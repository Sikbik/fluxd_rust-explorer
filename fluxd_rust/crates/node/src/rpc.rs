use std::collections::{BTreeSet, BinaryHeap, HashMap, HashSet};
use std::fs::{self, File};
use std::io::Write;
use std::net::{IpAddr, SocketAddr, ToSocketAddrs};
use std::path::{Path, PathBuf};
use std::process::{Command, Stdio};
use std::sync::{Arc, Mutex, OnceLock};
use std::time::{Duration, Instant, SystemTime, UNIX_EPOCH};

use base64::Engine;
use bech32::primitives::decode::CheckedHrpstring;
use bech32::{Bech32, Hrp};
use rand::RngCore;
use sapling_crypto::keys::{FullViewingKey as SaplingFullViewingKey, PreparedIncomingViewingKey};
use sapling_crypto::note_encryption::{
    try_sapling_note_decryption, SaplingDomain, Zip212Enforcement,
};
use sapling_crypto::{
    IncrementalWitness as SaplingIncrementalWitness, MerklePath as SaplingMerklePath,
    PaymentAddress,
};
use serde_json::{json, Number, Value};

struct RichListRow {
    address: String,
    script_hash: Hash256,
    balance: i64,
    cumulus_count: u32,
    nimbus_count: u32,
    stratus_count: u32,
}

struct RichListCache {
    computed_at: std::time::Instant,
    last_block_height: i64,
    total_supply: i64,
    total_addresses: u64,
    rows: Vec<RichListRow>,
}

impl RichListCache {
    fn to_response<S: fluxd_storage::KeyValueStore>(
        &self,
        chainstate: &ChainState<S>,
        page: u32,
        page_size: u32,
        min_balance: i64,
    ) -> Value {
        let eligible_addresses = self
            .rows
            .iter()
            .filter(|row| row.balance >= min_balance)
            .count() as u64;

        let page_u64 = page as u64;
        let page_size_u64 = page_size as u64;

        let total_pages = if eligible_addresses == 0 {
            0
        } else {
            ((eligible_addresses + page_size_u64 - 1) / page_size_u64).min(u64::from(u32::MAX))
        };

        let start = (page_u64 - 1).saturating_mul(page_size_u64) as usize;
        let mut remaining_skip = start;
        let mut addresses = Vec::new();

        for row in self.rows.iter() {
            if row.balance < min_balance {
                continue;
            }
            if remaining_skip > 0 {
                remaining_skip -= 1;
                continue;
            }
            if addresses.len() >= page_size as usize {
                break;
            }

            let mut tx_count = 0u64;
            let mut last_seen: Option<(u32, u32, Hash256)> = None;
            let end_height = u32::try_from(self.last_block_height.max(0)).unwrap_or(u32::MAX);

            let mut visitor = |delta: fluxd_chainstate::address_deltas::AddressDeltaEntry| {
                let key = (delta.height, delta.tx_index, delta.txid);
                if last_seen != Some(key) {
                    tx_count = tx_count.saturating_add(1);
                    last_seen = Some(key);
                }
                Ok(())
            };

            if let Err(err) = chainstate.for_each_address_delta_range(&row.script_hash, 0, end_height, &mut visitor)
            {
                log_warn!(
                    "richlist txCount scan failed for {}: {err}",
                    &row.address
                );
                tx_count = 0;
            }

            let rank = start
                .saturating_add(addresses.len())
                .saturating_add(1)
                .min(u32::MAX as usize);
            addresses.push(json!({
                "rank": rank,
                "address": &row.address,
                "balance": row.balance.to_string(),
                "txCount": tx_count,
                "cumulusCount": row.cumulus_count,
                "nimbusCount": row.nimbus_count,
                "stratusCount": row.stratus_count,
            }));
        }

        json!({
            "lastUpdate": current_unix_seconds_u64().to_string(),
            "generatedAt": current_unix_seconds_u64().to_string(),
            "lastBlockHeight": self.last_block_height,
            "totalSupply": self.total_supply.to_string(),
            "totalAddresses": eligible_addresses,
            "page": page,
            "pageSize": page_size,
            "totalPages": total_pages,
            "addresses": addresses,
        })
    }
}

static RICHLIST_CACHE: std::sync::OnceLock<std::sync::Mutex<Option<RichListCache>>> = std::sync::OnceLock::new();
static RICHLIST_REFRESH_IN_FLIGHT: std::sync::atomic::AtomicBool = std::sync::atomic::AtomicBool::new(false);
const RICHLIST_CACHE_TTL: std::time::Duration = std::time::Duration::from_secs(2 * 60);

fn richlist_cache() -> &'static std::sync::Mutex<Option<RichListCache>> {
    RICHLIST_CACHE.get_or_init(|| std::sync::Mutex::new(None))
}

fn parse_richlist_params(params: &[Value]) -> Result<(u32, u32, i64), RpcError> {
    if params.len() > 3 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "getrichlist expects 0 to 3 parameters",
        ));
    }

    let page = match params.get(0) {
        Some(value) if !value.is_null() => parse_u32(value, "page")?.max(1),
        _ => 1,
    };

    let page_size = match params.get(1) {
        Some(value) if !value.is_null() => parse_u32(value, "pageSize")?.clamp(1, 1000),
        _ => 100,
    };

    let min_balance = match params.get(2) {
        Some(value) if !value.is_null() => {
            let raw = parse_i64(value, "minBalance")?;
            if raw < 0 {
                return Err(RpcError::new(
                    RPC_INVALID_PARAMETER,
                    "minBalance must be non-negative",
                ));
            }
            raw
        }
        _ => 1,
    };

    Ok((page, page_size, min_balance))
}

fn refresh_richlist_cache<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    chain_params: &ChainParams,
) -> Result<(), RpcError> {
    let best = chainstate.best_block().map_err(map_internal)?;
    let last_block_height = best.map(|tip| tip.height.max(0) as i64).unwrap_or(0);
    let best_height = i32::try_from(last_block_height).unwrap_or(i32::MAX);

    let utxo_stats = chainstate.utxo_stats_or_compute().map_err(map_internal)?;
    let total_supply = utxo_stats.total_amount;

    struct RichListAccum {
        balance: i64,
        script_hash: Hash256,
        cumulus_count: u32,
        nimbus_count: u32,
        stratus_count: u32,
    }

    let mut balances: HashMap<String, RichListAccum> = HashMap::new();

    chainstate
        .for_each_utxo_entry(&mut |entry| {
            if entry.value <= 0 {
                return Ok(());
            }
            let Some(address) =
                script_pubkey_to_address(&entry.script_pubkey, chain_params.network)
            else {
                return Ok(());
            };

            let Some(script_hash) = fluxd_chainstate::address_index::script_hash(&entry.script_pubkey) else {
                return Ok(());
            };

            let slot = balances.entry(address).or_insert(RichListAccum {
                balance: 0,
                script_hash,
                cumulus_count: 0,
                nimbus_count: 0,
                stratus_count: 0,
            });

            slot.balance = slot
                .balance
                .checked_add(entry.value)
                .ok_or_else(|| fluxd_storage::StoreError::Backend("address balance overflow".to_string()))?;

            if let Some(tier) =
                fluxd_consensus::fluxnode_tier_from_collateral(best_height, entry.value, &chain_params.fluxnode)
            {
                match tier {
                    1 => slot.cumulus_count = slot.cumulus_count.saturating_add(1),
                    2 => slot.nimbus_count = slot.nimbus_count.saturating_add(1),
                    3 => slot.stratus_count = slot.stratus_count.saturating_add(1),
                    _ => {}
                }
            }

            Ok(())
        })
        .map_err(map_internal)?;

    let total_addresses = balances.len() as u64;

    let mut rows: Vec<RichListRow> = balances
        .into_iter()
        .map(|(address, accum)| RichListRow {
            address,
            script_hash: accum.script_hash,
            balance: accum.balance,
            cumulus_count: accum.cumulus_count,
            nimbus_count: accum.nimbus_count,
            stratus_count: accum.stratus_count,
        })
        .collect();
    rows.sort_unstable_by(|a, b| b.balance.cmp(&a.balance).then_with(|| a.address.cmp(&b.address)));

    let mut guard = richlist_cache()
        .lock()
        .map_err(|_| map_internal("richlist cache lock poisoned"))?;
    *guard = Some(RichListCache {
        computed_at: std::time::Instant::now(),
        last_block_height,
        total_supply,
        total_addresses,
        rows,
    });

    Ok(())
}
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use tokio::net::TcpListener;
use tokio::sync::{broadcast, watch};
use transparent::address::TransparentAddress;
use zcash_note_encryption::{EphemeralKeyBytes, ShieldedOutput, ENC_CIPHERTEXT_SIZE};
use zcash_primitives::transaction::builder::{BuildConfig, Builder as ZcashTxBuilder};
use zcash_proofs::prover::LocalTxProver;
use zcash_protocol::consensus::{BlockHeight, NetworkType, NetworkUpgrade, Parameters};
use zcash_protocol::memo::MemoBytes;
use zcash_protocol::value::Zatoshis;

use fluxd_chainstate::index::HeaderEntry;
use fluxd_chainstate::state::{ChainState, ChainStateError};
use fluxd_chainstate::validation::ValidationFlags;
use fluxd_consensus::constants::{
    COINBASE_MATURITY, FLUXNODE_DOS_REMOVE_AMOUNT, FLUXNODE_DOS_REMOVE_AMOUNT_V2,
    FLUXNODE_START_TX_EXPIRATION_HEIGHT, FLUXNODE_START_TX_EXPIRATION_HEIGHT_V2, MAX_BLOCK_SIGOPS,
    MAX_BLOCK_SIZE, PROTOCOL_VERSION,
};
use fluxd_consensus::money::{money_range, CENT, COIN, MAX_MONEY};
use fluxd_consensus::params::{hash256_from_hex, ChainParams, Network};
use fluxd_consensus::upgrades::{
    current_epoch_branch_id, network_upgrade_active, network_upgrade_state, UpgradeIndex,
    UpgradeState, ALL_UPGRADES, NETWORK_UPGRADE_INFO,
};
use fluxd_consensus::Hash256;
use fluxd_consensus::{
    block_subsidy, exchange_fund_amount, foundation_fund_amount, swap_pool_amount,
};
use fluxd_fluxnode::storage::FluxnodeRecord;
use fluxd_pow::difficulty::compact_to_u256;
use fluxd_primitives::block::{Block, CURRENT_VERSION, PON_VERSION};
use fluxd_primitives::hash::{hash160, sha256d};
use fluxd_primitives::merkleblock::{MerkleBlock, PartialMerkleTree};
use fluxd_primitives::outpoint::OutPoint;
use fluxd_primitives::transaction::{
    FluxnodeDelegates, FluxnodeStartV5, FluxnodeStartV6, FluxnodeStartVariantV6, FluxnodeTx,
    FluxnodeTxV5, FluxnodeTxV6, Transaction, TxIn, TxOut, FLUXNODE_INTERNAL_NORMAL_TX_VERSION,
    FLUXNODE_INTERNAL_P2SH_TX_VERSION, FLUXNODE_TX_FEATURE_DELEGATES_BIT,
    FLUXNODE_TX_TYPE_NORMAL_BIT, FLUXNODE_TX_TYPE_P2SH_BIT, FLUXNODE_TX_UPGRADEABLE_VERSION,
    FLUXNODE_TX_VERSION, SAPLING_VERSION_GROUP_ID,
};
use fluxd_primitives::{
    address_to_script_pubkey, script_pubkey_to_address, secret_key_to_wif, wif_to_secret_key,
    AddressError,
};
use fluxd_script::interpreter::{verify_script, STANDARD_SCRIPT_VERIFY_FLAGS};
use fluxd_script::message::{recover_signed_message_pubkey, signed_message_hash};
use fluxd_script::sighash::{
    signature_hash, SighashType, SIGHASH_ALL, SIGHASH_ANYONECANPAY, SIGHASH_NONE, SIGHASH_SINGLE,
};
use fluxd_script::standard::{classify_script_pubkey, ScriptType};
use primitive_types::U256;
use secp256k1::{ecdsa::RecoverableSignature, Message, PublicKey, Secp256k1, SecretKey};

use crate::fee_estimator::FeeEstimator;
use crate::mempool::{build_mempool_entry, Mempool, MempoolErrorKind, MempoolPolicy};
use crate::p2p::{NetTotals, PeerKind, PeerRegistry};
use crate::peer_book::HeaderPeerBook;
use crate::stats::{hash256_to_hex, HeaderMetrics, MempoolMetrics};
use crate::wallet::{Wallet, WalletError, WALLET_FILE_VERSION};
use crate::AddrBook;
use crate::{db_info, Backend, Store};

const MAX_REQUEST_BYTES: usize = 1024 * 1024;
const RPC_REALM: &str = "fluxd";
pub(crate) const RPC_COOKIE_FILE: &str = "rpc.cookie";

const RPC_INVALID_PARAMETER: i64 = -8;
const RPC_MISC_ERROR: i64 = -1;
const RPC_TYPE_ERROR: i64 = -3;
const RPC_WALLET_ERROR: i64 = -4;
const RPC_INVALID_ADDRESS_OR_KEY: i64 = -5;
const RPC_WALLET_KEYPOOL_RAN_OUT: i64 = -12;
const RPC_WALLET_UNLOCK_NEEDED: i64 = -13;
const RPC_WALLET_PASSPHRASE_INCORRECT: i64 = -14;
const RPC_WALLET_WRONG_ENC_STATE: i64 = -15;
const RPC_DESERIALIZATION_ERROR: i64 = -22;
const RPC_TRANSACTION_ERROR: i64 = -25;
const RPC_TRANSACTION_REJECTED: i64 = -26;
const RPC_TRANSACTION_ALREADY_IN_CHAIN: i64 = -27;
const RPC_CLIENT_NODE_ALREADY_ADDED: i64 = -23;
const RPC_CLIENT_NODE_NOT_ADDED: i64 = -24;
const RPC_CLIENT_NODE_NOT_CONNECTED: i64 = -29;
const RPC_METHOD_NOT_FOUND: i64 = -32601;
const RPC_INVALID_REQUEST: i64 = -32600;
const RPC_PARSE_ERROR: i64 = -32700;
const RPC_INTERNAL_ERROR: i64 = -32603;

const RPC_METHODS: &[&str] = &[
    "help",
    "getinfo",
    "ping",
    "stop",
    "restart",
    "reindex",
    "rescanblockchain",
    "importaddress",
    "importwallet",
    "getnewaddress",
    "getrawchangeaddress",
    "importprivkey",
    "dumpprivkey",
    "getbalance",
    "getunconfirmedbalance",
    "getreceivedbyaddress",
    "listunspent",
    "lockunspent",
    "listlockunspent",
    "listaddressgroupings",
    "getwalletinfo",
    "encryptwallet",
    "walletpassphrase",
    "walletpassphrasechange",
    "walletlock",
    "signmessage",
    "backupwallet",
    "dumpwallet",
    "z_exportwallet",
    "zexportwallet",
    "getdbinfo",
    "getblockcount",
    "getbestblockhash",
    "getblockhash",
    "getblockheader",
    "getblock",
    "getblockchaininfo",
    "getdifficulty",
    "getchaintips",
    "getblocksubsidy",
    "getblockhashes",
    "createrawtransaction",
    "decoderawtransaction",
    "decodescript",
    "validateaddress",
    "verifymessage",
    "createmultisig",
    "addmultisigaddress",
    "getrawtransaction",
    "gettransaction",
    "listtransactions",
    "listsinceblock",
    "listreceivedbyaddress",
    "keypoolrefill",
    "settxfee",
    "fundrawtransaction",
    "signrawtransaction",
    "sendrawtransaction",
    "sendfrom",
    "sendtoaddress",
    "sendmany",
    "zvalidateaddress",
    "z_validateaddress",
    "zcrawjoinsplit",
    "zcrawreceive",
    "zcrawkeygen",
    "zexportkey",
    "z_exportkey",
    "zexportviewingkey",
    "z_exportviewingkey",
    "zgetbalance",
    "z_getbalance",
    "zgetmigrationstatus",
    "z_getmigrationstatus",
    "zgetnewaddress",
    "z_getnewaddress",
    "zgetoperationresult",
    "z_getoperationresult",
    "zgetoperationstatus",
    "z_getoperationstatus",
    "zgettotalbalance",
    "z_gettotalbalance",
    "zimportkey",
    "z_importkey",
    "zimportviewingkey",
    "z_importviewingkey",
    "zimportwallet",
    "z_importwallet",
    "zlistaddresses",
    "z_listaddresses",
    "zlistoperationids",
    "z_listoperationids",
    "zlistreceivedbyaddress",
    "z_listreceivedbyaddress",
    "zlistunspent",
    "z_listunspent",
    "zsendmany",
    "z_sendmany",
    "zsetmigration",
    "z_setmigration",
    "zshieldcoinbase",
    "z_shieldcoinbase",
    "getmempoolinfo",
    "getrawmempool",
    "gettxout",
    "gettxoutproof",
    "verifytxoutproof",
    "gettxoutsetinfo",
    "getindexstats",
    "getrichlist",
    "getblockdeltas",
    "getspentinfo",
    "getaddressutxos",
    "getaddressbalance",
    "getaddressdeltas",
    "getaddresstxids",
    "getaddresspagecursor",
    "getaddressmempool",
    "getmininginfo",
    "getblocktemplate",
    "submitblock",
    "getnetworkhashps",
    "getnetworksolps",
    "getlocalsolps",
    "estimatefee",
    "estimatepriority",
    "prioritisetransaction",
    "getconnectioncount",
    "getnettotals",
    "listbanned",
    "getnetworkinfo",
    "getpeerinfo",
    "getdeprecationinfo",
    "getfluxnodecount",
    "getzelnodecount",
    "listfluxnodes",
    "listzelnodes",
    "viewdeterministicfluxnodelist",
    "viewdeterministiczelnodelist",
    "fluxnodecurrentwinner",
    "zelnodecurrentwinner",
    "getfluxnodestatus",
    "getzelnodestatus",
    "getdoslist",
    "getstartlist",
    "getbenchmarks",

    "getbenchstatus",
    "startbenchmark",
    "stopbenchmark",
    "startfluxbenchd",
    "stopfluxbenchd",
    "startzelbenchd",
    "stopzelbenchd",
    "zcbenchmark",
    "verifychain",
    "addnode",
    "disconnectnode",
    "getaddednodeinfo",
    "setban",
    "clearbanned",
];
pub struct RpcAuth {
    user: String,
    pass: String,
}

#[derive(Clone, Debug)]
pub struct RpcAllowList {
    rules: Vec<IpNet>,
}

#[derive(Clone)]
struct RpcContext<S> {
    chainstate: Arc<ChainState<S>>,
    store: Arc<Store>,
    write_lock: Arc<Mutex<()>>,
    mempool: Arc<Mutex<Mempool>>,
    mempool_policy: Arc<MempoolPolicy>,
    mempool_metrics: Arc<MempoolMetrics>,
    header_metrics: Arc<HeaderMetrics>,
    fee_estimator: Arc<Mutex<FeeEstimator>>,
    tx_confirm_target: u32,
    mempool_flags: ValidationFlags,
    miner_address: Option<String>,
    chain_params: ChainParams,
    data_dir: PathBuf,
    params_dir: PathBuf,
    net_totals: Arc<NetTotals>,
    peer_registry: Arc<PeerRegistry>,
    header_peer_book: Arc<HeaderPeerBook>,
    addr_book: Arc<AddrBook>,
    added_nodes: Arc<Mutex<HashSet<String>>>,
    tx_announce: broadcast::Sender<Hash256>,
    wallet: Arc<Mutex<Wallet>>,
    shutdown_tx: watch::Sender<bool>,
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
enum AsyncOpState {
    Queued,
    Executing,
    Success,
    Failed,
}

impl AsyncOpState {
    fn as_str(self) -> &'static str {
        match self {
            Self::Queued => "queued",
            Self::Executing => "executing",
            Self::Success => "success",
            Self::Failed => "failed",
        }
    }

    fn parse_filter(raw: &str) -> Option<Self> {
        match raw {
            "queued" => Some(Self::Queued),
            "executing" => Some(Self::Executing),
            "success" => Some(Self::Success),
            "failed" => Some(Self::Failed),
            _ => None,
        }
    }
}

#[derive(Clone, Debug)]
struct AsyncOpError {
    code: i64,
    message: String,
}

#[derive(Clone, Debug)]
struct AsyncOpEntry {
    operationid: String,
    status: AsyncOpState,
    method: String,
    params: Value,
    creation_time: u64,
    started_time: Option<u64>,
    finished_time: Option<u64>,
    result: Option<Value>,
    error: Option<AsyncOpError>,
}

impl AsyncOpEntry {
    fn status_object(&self) -> Value {
        let mut obj = serde_json::Map::new();
        obj.insert(
            "operationid".to_string(),
            Value::String(self.operationid.clone()),
        );
        obj.insert(
            "status".to_string(),
            Value::String(self.status.as_str().to_string()),
        );
        obj.insert(
            "creation_time".to_string(),
            Value::Number(Number::from(self.creation_time)),
        );
        obj.insert("method".to_string(), Value::String(self.method.clone()));
        obj.insert("params".to_string(), self.params.clone());
        if let (Some(started), Some(finished)) = (self.started_time, self.finished_time) {
            if finished >= started {
                obj.insert(
                    "execution_time".to_string(),
                    Value::Number(Number::from(finished - started)),
                );
            }
        }
        if self.status == AsyncOpState::Success {
            if let Some(result) = self.result.clone() {
                obj.insert("result".to_string(), result);
            }
        }
        if self.status == AsyncOpState::Failed {
            if let Some(err) = self.error.as_ref() {
                obj.insert(
                    "error".to_string(),
                    json!({
                        "code": err.code,
                        "message": err.message,
                    }),
                );
            }
        }
        Value::Object(obj)
    }

    fn is_finished(&self) -> bool {
        matches!(self.status, AsyncOpState::Success | AsyncOpState::Failed)
    }
}

#[derive(Default)]
struct AsyncOpManager {
    ops: HashMap<String, AsyncOpEntry>,
}

impl AsyncOpManager {
    fn insert(&mut self, entry: AsyncOpEntry) {
        self.ops.insert(entry.operationid.clone(), entry);
    }

    fn update_status(&mut self, opid: &str, status: AsyncOpState) {
        let Some(entry) = self.ops.get_mut(opid) else {
            return;
        };
        entry.status = status;
        match status {
            AsyncOpState::Executing => {
                if entry.started_time.is_none() {
                    entry.started_time = Some(current_unix_seconds_u64());
                }
            }
            AsyncOpState::Success | AsyncOpState::Failed => {
                entry.finished_time = Some(current_unix_seconds_u64());
            }
            AsyncOpState::Queued => {}
        }
    }

    fn set_result(&mut self, opid: &str, result: Value) {
        if let Some(entry) = self.ops.get_mut(opid) {
            entry.result = Some(result);
        }
    }

    fn set_error(&mut self, opid: &str, code: i64, message: String) {
        if let Some(entry) = self.ops.get_mut(opid) {
            entry.error = Some(AsyncOpError { code, message });
        }
    }

    fn list_ids(&self, filter: Option<AsyncOpState>) -> Vec<Value> {
        let mut ids: Vec<&str> = self
            .ops
            .values()
            .filter(|entry| filter.map_or(true, |f| entry.status == f))
            .map(|entry| entry.operationid.as_str())
            .collect();
        ids.sort_unstable();
        ids.into_iter()
            .map(|id| Value::String(id.to_string()))
            .collect()
    }

    fn status_objects(&self, ids: Option<&[String]>) -> Vec<Value> {
        let mut out: Vec<Value> = Vec::new();
        match ids {
            Some(ids) => {
                for id in ids {
                    if let Some(entry) = self.ops.get(id) {
                        out.push(entry.status_object());
                    }
                }
            }
            None => {
                let mut entries: Vec<&AsyncOpEntry> = self.ops.values().collect();
                entries.sort_by(|a, b| a.operationid.cmp(&b.operationid));
                out.extend(entries.into_iter().map(|entry| entry.status_object()));
            }
        }
        out
    }

    fn take_finished(&mut self, ids: Option<&[String]>) -> Vec<Value> {
        let mut to_take: Vec<String> = Vec::new();
        match ids {
            Some(ids) => {
                for id in ids {
                    if self.ops.get(id).is_some_and(|entry| entry.is_finished()) {
                        to_take.push(id.clone());
                    }
                }
            }
            None => {
                for (id, entry) in &self.ops {
                    if entry.is_finished() {
                        to_take.push(id.clone());
                    }
                }
            }
        }
        to_take.sort_unstable();
        let mut out = Vec::new();
        for id in to_take {
            if let Some(entry) = self.ops.remove(&id) {
                out.push(entry.status_object());
            }
        }
        out
    }
}

static ASYNC_OP_MANAGER: OnceLock<Mutex<AsyncOpManager>> = OnceLock::new();

fn async_ops() -> &'static Mutex<AsyncOpManager> {
    ASYNC_OP_MANAGER.get_or_init(|| Mutex::new(AsyncOpManager::default()))
}

#[derive(Clone, Debug)]
pub(crate) struct AsyncOpSnapshot {
    pub operationid: String,
    pub status: String,
    pub method: String,
    pub creation_time: u64,
    pub started_time: Option<u64>,
    pub finished_time: Option<u64>,
}

pub(crate) fn tui_async_ops_snapshot(limit: usize) -> Vec<AsyncOpSnapshot> {
    let guard = match async_ops().lock() {
        Ok(guard) => guard,
        Err(_) => return Vec::new(),
    };
    let mut out: Vec<AsyncOpSnapshot> = guard
        .ops
        .values()
        .map(|entry| AsyncOpSnapshot {
            operationid: entry.operationid.clone(),
            status: entry.status.as_str().to_string(),
            method: entry.method.clone(),
            creation_time: entry.creation_time,
            started_time: entry.started_time,
            finished_time: entry.finished_time,
        })
        .collect();
    out.sort_by(|a, b| b.creation_time.cmp(&a.creation_time));
    if limit > 0 && out.len() > limit {
        out.truncate(limit);
    }
    out
}

fn current_unix_seconds_u64() -> u64 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_secs()
}

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
enum IpNet {
    V4 { network: u32, mask: u32 },
    V6 { network: u128, mask: u128 },
}

impl RpcAllowList {
    pub fn from_allow_ips(allow_ips: &[String]) -> Result<Self, String> {
        let mut rules = Vec::with_capacity(allow_ips.len().saturating_add(2));
        rules.push(
            IpNet::from_cidr(IpAddr::V4(std::net::Ipv4Addr::LOCALHOST), None)
                .map_err(|_| "failed to build default RPC allowlist".to_string())?,
        );
        rules.push(
            IpNet::from_cidr(IpAddr::V6(std::net::Ipv6Addr::LOCALHOST), None)
                .map_err(|_| "failed to build default RPC allowlist".to_string())?,
        );
        for raw in allow_ips {
            rules.push(IpNet::parse(raw)?);
        }
        Ok(Self { rules })
    }

    pub fn allows(&self, ip: IpAddr) -> bool {
        match ip {
            IpAddr::V6(v6) => {
                if let Some(v4) = v6.to_ipv4() {
                    if self.rules.iter().any(|rule| rule.contains(IpAddr::V4(v4))) {
                        return true;
                    }
                }
                self.rules.iter().any(|rule| rule.contains(IpAddr::V6(v6)))
            }
            other => self.rules.iter().any(|rule| rule.contains(other)),
        }
    }
}

impl IpNet {
    fn parse(raw: &str) -> Result<Self, String> {
        let raw = raw.trim();
        if raw.is_empty() {
            return Err("rpcallowip entry is empty".to_string());
        }

        let (ip_raw, prefix_raw) = match raw.split_once('/') {
            Some((ip, prefix)) => (ip, Some(prefix)),
            None => (raw, None),
        };

        let ip = ip_raw
            .trim()
            .parse::<IpAddr>()
            .map_err(|_| format!("invalid rpcallowip '{raw}'"))?;
        let prefix = match prefix_raw {
            None => None,
            Some(prefix) => {
                let prefix = prefix.trim();
                if prefix.is_empty() {
                    return Err(format!("invalid rpcallowip '{raw}'"));
                }
                Some(
                    prefix
                        .parse::<u8>()
                        .map_err(|_| format!("invalid rpcallowip '{raw}'"))?,
                )
            }
        };
        Self::from_cidr(ip, prefix).map_err(|_| format!("invalid rpcallowip '{raw}'"))
    }

    fn from_cidr(ip: IpAddr, prefix: Option<u8>) -> Result<Self, ()> {
        match ip {
            IpAddr::V4(ip) => {
                let prefix = prefix.unwrap_or(32);
                if prefix > 32 {
                    return Err(());
                }
                let mask = if prefix == 0 {
                    0
                } else {
                    (!0u32).checked_shl(u32::from(32 - prefix)).ok_or(())?
                };
                let ip_u32 = u32::from_be_bytes(ip.octets());
                let network = ip_u32 & mask;
                Ok(IpNet::V4 { network, mask })
            }
            IpAddr::V6(ip) => {
                let prefix = prefix.unwrap_or(128);
                if prefix > 128 {
                    return Err(());
                }
                let mask = if prefix == 0 {
                    0
                } else {
                    (!0u128).checked_shl(u32::from(128 - prefix)).ok_or(())?
                };
                let ip_u128 = u128::from_be_bytes(ip.octets());
                let network = ip_u128 & mask;
                Ok(IpNet::V6 { network, mask })
            }
        }
    }

    fn contains(&self, ip: IpAddr) -> bool {
        match (self, ip) {
            (IpNet::V4 { network, mask }, IpAddr::V4(ip)) => {
                let ip = u32::from_be_bytes(ip.octets());
                (ip & mask) == *network
            }
            (IpNet::V6 { network, mask }, IpAddr::V6(ip)) => {
                let ip = u128::from_be_bytes(ip.octets());
                (ip & mask) == *network
            }
            _ => false,
        }
    }
}

pub fn load_or_create_auth(
    user: Option<String>,
    pass: Option<String>,
    data_dir: &Path,
) -> Result<RpcAuth, String> {
    if user.is_some() || pass.is_some() {
        let user =
            user.ok_or_else(|| "missing --rpc-user (required with --rpc-pass)".to_string())?;
        let pass =
            pass.ok_or_else(|| "missing --rpc-pass (required with --rpc-user)".to_string())?;
        return Ok(RpcAuth { user, pass });
    }

    let cookie_path = data_dir.join(RPC_COOKIE_FILE);
    if cookie_path.exists() {
        let contents = fs::read_to_string(&cookie_path).map_err(|err| err.to_string())?;
        if let Some((user, pass)) = contents.trim().split_once(':') {
            return Ok(RpcAuth {
                user: user.to_string(),
                pass: pass.to_string(),
            });
        }
    }

    let mut bytes = [0u8; 32];
    rand::thread_rng().fill_bytes(&mut bytes);
    let user = "__cookie__".to_string();
    let pass = hex_bytes(&bytes);
    write_cookie(&cookie_path, &user, &pass)?;
    log_info!("RPC auth cookie: {}", cookie_path.display());
    Ok(RpcAuth { user, pass })
}

#[allow(clippy::too_many_arguments)]
pub async fn serve_rpc<S: fluxd_storage::KeyValueStore + Send + Sync + 'static>(
    addr: SocketAddr,
    auth: RpcAuth,
    allowlist: RpcAllowList,
    chainstate: Arc<ChainState<S>>,
    store: Arc<Store>,
    write_lock: Arc<Mutex<()>>,
    mempool: Arc<Mutex<Mempool>>,
    mempool_policy: Arc<MempoolPolicy>,
    mempool_metrics: Arc<MempoolMetrics>,
    header_metrics: Arc<HeaderMetrics>,
    fee_estimator: Arc<Mutex<FeeEstimator>>,
    tx_confirm_target: u32,
    mempool_flags: ValidationFlags,
    miner_address: Option<String>,
    params: ChainParams,
    data_dir: PathBuf,
    params_dir: PathBuf,
    net_totals: Arc<NetTotals>,
    peer_registry: Arc<PeerRegistry>,
    header_peer_book: Arc<HeaderPeerBook>,
    addr_book: Arc<AddrBook>,
    added_nodes: Arc<Mutex<HashSet<String>>>,
    tx_announce: broadcast::Sender<Hash256>,
    wallet: Arc<Mutex<Wallet>>,
    shutdown_tx: watch::Sender<bool>,
) -> Result<(), String> {
    let listener = TcpListener::bind(addr)
        .await
        .map_err(|err| format!("rpc bind failed: {err}"))?;
    log_info!("RPC listening on http://{addr}");

    let auth = Arc::new(auth);
    let allowlist = Arc::new(allowlist);
    loop {
        let (mut stream, peer_addr) = listener
            .accept()
            .await
            .map_err(|err| format!("rpc accept failed: {err}"))?;
        if !allowlist.allows(peer_addr.ip()) {
            let response = build_forbidden();
            tokio::spawn(async move {
                let _ = stream.write_all(&response).await;
            });
            continue;
        }
        let auth = Arc::clone(&auth);
        let chainstate = Arc::clone(&chainstate);
        let store = Arc::clone(&store);
        let write_lock = Arc::clone(&write_lock);
        let mempool = Arc::clone(&mempool);
        let mempool_policy = Arc::clone(&mempool_policy);
        let mempool_metrics = Arc::clone(&mempool_metrics);
        let header_metrics = Arc::clone(&header_metrics);
        let fee_estimator = Arc::clone(&fee_estimator);
        let tx_confirm_target = tx_confirm_target;
        let mempool_flags = mempool_flags.clone();
        let miner_address = miner_address.clone();
        let params = params.clone();
        let data_dir = data_dir.clone();
        let params_dir = params_dir.clone();
        let net_totals = Arc::clone(&net_totals);
        let peer_registry = Arc::clone(&peer_registry);
        let header_peer_book = Arc::clone(&header_peer_book);
        let addr_book = Arc::clone(&addr_book);
        let added_nodes = Arc::clone(&added_nodes);
        let tx_announce = tx_announce.clone();
        let wallet = Arc::clone(&wallet);
        let shutdown_tx = shutdown_tx.clone();
        tokio::spawn(async move {
            if let Err(err) = handle_connection(
                stream,
                auth,
                chainstate,
                store,
                write_lock,
                mempool,
                mempool_policy,
                mempool_metrics,
                header_metrics,
                fee_estimator,
                tx_confirm_target,
                mempool_flags,
                miner_address,
                params,
                data_dir,
                params_dir,
                net_totals,
                peer_registry,
                header_peer_book,
                addr_book,
                added_nodes,
                tx_announce,
                wallet,
                shutdown_tx,
            )
            .await
            {
                log_warn!("rpc error: {err}");
            }
        });
    }
}

#[allow(clippy::too_many_arguments)]
async fn handle_connection<S: fluxd_storage::KeyValueStore + Send + Sync + 'static>(
    mut stream: tokio::net::TcpStream,
    auth: Arc<RpcAuth>,
    chainstate: Arc<ChainState<S>>,
    store: Arc<Store>,
    write_lock: Arc<Mutex<()>>,
    mempool: Arc<Mutex<Mempool>>,
    mempool_policy: Arc<MempoolPolicy>,
    mempool_metrics: Arc<MempoolMetrics>,
    header_metrics: Arc<HeaderMetrics>,
    fee_estimator: Arc<Mutex<FeeEstimator>>,
    tx_confirm_target: u32,
    mempool_flags: ValidationFlags,
    miner_address: Option<String>,
    chain_params: ChainParams,
    data_dir: PathBuf,
    params_dir: PathBuf,
    net_totals: Arc<NetTotals>,
    peer_registry: Arc<PeerRegistry>,
    header_peer_book: Arc<HeaderPeerBook>,
    addr_book: Arc<AddrBook>,
    added_nodes: Arc<Mutex<HashSet<String>>>,
    tx_announce: broadcast::Sender<Hash256>,
    wallet: Arc<Mutex<Wallet>>,
    shutdown_tx: watch::Sender<bool>,
) -> Result<(), String> {
    let request = read_http_request(&mut stream).await?;
    let is_daemon = request.path.starts_with("/daemon/");
    if !is_daemon && request.method != "POST" {
        let response = build_response("405 Method Not Allowed", "text/plain", "method not allowed");
        stream
            .write_all(&response)
            .await
            .map_err(|err| err.to_string())?;
        return Ok(());
    }

    if !auth.check(
        request
            .headers
            .get("authorization")
            .map(|value| value.as_str()),
    ) {
        let response = build_unauthorized();
        stream
            .write_all(&response)
            .await
            .map_err(|err| err.to_string())?;
        return Ok(());
    }

    let ctx = RpcContext {
        chainstate,
        store,
        write_lock,
        mempool,
        mempool_policy,
        mempool_metrics,
        header_metrics,
        fee_estimator,
        tx_confirm_target,
        mempool_flags,
        miner_address,
        chain_params,
        data_dir,
        params_dir,
        net_totals,
        peer_registry,
        header_peer_book,
        addr_book,
        added_nodes,
        tx_announce,
        wallet,
        shutdown_tx,
    };

    if is_daemon {
        let method = request
            .path
            .trim_start_matches("/daemon/")
            .trim_matches('/');
        if method.is_empty() {
            let response = build_response("404 Not Found", "text/plain", "not found");
            stream
                .write_all(&response)
                .await
                .map_err(|err| err.to_string())?;
            return Ok(());
        }
        let rpc_response = if method == "getblocktemplate" {
            let params = if request.method == "GET" {
                parse_query_params(request.query.as_deref().unwrap_or(""))
            } else if request.method == "POST" {
                parse_body_params(&request.body)
            } else {
                Err(RpcError::new(RPC_INVALID_REQUEST, "method not allowed"))
            };

            match params {
                Err(err) => rpc_error(Value::Null, err.code, err.message),
                Ok(params) => {
                    let mut longpoll_error: Option<RpcError> = None;
                    if let Some((watched_hash, watched_revision)) =
                        longpoll_state_from_params(&params)
                    {
                        match current_longpoll_state(ctx.chainstate.as_ref(), ctx.mempool.as_ref())
                        {
                            Ok((current_hash, current_revision))
                                if current_hash == watched_hash
                                    && current_revision == watched_revision =>
                            {
                                if let Err(err) = wait_longpoll(
                                    ctx.chainstate.as_ref(),
                                    ctx.mempool.as_ref(),
                                    watched_hash,
                                    watched_revision,
                                )
                                .await
                                {
                                    longpoll_error = Some(err);
                                }
                            }
                            Ok(_) => {}
                            Err(err) => longpoll_error = Some(err),
                        }
                    }

                    if let Some(err) = longpoll_error {
                        rpc_error(Value::Null, err.code, err.message)
                    } else {
                        match dispatch_method(method, params, &ctx) {
                            Ok(value) => rpc_ok(Value::Null, value),
                            Err(err) => rpc_error(Value::Null, err.code, err.message),
                        }
                    }
                }
            }
        } else {
            match handle_daemon_request(method, &request, &ctx) {
                Ok(value) => rpc_ok(Value::Null, value),
                Err(err) => rpc_error(Value::Null, err.code, err.message),
            }
        };
        let body = rpc_response.to_string();
        let response = build_response("200 OK", "application/json", &body);
        stream
            .write_all(&response)
            .await
            .map_err(|err| err.to_string())?;
        return Ok(());
    }

    if let Some(rpc_response) =
        handle_json_rpc_getblocktemplate_longpoll(&request.body, &ctx).await?
    {
        let body = rpc_response.to_string();
        let response = build_response("200 OK", "application/json", &body);
        stream
            .write_all(&response)
            .await
            .map_err(|err| err.to_string())?;
        return Ok(());
    }

    let rpc_response = match handle_rpc_request(&request.body, &ctx) {
        Ok(value) => value,
        Err(err) => err,
    };
    let body = rpc_response.to_string();
    let response = build_response("200 OK", "application/json", &body);
    stream
        .write_all(&response)
        .await
        .map_err(|err| err.to_string())?;
    Ok(())
}

fn parse_longpollid(value: &str) -> Option<(Hash256, u64)> {
    if value.len() < 64 {
        return None;
    }
    let (hash_hex, rest) = value.split_at(64);
    let hash = hash256_from_hex(hash_hex).ok()?;
    let revision = rest.parse::<u64>().ok()?;
    Some((hash, revision))
}

fn longpoll_state_from_params(params: &[Value]) -> Option<(Hash256, u64)> {
    let obj = params.get(0)?.as_object()?;
    let value = obj.get("longpollid")?.as_str()?;
    parse_longpollid(value)
}

fn current_longpoll_state<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    mempool: &Mutex<Mempool>,
) -> Result<(Hash256, u64), RpcError> {
    let tip_hash = chainstate
        .best_block()
        .map_err(map_internal)?
        .map(|tip| tip.hash)
        .unwrap_or([0u8; 32]);
    let revision = mempool
        .lock()
        .map_err(|_| map_internal("mempool lock poisoned"))?
        .revision();
    Ok((tip_hash, revision))
}

async fn wait_longpoll<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    mempool: &Mutex<Mempool>,
    watched_hash: Hash256,
    watched_revision: u64,
) -> Result<(), RpcError> {
    loop {
        let (current_hash, current_revision) = current_longpoll_state(chainstate, mempool)?;
        if current_hash != watched_hash || current_revision != watched_revision {
            return Ok(());
        }
        tokio::time::sleep(Duration::from_secs(1)).await;
    }
}

async fn handle_json_rpc_getblocktemplate_longpoll<S: fluxd_storage::KeyValueStore + 'static>(
    body: &[u8],
    ctx: &RpcContext<S>,
) -> Result<Option<Value>, String> {
    let value: Value = match serde_json::from_slice(body) {
        Ok(value) => value,
        Err(_) => return Ok(None),
    };

    if value.is_array() {
        return Ok(None);
    }

    let id = value.get("id").cloned().unwrap_or(Value::Null);
    let method = match value.get("method").and_then(|value| value.as_str()) {
        Some(method) => method,
        None => return Ok(None),
    };
    if method != "getblocktemplate" {
        return Ok(None);
    }

    let params_value = value
        .get("params")
        .cloned()
        .unwrap_or(Value::Array(Vec::new()));
    let params = match params_value {
        Value::Array(values) => values,
        Value::Null => Vec::new(),
        _ => {
            return Ok(Some(rpc_error(
                id,
                RPC_INVALID_REQUEST,
                "params must be an array",
            )))
        }
    };

    if let Some((watched_hash, watched_revision)) = longpoll_state_from_params(&params) {
        let (current_hash, current_revision) =
            match current_longpoll_state(ctx.chainstate.as_ref(), ctx.mempool.as_ref()) {
                Ok(state) => state,
                Err(err) => return Ok(Some(rpc_error(id, err.code, err.message))),
            };
        if current_hash == watched_hash && current_revision == watched_revision {
            if let Err(err) = wait_longpoll(
                ctx.chainstate.as_ref(),
                ctx.mempool.as_ref(),
                watched_hash,
                watched_revision,
            )
            .await
            {
                return Ok(Some(rpc_error(id, err.code, err.message)));
            }
        }
    }

    let rpc_response = match dispatch_method(method, params, ctx) {
        Ok(value) => rpc_ok(id, value),
        Err(err) => rpc_error(id, err.code, err.message),
    };
    Ok(Some(rpc_response))
}

fn handle_daemon_request<S: fluxd_storage::KeyValueStore + 'static>(
    method: &str,
    request: &HttpRequest,
    ctx: &RpcContext<S>,
) -> Result<Value, RpcError> {
    let params = if request.method == "GET" {
        parse_query_params(request.query.as_deref().unwrap_or(""))?
    } else if request.method == "POST" {
        parse_body_params(&request.body)?
    } else {
        return Err(RpcError::new(RPC_INVALID_REQUEST, "method not allowed"));
    };
    dispatch_method(method, params, ctx)
}

fn handle_rpc_request<S: fluxd_storage::KeyValueStore + 'static>(
    body: &[u8],
    ctx: &RpcContext<S>,
) -> Result<Value, Value> {
    let value: Value = serde_json::from_slice(body)
        .map_err(|err| rpc_error(Value::Null, RPC_PARSE_ERROR, format!("parse error: {err}")))?;

    if value.is_array() {
        return Err(rpc_error(
            Value::Null,
            RPC_INVALID_REQUEST,
            "batch requests are not supported",
        ));
    }

    let id = value.get("id").cloned().unwrap_or(Value::Null);
    let method = value
        .get("method")
        .and_then(|value| value.as_str())
        .ok_or_else(|| rpc_error(id.clone(), RPC_INVALID_REQUEST, "missing method"))?;
    let params_value = value
        .get("params")
        .cloned()
        .unwrap_or(Value::Array(Vec::new()));
    let params = match params_value {
        Value::Array(values) => values,
        Value::Null => Vec::new(),
        _ => {
            return Err(rpc_error(
                id,
                RPC_INVALID_REQUEST,
                "params must be an array",
            ))
        }
    };

    let result = dispatch_method(method, params, ctx);

    match result {
        Ok(value) => Ok(rpc_ok(id, value)),
        Err(err) => Err(rpc_error(id, err.code, err.message)),
    }
}

fn parse_body_params(body: &[u8]) -> Result<Vec<Value>, RpcError> {
    if body.is_empty() {
        return Ok(Vec::new());
    }
    let value: Value = serde_json::from_slice(body)
        .map_err(|err| RpcError::new(RPC_PARSE_ERROR, format!("parse error: {err}")))?;
    match value {
        Value::Array(values) => Ok(values),
        Value::Object(mut map) => {
            if let Some(params_value) = map.remove("params") {
                match params_value {
                    Value::Array(values) => Ok(values),
                    Value::Null => Ok(Vec::new()),
                    other => Ok(vec![other]),
                }
            } else {
                Ok(vec![Value::Object(map)])
            }
        }
        Value::Null => Ok(Vec::new()),
        other => Ok(vec![other]),
    }
}

fn parse_query_params(query: &str) -> Result<Vec<Value>, RpcError> {
    if query.is_empty() {
        return Ok(Vec::new());
    }
    let mut params = Vec::new();
    for pair in query.split('&') {
        if pair.is_empty() {
            continue;
        }
        let mut parts = pair.splitn(2, '=');
        let key_raw = parts.next().unwrap_or("");
        let value_raw = parts.next().unwrap_or("");
        let key = percent_decode(key_raw)?;
        let value = percent_decode(value_raw)?;
        if key == "params" {
            let value = if value.is_empty() {
                Value::Null
            } else {
                serde_json::from_str(&value).map_err(|err| {
                    RpcError::new(RPC_INVALID_REQUEST, format!("invalid params: {err}"))
                })?
            };
            return match value {
                Value::Array(values) => Ok(values),
                Value::Null => Ok(Vec::new()),
                other => Ok(vec![other]),
            };
        }
        params.push(parse_query_value(&value));
    }
    Ok(params)
}

fn parse_query_value(value: &str) -> Value {
    let trimmed = value.trim();
    let lower = trimmed.to_ascii_lowercase();
    if lower == "true" {
        return Value::Bool(true);
    }
    if lower == "false" {
        return Value::Bool(false);
    }
    if let Ok(int_val) = trimmed.parse::<i64>() {
        return Value::Number(int_val.into());
    }
    if trimmed.contains('.') || trimmed.contains('e') || trimmed.contains('E') {
        if let Ok(float_val) = trimmed.parse::<f64>() {
            if let Some(number) = Number::from_f64(float_val) {
                return Value::Number(number);
            }
        }
    }
    Value::String(trimmed.to_string())
}

fn percent_decode(input: &str) -> Result<String, RpcError> {
    let bytes = input.as_bytes();
    let mut out = Vec::with_capacity(bytes.len());
    let mut idx = 0;
    while idx < bytes.len() {
        match bytes[idx] {
            b'%' => {
                if idx + 2 >= bytes.len() {
                    return Err(RpcError::new(
                        RPC_INVALID_REQUEST,
                        "invalid percent-encoding",
                    ));
                }
                let hi = hex_value(bytes[idx + 1])?;
                let lo = hex_value(bytes[idx + 2])?;
                out.push((hi << 4) | lo);
                idx += 3;
            }
            b'+' => {
                out.push(b' ');
                idx += 1;
            }
            byte => {
                out.push(byte);
                idx += 1;
            }
        }
    }
    String::from_utf8(out).map_err(|_| RpcError::new(RPC_INVALID_REQUEST, "invalid utf8 in query"))
}

fn hex_value(byte: u8) -> Result<u8, RpcError> {
    match byte {
        b'0'..=b'9' => Ok(byte - b'0'),
        b'a'..=b'f' => Ok(byte - b'a' + 10),
        b'A'..=b'F' => Ok(byte - b'A' + 10),
        _ => Err(RpcError::new(
            RPC_INVALID_REQUEST,
            "invalid percent-encoding",
        )),
    }
}

fn dispatch_method<S: fluxd_storage::KeyValueStore + 'static>(
    method: &str,
    params: Vec<Value>,
    ctx: &RpcContext<S>,
) -> Result<Value, RpcError> {
    if method == "getrichlist" {
        let (page, page_size, min_balance) = parse_richlist_params(&params)?;

        {
            let guard = richlist_cache()
                .lock()
                .map_err(|_| map_internal("richlist cache lock poisoned"))?;
            if let Some(existing) = guard.as_ref() {
                if existing.computed_at.elapsed() < RICHLIST_CACHE_TTL {
                    return Ok(existing.to_response(
                        ctx.chainstate.as_ref(),
                        page,
                        page_size,
                        min_balance,
                    ));
                }
            }
        }

        if RICHLIST_REFRESH_IN_FLIGHT
            .compare_exchange(false, true, std::sync::atomic::Ordering::SeqCst, std::sync::atomic::Ordering::SeqCst)
            .is_ok()
        {
            let chainstate = Arc::clone(&ctx.chainstate);
            let chain_params = ctx.chain_params.clone();
            tokio::task::spawn_blocking(move || {
                let _ = refresh_richlist_cache(chainstate.as_ref(), &chain_params);
                RICHLIST_REFRESH_IN_FLIGHT.store(false, std::sync::atomic::Ordering::SeqCst);
            });
        }

        let guard = richlist_cache()
            .lock()
            .map_err(|_| map_internal("richlist cache lock poisoned"))?;
        if let Some(existing) = guard.as_ref() {
            return Ok(existing.to_response(
                ctx.chainstate.as_ref(),
                page,
                page_size,
                min_balance,
            ));
        }

        return Err(RpcError::new(RPC_INTERNAL_ERROR, "rich list warming up"));
    }
    let chainstate = ctx.chainstate.as_ref();
    let store = ctx.store.as_ref();
    let write_lock = ctx.write_lock.as_ref();
    let mempool = ctx.mempool.as_ref();
    let mempool_policy = ctx.mempool_policy.as_ref();
    let mempool_metrics = ctx.mempool_metrics.as_ref();
    let header_metrics = ctx.header_metrics.as_ref();
    let fee_estimator = ctx.fee_estimator.as_ref();
    let tx_confirm_target = ctx.tx_confirm_target;
    let mempool_flags = &ctx.mempool_flags;
    let miner_address = ctx.miner_address.as_deref();
    let chain_params = &ctx.chain_params;
    let data_dir = ctx.data_dir.as_path();
    let params_dir = ctx.params_dir.as_path();
    let net_totals = ctx.net_totals.as_ref();
    let peer_registry = ctx.peer_registry.as_ref();
    let header_peer_book = ctx.header_peer_book.as_ref();
    let addr_book = ctx.addr_book.as_ref();
    let added_nodes = ctx.added_nodes.as_ref();
    let tx_announce = &ctx.tx_announce;
    let wallet = ctx.wallet.as_ref();
    let shutdown_tx = &ctx.shutdown_tx;

    match method {
        "help" => rpc_help(params),
        "getinfo" => rpc_getinfo(
            chainstate,
            mempool,
            wallet,
            params,
            chain_params,
            data_dir,
            net_totals,
            peer_registry,
            mempool_policy,
        ),
        "ping" => rpc_ping(params),
        "stop" => rpc_stop(params, shutdown_tx),
        "restart" => rpc_restart(params, shutdown_tx),
        "reindex" => rpc_reindex(params, data_dir, shutdown_tx),
        "rescanblockchain" => rpc_rescanblockchain(chainstate, wallet, params),
        "importaddress" => rpc_importaddress(chainstate, wallet, params, chain_params),
        "importwallet" => rpc_importwallet(chainstate, wallet, params),
        "getwalletinfo" => rpc_getwalletinfo(chainstate, mempool, wallet, params),
        "encryptwallet" => rpc_encryptwallet(wallet, params),
        "walletpassphrase" => rpc_walletpassphrase(&ctx.wallet, params),
        "walletpassphrasechange" => rpc_walletpassphrasechange(wallet, params),
        "walletlock" => rpc_walletlock(wallet, params),
        "getnewaddress" => rpc_getnewaddress(wallet, params),
        "getrawchangeaddress" => rpc_getrawchangeaddress(wallet, params),
        "importprivkey" => rpc_importprivkey(chainstate, wallet, params),
        "dumpprivkey" => rpc_dumpprivkey(wallet, params, chain_params),
        "signmessage" => rpc_signmessage(wallet, params, chain_params),
        "backupwallet" => rpc_backupwallet(wallet, params),
        "dumpwallet" => rpc_dumpwallet(wallet, params, data_dir),
        "z_exportwallet" | "zexportwallet" => rpc_zexportwallet(wallet, params, data_dir),
        "addmultisigaddress" => rpc_addmultisigaddress(wallet, params, chain_params),
        "getbalance" => rpc_getbalance(chainstate, mempool, wallet, params),
        "getunconfirmedbalance" => rpc_getunconfirmedbalance(chainstate, mempool, wallet, params),
        "getreceivedbyaddress" => {
            rpc_getreceivedbyaddress(chainstate, mempool, wallet, params, chain_params)
        }
        "listunspent" => rpc_listunspent(chainstate, mempool, wallet, params, chain_params),
        "lockunspent" => rpc_lockunspent(wallet, params),
        "listlockunspent" => rpc_listlockunspent(wallet, params),
        "listaddressgroupings" => {
            rpc_listaddressgroupings(chainstate, mempool, wallet, params, chain_params)
        }
        "getdbinfo" => rpc_getdbinfo(chainstate, store, params, data_dir),
        "getblockcount" => rpc_getblockcount(chainstate, params),
        "getbestblockhash" => rpc_getbestblockhash(chainstate, params),
        "getblockhash" => rpc_getblockhash(chainstate, params),
        "getblockheader" => rpc_getblockheader(chainstate, params, chain_params),
        "getblock" => rpc_getblock(chainstate, params, chain_params),
        "getblockchaininfo" => rpc_getblockchaininfo(chainstate, params, chain_params, data_dir),
        "getdifficulty" => rpc_getdifficulty(chainstate, params, chain_params),
        "getchaintips" => rpc_getchaintips(chainstate, params),
        "getblocksubsidy" => rpc_getblocksubsidy(chainstate, params, chain_params),
        "getblockhashes" => rpc_getblockhashes(chainstate, params),
        "gettxstats" => rpc_gettxstats(chainstate, params),
        "createrawtransaction" => rpc_createrawtransaction(chainstate, params, chain_params),
        "decoderawtransaction" => rpc_decoderawtransaction(params, chain_params),
        "decodescript" => rpc_decodescript(params, chain_params),
        "getrawtransaction" => rpc_getrawtransaction(chainstate, mempool, params, chain_params),
        "gettransaction" => rpc_gettransaction(chainstate, mempool, wallet, params, chain_params),
        "listtransactions" => {
            rpc_listtransactions(chainstate, mempool, wallet, params, chain_params)
        }
        "listsinceblock" => rpc_listsinceblock(chainstate, mempool, wallet, params, chain_params),
        "listreceivedbyaddress" => {
            rpc_listreceivedbyaddress(chainstate, mempool, wallet, params, chain_params)
        }
        "keypoolrefill" => rpc_keypoolrefill(wallet, params),
        "settxfee" => rpc_settxfee(wallet, params),
        "fundrawtransaction" => rpc_fundrawtransaction(
            chainstate,
            mempool,
            mempool_policy,
            fee_estimator,
            tx_confirm_target,
            wallet,
            params,
            chain_params,
            FundTransactionControl::default(),
        ),
        "signrawtransaction" => {
            rpc_signrawtransaction(chainstate, mempool, wallet, params, chain_params)
        }
        "sendrawtransaction" => rpc_sendrawtransaction(
            chainstate,
            mempool,
            mempool_policy,
            mempool_metrics,
            fee_estimator,
            mempool_flags,
            params,
            chain_params,
            tx_announce,
        ),
        "sendfrom" => rpc_sendfrom(
            chainstate,
            mempool,
            mempool_policy,
            mempool_metrics,
            fee_estimator,
            tx_confirm_target,
            mempool_flags,
            wallet,
            params,
            chain_params,
            tx_announce,
        ),
        "sendtoaddress" => rpc_sendtoaddress(
            chainstate,
            mempool,
            mempool_policy,
            mempool_metrics,
            fee_estimator,
            tx_confirm_target,
            mempool_flags,
            wallet,
            params,
            chain_params,
            tx_announce,
        ),
        "sendmany" => rpc_sendmany(
            chainstate,
            mempool,
            mempool_policy,
            mempool_metrics,
            fee_estimator,
            tx_confirm_target,
            mempool_flags,
            wallet,
            params,
            chain_params,
            tx_announce,
        ),
        "getmempoolinfo" => rpc_getmempoolinfo(params, mempool),
        "getrawmempool" => rpc_getrawmempool(chainstate, params, mempool),
        "gettxout" => rpc_gettxout(chainstate, mempool, params, chain_params),
        "gettxoutproof" => rpc_gettxoutproof(chainstate, params),
        "verifytxoutproof" => rpc_verifytxoutproof(chainstate, params),
        "gettxoutsetinfo" => rpc_gettxoutsetinfo(chainstate, params, data_dir),
        "getindexstats" => rpc_getindexstats(chainstate, params),
        "getrichlist" => rpc_getrichlist(chainstate, params, chain_params),
        "getblockdeltas" => rpc_getblockdeltas(chainstate, params, chain_params),
        "getspentinfo" => rpc_getspentinfo(chainstate, params),
        "getaddressutxos" => rpc_getaddressutxos(chainstate, params, chain_params),
        "getaddressbalance" => rpc_getaddressbalance(chainstate, params, chain_params),
        "getaddressdeltas" => rpc_getaddressdeltas(chainstate, params, chain_params),
        "getaddresstxids" => rpc_getaddresstxids(chainstate, params, chain_params),
        "getaddresstxidscount" => rpc_getaddresstxidscount(chainstate, params, chain_params),
        "getaddresspagecursor" => rpc_getaddresspagecursor(chainstate, params, chain_params),
        "getaddressmempool" => rpc_getaddressmempool(chainstate, mempool, params, chain_params),
        "getmininginfo" => {
            rpc_getmininginfo(chainstate, mempool, params, chain_params, header_metrics)
        }
        "getblocktemplate" => {
            let wallet_default = default_miner_address_from_wallet_for_blocktemplate(
                miner_address,
                &params,
                wallet,
            )?;
            rpc_getblocktemplate(
                chainstate,
                mempool,
                mempool_policy,
                params,
                chain_params,
                mempool_flags,
                miner_address.or(wallet_default.as_deref()),
            )
        }
        "submitblock" => rpc_submitblock(
            chainstate,
            write_lock,
            mempool,
            fee_estimator,
            params,
            chain_params,
            mempool_flags,
        ),
        "getnetworkhashps" => rpc_getnetworkhashps(chainstate, params, chain_params),
        "getnetworksolps" => rpc_getnetworksolps(chainstate, params, chain_params),
        "getlocalsolps" => rpc_getlocalsolps(params, header_metrics),
        "estimatefee" => rpc_estimatefee(params, fee_estimator),
        "estimatepriority" => rpc_estimatepriority(params, fee_estimator),
        "prioritisetransaction" => rpc_prioritisetransaction(params, mempool),
        "getconnectioncount" => rpc_getconnectioncount(params, peer_registry, net_totals),
        "getnettotals" => rpc_getnettotals(params, net_totals),
        "getnetworkinfo" => rpc_getnetworkinfo(params, peer_registry, net_totals, mempool_policy),
        "getpeerinfo" => rpc_getpeerinfo(params, peer_registry),
        "getdeprecationinfo" => rpc_getdeprecationinfo(params),
        "listbanned" => rpc_listbanned(params, header_peer_book),
        "clearbanned" => rpc_clearbanned(params, header_peer_book),
        "setban" => rpc_setban(params, chain_params, peer_registry, header_peer_book),
        "disconnectnode" => rpc_disconnectnode(params, chain_params, peer_registry),
        "addnode" => rpc_addnode(params, chain_params, addr_book, added_nodes),
        "getaddednodeinfo" => {
            rpc_getaddednodeinfo(params, chain_params, peer_registry, added_nodes)
        }
        "getfluxnodecount" | "getzelnodecount" => rpc_getfluxnodecount(chainstate, params),
        "listfluxnodes" | "listzelnodes" => {
            rpc_viewdeterministicfluxnodelist(chainstate, params, chain_params)
        }
        "viewdeterministicfluxnodelist" | "viewdeterministiczelnodelist" => {
            rpc_viewdeterministicfluxnodelist(chainstate, params, chain_params)
        }
        "fluxnodecurrentwinner" | "zelnodecurrentwinner" => {
            rpc_fluxnodecurrentwinner(chainstate, params, chain_params)
        }
        "getfluxnodestatus" | "getzelnodestatus" => {
            rpc_getfluxnodestatus(chainstate, params, chain_params, data_dir)
        }
        "getdoslist" => rpc_getdoslist(chainstate, params, chain_params),
        "getstartlist" => rpc_getstartlist(chainstate, params, chain_params),
        "getbenchmarks" => rpc_getbenchmarks(params, data_dir, chain_params),
        "getbenchstatus" => rpc_getbenchstatus(params, data_dir, chain_params),
        "startbenchmark" | "startfluxbenchd" | "startzelbenchd" => {
            rpc_startbenchmark(params, data_dir, chain_params)
        }
        "stopbenchmark" | "stopfluxbenchd" | "stopzelbenchd" => {
            rpc_stopbenchmark(params, data_dir, chain_params)
        }
        "zcbenchmark" => rpc_zcbenchmark(params),
        "createfluxnodekey" | "createzelnodekey" => rpc_createfluxnodekey(params, chain_params),
        "createdelegatekeypair" => rpc_createdelegatekeypair(params, chain_params),
        "createp2shstarttx" => rpc_createp2shstarttx(chainstate, params, chain_params),
        "signp2shstarttx" => rpc_signp2shstarttx(wallet, params, chain_params),
        "sendp2shstarttx" => rpc_sendp2shstarttx(
            chainstate,
            mempool,
            mempool_policy,
            mempool_metrics,
            fee_estimator,
            mempool_flags,
            params,
            chain_params,
            tx_announce,
        ),
        "startfluxnodewithdelegates" => rpc_startfluxnodewithdelegates(
            chainstate,
            wallet,
            mempool,
            mempool_policy,
            mempool_metrics,
            fee_estimator,
            mempool_flags,
            params,
            chain_params,
            tx_announce,
            data_dir,
        ),
        "startfluxnodeasdelegate" => rpc_startfluxnodeasdelegate(
            chainstate,
            mempool,
            mempool_policy,
            mempool_metrics,
            fee_estimator,
            mempool_flags,
            params,
            chain_params,
            tx_announce,
        ),
        "startp2shasdelegate" => rpc_startp2shasdelegate(
            chainstate,
            mempool,
            mempool_policy,
            mempool_metrics,
            fee_estimator,
            mempool_flags,
            params,
            chain_params,
            tx_announce,
        ),
        "listfluxnodeconf" | "listzelnodeconf" => {
            rpc_listfluxnodeconf(chainstate, params, chain_params, data_dir)
        }
        "getfluxnodeoutputs" | "getzelnodeoutputs" => {
            rpc_getfluxnodeoutputs(chainstate, params, chain_params, data_dir)
        }
        "startfluxnode" | "startzelnode" => rpc_startfluxnode(
            chainstate,
            wallet,
            mempool,
            mempool_policy,
            mempool_metrics,
            fee_estimator,
            mempool_flags,
            params,
            chain_params,
            tx_announce,
            data_dir,
        ),
        "startdeterministicfluxnode" | "startdeterministiczelnode" => {
            rpc_startdeterministicfluxnode(
                chainstate,
                wallet,
                mempool,
                mempool_policy,
                mempool_metrics,
                fee_estimator,
                mempool_flags,
                params,
                chain_params,
                tx_announce,
                data_dir,
            )
        }
        "verifychain" => rpc_verifychain(chainstate, params),
        "validateaddress" => rpc_validateaddress(wallet, params, chain_params),
        "zcrawjoinsplit" => rpc_zcrawjoinsplit(chainstate, params, chain_params, params_dir),
        "zcrawreceive" => rpc_zcrawreceive(chainstate, params, chain_params),
        "zcrawkeygen" => rpc_zcrawkeygen(params, chain_params),
        "zexportkey" | "z_exportkey" => rpc_zexportkey(wallet, params, chain_params),
        "zexportviewingkey" | "z_exportviewingkey" => {
            rpc_zexportviewingkey(wallet, params, chain_params)
        }
        "zgetbalance" | "z_getbalance" => {
            rpc_zgetbalance(chainstate, mempool, wallet, params, chain_params)
        }
        "zgetmigrationstatus" | "z_getmigrationstatus" => rpc_zgetmigrationstatus(params),
        "zgetnewaddress" | "z_getnewaddress" => {
            rpc_zgetnewaddress(chainstate, wallet, params, chain_params)
        }
        "zgetoperationresult" | "z_getoperationresult" => rpc_zgetoperationresult(params),
        "zgetoperationstatus" | "z_getoperationstatus" => rpc_zgetoperationstatus(params),
        "zgettotalbalance" | "z_gettotalbalance" => {
            rpc_zgettotalbalance(chainstate, mempool, wallet, params, chain_params)
        }
        "zimportkey" | "z_importkey" => rpc_zimportkey(wallet, params, chain_params),
        "zimportviewingkey" | "z_importviewingkey" => {
            rpc_zimportviewingkey(wallet, params, chain_params)
        }
        "zimportwallet" | "z_importwallet" => rpc_zimportwallet(wallet, params, chain_params),
        "zlistaddresses" | "z_listaddresses" => rpc_zlistaddresses(wallet, params, chain_params),
        "zlistoperationids" | "z_listoperationids" => rpc_zlistoperationids(params),
        "zlistreceivedbyaddress" | "z_listreceivedbyaddress" => {
            rpc_zlistreceivedbyaddress(chainstate, wallet, params, chain_params)
        }
        "zlistunspent" | "z_listunspent" => {
            rpc_zlistunspent(chainstate, mempool, wallet, params, chain_params)
        }
        "zsendmany" | "z_sendmany" => rpc_zsendmany(ctx, params),
        "zsetmigration" | "z_setmigration" => rpc_zsetmigration(params),
        "zshieldcoinbase" | "z_shieldcoinbase" => rpc_zshieldcoinbase(params),
        "zvalidateaddress" | "z_validateaddress" => {
            rpc_zvalidateaddress(wallet, params, chain_params)
        }
        "verifymessage" => rpc_verifymessage(params, chain_params),
        "createmultisig" => rpc_createmultisig(wallet, params, chain_params),
        _ => Err(RpcError::new(RPC_METHOD_NOT_FOUND, "method not found")),
    }
}

fn rpc_ping(params: Vec<Value>) -> Result<Value, RpcError> {
    ensure_no_params(&params)?;
    Ok(Value::Null)
}

fn rpc_zlistoperationids(params: Vec<Value>) -> Result<Value, RpcError> {
    if params.len() > 1 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "zlistoperationids expects 0 or 1 parameters",
        ));
    }
    let filter = match params.first() {
        None | Some(Value::Null) => None,
        Some(value) => {
            let status = value
                .as_str()
                .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "status must be a string"))?;
            if status == "all" {
                None
            } else {
                if status == "cancelled" {
                    return Ok(Value::Array(Vec::new()));
                }
                Some(AsyncOpState::parse_filter(status).ok_or_else(|| {
                    RpcError::new(RPC_INVALID_PARAMETER, "invalid operation status")
                })?)
            }
        }
    };

    let guard = async_ops()
        .lock()
        .map_err(|_| map_internal("operation manager lock poisoned"))?;
    Ok(Value::Array(guard.list_ids(filter)))
}

fn rpc_zgetoperationstatus(params: Vec<Value>) -> Result<Value, RpcError> {
    if params.len() > 1 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "zgetoperationstatus expects 0 or 1 parameters",
        ));
    }
    let filter_ids = match params.first() {
        None | Some(Value::Null) => None,
        Some(value) => {
            let ids = value.as_array().ok_or_else(|| {
                RpcError::new(RPC_INVALID_PARAMETER, "operationids must be an array")
            })?;
            let mut out = Vec::with_capacity(ids.len());
            for id in ids {
                out.push(
                    id.as_str()
                        .ok_or_else(|| {
                            RpcError::new(RPC_INVALID_PARAMETER, "operationids must be strings")
                        })?
                        .to_string(),
                );
            }
            Some(out)
        }
    };

    let guard = async_ops()
        .lock()
        .map_err(|_| map_internal("operation manager lock poisoned"))?;
    let values = guard.status_objects(filter_ids.as_deref());
    Ok(Value::Array(values))
}

fn rpc_zgetoperationresult(params: Vec<Value>) -> Result<Value, RpcError> {
    if params.len() > 1 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "zgetoperationresult expects 0 or 1 parameters",
        ));
    }
    let filter_ids = match params.first() {
        None | Some(Value::Null) => None,
        Some(value) => {
            let ids = value.as_array().ok_or_else(|| {
                RpcError::new(RPC_INVALID_PARAMETER, "operationids must be an array")
            })?;
            let mut out = Vec::with_capacity(ids.len());
            for id in ids {
                out.push(
                    id.as_str()
                        .ok_or_else(|| {
                            RpcError::new(RPC_INVALID_PARAMETER, "operationids must be strings")
                        })?
                        .to_string(),
                );
            }
            Some(out)
        }
    };

    let mut guard = async_ops()
        .lock()
        .map_err(|_| map_internal("operation manager lock poisoned"))?;
    let values = guard.take_finished(filter_ids.as_deref());
    Ok(Value::Array(values))
}

fn rpc_zgetmigrationstatus(params: Vec<Value>) -> Result<Value, RpcError> {
    ensure_no_params(&params)?;
    Ok(json!({
        "enabled": false,
        "unmigrated_amount": "0.00000000",
        "unfinalized_migrated_amount": "0.00000000",
        "finalized_migrated_amount": "0.00000000",
        "finalized_migration_transactions": 0,
        "migration_txids": [],
    }))
}

fn rpc_zsetmigration(params: Vec<Value>) -> Result<Value, RpcError> {
    if params.len() != 1 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "zsetmigration expects 1 parameter",
        ));
    }
    if !matches!(params[0], Value::Bool(_)) {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "enabled must be a boolean",
        ));
    }
    Err(RpcError::new(
        RPC_MISC_ERROR,
        "Flux fork active: z_setmigration has been deprecated.",
    ))
}

fn rpc_zshieldcoinbase(_params: Vec<Value>) -> Result<Value, RpcError> {
    Err(RpcError::new(
        RPC_MISC_ERROR,
        "Flux fork active. z_shieldcoinbase has been deprecated.",
    ))
}

fn rpc_shielded_wallet_not_implemented(
    _params: Vec<Value>,
    method: &'static str,
) -> Result<Value, RpcError> {
    Err(RpcError::new(
        RPC_WALLET_ERROR,
        format!("{method} not implemented (shielded wallet WIP)"),
    ))
}

fn rpc_shielded_not_implemented(
    _params: Vec<Value>,
    method: &'static str,
) -> Result<Value, RpcError> {
    Err(RpcError::new(
        RPC_INTERNAL_ERROR,
        format!("{method} not implemented"),
    ))
}

fn rpc_stop(params: Vec<Value>, shutdown_tx: &watch::Sender<bool>) -> Result<Value, RpcError> {
    ensure_no_params(&params)?;
    shutdown_tx
        .send(true)
        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "shutdown channel closed"))?;
    Ok(Value::String("fluxd stopping".to_string()))
}

fn rpc_restart(params: Vec<Value>, shutdown_tx: &watch::Sender<bool>) -> Result<Value, RpcError> {
    ensure_no_params(&params)?;
    shutdown_tx
        .send(true)
        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "shutdown channel closed"))?;
    Ok(Value::String(
        "fluxd restarting (exit requested; restart requires a supervisor)".to_string(),
    ))
}

fn rpc_reindex(
    params: Vec<Value>,
    data_dir: &Path,
    shutdown_tx: &watch::Sender<bool>,
) -> Result<Value, RpcError> {
    ensure_no_params(&params)?;
    let flag_path = data_dir.join(crate::REINDEX_REQUEST_FILE_NAME);
    fs::write(&flag_path, b"reindex\n").map_err(|err| {
        RpcError::new(
            RPC_INTERNAL_ERROR,
            &format!("failed to write {}: {err}", flag_path.display()),
        )
    })?;
    shutdown_tx
        .send(true)
        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "shutdown channel closed"))?;
    Ok(Value::String(
        "fluxd reindex requested (exit requested; restart required)".to_string(),
    ))
}

fn rpc_rescanblockchain<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    wallet: &Mutex<Wallet>,
    params: Vec<Value>,
) -> Result<Value, RpcError> {
    if params.len() > 2 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "rescanblockchain expects 0 to 2 parameters",
        ));
    }
    let tip_height = best_block_height(chainstate)?;
    let start_height = match params.get(0) {
        Some(value) if !value.is_null() => parse_u32(value, "start_height")? as i32,
        _ => 0,
    };
    let stop_height = match params.get(1) {
        Some(value) if !value.is_null() => parse_u32(value, "stop_height")? as i32,
        _ => tip_height,
    };
    if start_height < 0 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "start_height out of range",
        ));
    }
    if stop_height < 0 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "stop_height out of range",
        ));
    }
    let stop_height = stop_height.min(tip_height);
    if stop_height < start_height {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "stop_height must be >= start_height",
        ));
    }

    let scripts = {
        let guard = wallet
            .lock()
            .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;
        guard
            .all_script_pubkeys_including_watchonly()
            .map_err(map_wallet_error)?
    };
    if scripts.is_empty() {
        return Ok(json!({
            "start_height": start_height,
            "stop_height": stop_height,
        }));
    }

    let mut txids = std::collections::BTreeSet::<Hash256>::new();
    for script_pubkey in &scripts {
        let mut visitor = |delta: fluxd_chainstate::address_deltas::AddressDeltaEntry| {
            if delta.height < start_height as u32 || delta.height > stop_height as u32 {
                return Ok(());
            }
            txids.insert(delta.txid);
            Ok(())
        };
        chainstate
            .for_each_address_delta(script_pubkey, &mut visitor)
            .map_err(map_internal)?;
    }

    let mut blocks: std::collections::BTreeMap<(u32, u64, u32), Vec<(Hash256, u32)>> =
        std::collections::BTreeMap::new();
    for txid in &txids {
        if let Some(location) = chainstate.tx_location(txid).map_err(map_internal)? {
            blocks
                .entry((
                    location.block.file_id,
                    location.block.offset,
                    location.block.len,
                ))
                .or_default()
                .push((*txid, location.index));
        }
    }

    let mut stored = Vec::new();
    for ((file_id, offset, len), entries) in blocks {
        let location = fluxd_chainstate::flatfiles::FileLocation {
            file_id,
            offset,
            len,
        };
        let bytes = chainstate.read_block(location).map_err(map_internal)?;
        let block = Block::consensus_decode(&bytes).map_err(map_internal)?;
        for (txid, tx_index) in entries {
            let Some(tx) = block.transactions.get(tx_index as usize) else {
                continue;
            };
            let candidate = tx.txid().map_err(map_internal)?;
            if candidate != txid {
                continue;
            }
            let encoded = tx.consensus_encode().map_err(map_internal)?;
            stored.push((txid, encoded));
        }
    }

    let stored_set: HashSet<Hash256> = stored.iter().map(|(txid, _)| *txid).collect();
    let remaining = txids
        .into_iter()
        .filter(|txid| !stored_set.contains(txid))
        .collect::<Vec<_>>();

    let mut guard = wallet
        .lock()
        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;
    if !stored.is_empty() {
        let _ = guard
            .record_transactions(stored)
            .map_err(map_wallet_error)?;
    }
    if !remaining.is_empty() {
        let _ = guard.record_txids(remaining).map_err(map_wallet_error)?;
    }

    Ok(json!({
        "start_height": start_height,
        "stop_height": stop_height,
    }))
}

fn rpc_importaddress<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    wallet: &Mutex<Wallet>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    if params.is_empty() || params.len() > 4 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "importaddress expects 1 to 4 parameters",
        ));
    }
    let value = params[0]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "address must be a string"))?;
    if let Some(label) = params.get(1) {
        if !label.is_null() && label.as_str().is_none() {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                "label must be a string",
            ));
        }
    }
    if let Some(rescan) = params.get(2) {
        if !rescan.is_null() && rescan.as_bool().is_none() {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                "rescan must be a boolean",
            ));
        }
    }
    if let Some(p2sh) = params.get(3) {
        if !p2sh.is_null() && p2sh.as_bool().is_none() {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                "p2sh must be a boolean",
            ));
        }
    }

    let script_pubkey = match address_to_script_pubkey(value, chain_params.network) {
        Ok(script) => script,
        Err(_) => bytes_from_hex(value).ok_or_else(|| {
            RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "Invalid address or script")
        })?,
    };

    let label = params
        .get(1)
        .and_then(Value::as_str)
        .unwrap_or("")
        .to_string();
    let rescan = params.get(2).and_then(Value::as_bool).unwrap_or(true);

    let mut guard = wallet
        .lock()
        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;
    guard
        .import_watch_script_pubkey(script_pubkey.clone())
        .map_err(map_wallet_error)?;
    if !label.is_empty() {
        guard
            .set_label_for_script_pubkey(script_pubkey, label)
            .map_err(map_wallet_error)?;
    }
    drop(guard);

    if rescan {
        let _ = rpc_rescanblockchain(chainstate, wallet, Vec::new())?;
    }
    Ok(Value::Null)
}

fn rpc_importwallet<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    wallet: &Mutex<Wallet>,
    params: Vec<Value>,
) -> Result<Value, RpcError> {
    if params.len() != 1 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "importwallet expects 1 parameter",
        ));
    }
    let filename = params[0]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "filename must be a string"))?;
    if filename.trim().is_empty() {
        return Err(RpcError::new(RPC_INVALID_PARAMETER, "filename is empty"));
    }
    let contents = std::fs::read_to_string(filename)
        .map_err(|err| RpcError::new(RPC_INVALID_PARAMETER, err.to_string()))?;

    let mut imported = 0usize;
    let mut guard = wallet
        .lock()
        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;

    for line in contents.lines() {
        let trimmed = line.trim();
        if trimmed.is_empty() || trimmed.starts_with('#') {
            continue;
        }
        let mut parts = trimmed.split_whitespace();
        let Some(wif) = parts.next() else { continue };
        let _timestamp = parts.next();

        let mut label = None::<String>;
        for token in parts {
            if token == "#" {
                break;
            }
            if let Some(encoded) = token.strip_prefix("label=") {
                label = Some(crate::wallet::decode_wallet_dump_string(encoded));
            }
        }

        match guard.import_wif(wif) {
            Ok(()) => {
                imported += 1;
                if let Some(label) = label.filter(|value| !value.is_empty()) {
                    let (secret, compressed) = match wif_to_secret_key(wif, guard.network()) {
                        Ok(decoded) => decoded,
                        Err(_) => continue,
                    };
                    let secret_key = match SecretKey::from_slice(&secret) {
                        Ok(key) => key,
                        Err(_) => continue,
                    };
                    let pubkey = PublicKey::from_secret_key(&Secp256k1::new(), &secret_key);
                    let pubkey_bytes = if compressed {
                        pubkey.serialize().to_vec()
                    } else {
                        pubkey.serialize_uncompressed().to_vec()
                    };
                    let key_hash = hash160(&pubkey_bytes);
                    let mut script_pubkey = Vec::with_capacity(25);
                    script_pubkey.extend_from_slice(&[0x76, 0xa9, 0x14]);
                    script_pubkey.extend_from_slice(&key_hash);
                    script_pubkey.extend_from_slice(&[0x88, 0xac]);
                    guard
                        .set_label_for_script_pubkey(script_pubkey, label)
                        .map_err(map_wallet_error)?;
                }
            }
            Err(WalletError::InvalidData("invalid wif")) => continue,
            Err(err) => return Err(map_wallet_error(err)),
        }
    }

    if imported == 0 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "no keys found in wallet dump",
        ));
    }
    drop(guard);
    let _ = rpc_rescanblockchain(chainstate, wallet, Vec::new())?;
    Ok(Value::Null)
}

fn rpc_encryptwallet(wallet: &Mutex<Wallet>, params: Vec<Value>) -> Result<Value, RpcError> {
    if params.len() != 1 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "encryptwallet expects 1 parameter",
        ));
    }
    let passphrase = params[0]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "passphrase must be a string"))?;
    if passphrase.is_empty() {
        return Err(RpcError::new(RPC_INVALID_PARAMETER, "passphrase is empty"));
    }

    let mut guard = wallet
        .lock()
        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;
    if guard.is_encrypted() {
        return Err(RpcError::new(
            RPC_WALLET_WRONG_ENC_STATE,
            "Error: running with an encrypted wallet, but encryptwallet was called.",
        ));
    }
    guard.encryptwallet(passphrase).map_err(map_wallet_error)?;

    Ok(Value::Null)
}

fn rpc_walletpassphrase(
    wallet: &Arc<Mutex<Wallet>>,
    params: Vec<Value>,
) -> Result<Value, RpcError> {
    if params.len() != 2 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "walletpassphrase expects 2 parameters",
        ));
    }
    let passphrase = params[0]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "passphrase must be a string"))?;
    let timeout = params[1]
        .as_i64()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "timeout must be an integer"))?;
    if timeout <= 0 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "timeout must be positive",
        ));
    }
    let timeout_u64 = u64::try_from(timeout)
        .map_err(|_| RpcError::new(RPC_INVALID_PARAMETER, "timeout out of range"))?;

    let generation = {
        let mut guard = wallet
            .lock()
            .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;
        if !guard.is_encrypted() {
            return Err(RpcError::new(
                RPC_WALLET_WRONG_ENC_STATE,
                "Error: running with an unencrypted wallet, but walletpassphrase was called.",
            ));
        }
        let (_unlocked_until, generation) = guard
            .walletpassphrase(passphrase, timeout_u64)
            .map_err(map_wallet_error)?;
        generation
    };

    let wallet_ref = Arc::clone(wallet);
    tokio::spawn(async move {
        tokio::time::sleep(Duration::from_secs(timeout_u64)).await;
        let mut guard = match wallet_ref.lock() {
            Ok(guard) => guard,
            Err(_) => return,
        };
        if guard.unlock_generation() != generation {
            return;
        }
        let _ = guard.walletlock();
    });

    Ok(Value::Null)
}

fn rpc_walletpassphrasechange(
    wallet: &Mutex<Wallet>,
    params: Vec<Value>,
) -> Result<Value, RpcError> {
    if params.len() != 2 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "walletpassphrasechange expects 2 parameters",
        ));
    }
    let old_passphrase = params[0]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "old passphrase must be a string"))?;
    let new_passphrase = params[1]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "new passphrase must be a string"))?;
    if new_passphrase.is_empty() {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "new passphrase is empty",
        ));
    }
    let mut guard = wallet
        .lock()
        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;
    if !guard.is_encrypted() {
        return Err(RpcError::new(
            RPC_WALLET_WRONG_ENC_STATE,
            "Error: running with an unencrypted wallet, but walletpassphrasechange was called.",
        ));
    }
    guard
        .walletpassphrasechange(old_passphrase, new_passphrase)
        .map_err(map_wallet_error)?;

    Ok(Value::Null)
}

fn rpc_walletlock(wallet: &Mutex<Wallet>, params: Vec<Value>) -> Result<Value, RpcError> {
    ensure_no_params(&params)?;
    let mut guard = wallet
        .lock()
        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;
    if !guard.is_encrypted() {
        return Err(RpcError::new(
            RPC_WALLET_WRONG_ENC_STATE,
            "Error: running with an unencrypted wallet, but walletlock was called.",
        ));
    }
    guard.walletlock().map_err(map_wallet_error)?;
    Ok(Value::Null)
}

fn parse_outpoint_list(value: &Value) -> Result<Vec<OutPoint>, RpcError> {
    let outputs = value.as_array().ok_or_else(|| {
        RpcError::new(
            RPC_INVALID_PARAMETER,
            "outputs must be an array of {txid,vout} objects",
        )
    })?;
    let mut out = Vec::with_capacity(outputs.len());
    for entry in outputs {
        let obj = entry.as_object().ok_or_else(|| {
            RpcError::new(RPC_INVALID_PARAMETER, "outputs entries must be objects")
        })?;
        let txid_value = obj
            .get("txid")
            .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "missing txid"))?;
        let vout_value = obj
            .get("vout")
            .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "missing vout"))?;
        let txid = parse_hash(txid_value)?;
        let vout = parse_u32(vout_value, "vout")?;
        out.push(OutPoint {
            hash: txid,
            index: vout,
        });
    }
    Ok(out)
}

fn rpc_lockunspent(wallet: &Mutex<Wallet>, params: Vec<Value>) -> Result<Value, RpcError> {
    if params.is_empty() || params.len() > 2 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "lockunspent expects 1 or 2 parameters",
        ));
    }
    let unlock = parse_bool(&params[0])?;

    let outputs = match params.get(1) {
        None | Some(Value::Null) => Vec::new(),
        Some(value) => parse_outpoint_list(value)?,
    };

    let mut guard = wallet
        .lock()
        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;

    if unlock && outputs.is_empty() {
        guard.unlock_all_outpoints();
        return Ok(Value::Bool(true));
    }
    if !unlock && outputs.is_empty() {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "outputs is required when unlock=false",
        ));
    }

    if unlock {
        for outpoint in outputs {
            guard.unlock_outpoint(&outpoint);
        }
    } else {
        for outpoint in outputs {
            guard.lock_outpoint(outpoint);
        }
    }
    Ok(Value::Bool(true))
}

fn rpc_listlockunspent(wallet: &Mutex<Wallet>, params: Vec<Value>) -> Result<Value, RpcError> {
    ensure_no_params(&params)?;
    let mut locked = wallet
        .lock()
        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?
        .locked_outpoints();
    locked.sort_by(|a, b| a.hash.cmp(&b.hash).then_with(|| a.index.cmp(&b.index)));
    Ok(Value::Array(
        locked
            .into_iter()
            .map(|outpoint| {
                json!({
                    "txid": hash256_to_hex(&outpoint.hash),
                    "vout": outpoint.index,
                })
            })
            .collect(),
    ))
}

fn rpc_listaddressgroupings<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    mempool: &Mutex<Mempool>,
    wallet: &Mutex<Wallet>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    ensure_no_params(&params)?;

    let (scripts, labels_by_index) = {
        let guard = wallet
            .lock()
            .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;
        let scripts = guard
            .all_script_pubkeys_including_watchonly()
            .map_err(map_wallet_error)?;
        let labels_by_index = scripts
            .iter()
            .map(|script_pubkey| {
                guard
                    .label_for_script_pubkey(script_pubkey)
                    .map(str::to_owned)
            })
            .collect::<Vec<_>>();
        (scripts, labels_by_index)
    };
    if scripts.is_empty() {
        return Ok(Value::Array(Vec::new()));
    }

    #[derive(Clone)]
    struct TxScriptGrouping {
        inputs: HashSet<usize>,
        outputs: HashSet<usize>,
    }

    struct UnionFind {
        parent: Vec<usize>,
        rank: Vec<u8>,
    }

    impl UnionFind {
        fn new(size: usize) -> Self {
            Self {
                parent: (0..size).collect(),
                rank: vec![0u8; size],
            }
        }

        fn find(&mut self, idx: usize) -> usize {
            let mut current = idx;
            while self.parent[current] != current {
                current = self.parent[current];
            }
            let root = current;
            let mut current = idx;
            while self.parent[current] != current {
                let next = self.parent[current];
                self.parent[current] = root;
                current = next;
            }
            root
        }

        fn union(&mut self, a: usize, b: usize) {
            let root_a = self.find(a);
            let root_b = self.find(b);
            if root_a == root_b {
                return;
            }
            let rank_a = self.rank[root_a];
            let rank_b = self.rank[root_b];
            if rank_a < rank_b {
                self.parent[root_a] = root_b;
            } else if rank_a > rank_b {
                self.parent[root_b] = root_a;
            } else {
                self.parent[root_b] = root_a;
                self.rank[root_a] = rank_a.saturating_add(1);
            }
        }
    }

    let mut script_to_index: HashMap<Vec<u8>, usize> = HashMap::with_capacity(scripts.len());
    let mut address_by_index: Vec<Option<String>> = Vec::with_capacity(scripts.len());
    for (idx, script_pubkey) in scripts.iter().enumerate() {
        script_to_index.insert(script_pubkey.clone(), idx);
        address_by_index.push(script_pubkey_to_address(
            script_pubkey,
            chain_params.network,
        ));
    }

    let mut dsu = UnionFind::new(scripts.len());

    let mut tx_groupings: HashMap<Hash256, TxScriptGrouping> = HashMap::new();
    for (idx, script_pubkey) in scripts.iter().enumerate() {
        let mut visitor = |delta: fluxd_chainstate::address_deltas::AddressDeltaEntry| {
            let grouping = tx_groupings
                .entry(delta.txid)
                .or_insert_with(|| TxScriptGrouping {
                    inputs: HashSet::new(),
                    outputs: HashSet::new(),
                });
            if delta.spending {
                grouping.inputs.insert(idx);
            } else {
                grouping.outputs.insert(idx);
            }
            Ok(())
        };
        chainstate
            .for_each_address_delta(script_pubkey, &mut visitor)
            .map_err(map_internal)?;
    }

    for grouping in tx_groupings.values() {
        if grouping.inputs.is_empty() {
            continue;
        }
        let mut all = Vec::with_capacity(grouping.inputs.len() + grouping.outputs.len());
        all.extend(grouping.inputs.iter().copied());
        all.extend(grouping.outputs.iter().copied());
        all.sort_unstable();
        all.dedup();
        if all.len() < 2 {
            continue;
        }
        let first = all[0];
        for other in &all[1..] {
            dsu.union(first, *other);
        }
    }

    if let Ok(mempool_guard) = mempool.lock() {
        for entry in mempool_guard.entries() {
            let mut touched: HashSet<usize> = HashSet::new();
            for output in &entry.tx.vout {
                if let Some(idx) = script_to_index.get(&output.script_pubkey) {
                    touched.insert(*idx);
                }
            }
            let prevouts = mempool_guard.prevouts_for_tx(&entry.tx);
            for input in &entry.tx.vin {
                let mut script_pubkey = None;
                if let Ok(Some(utxo)) = chainstate.utxo_entry(&input.prevout) {
                    script_pubkey = Some(utxo.script_pubkey);
                } else if let Some(prev) = prevouts.get(&input.prevout) {
                    script_pubkey = Some(prev.script_pubkey.clone());
                } else if let Ok(Some(prev_location)) = chainstate.tx_location(&input.prevout.hash)
                {
                    if let Ok(prev_bytes) = chainstate.read_block(prev_location.block) {
                        if let Ok(prev_block) = Block::consensus_decode(&prev_bytes) {
                            let tx_index = prev_location.index as usize;
                            let vout = input.prevout.index as usize;
                            if let Some(prev_tx) = prev_block.transactions.get(tx_index) {
                                if let Some(out) = prev_tx.vout.get(vout) {
                                    script_pubkey = Some(out.script_pubkey.clone());
                                }
                            }
                        }
                    }
                }

                let Some(script_pubkey) = script_pubkey else {
                    continue;
                };
                if let Some(idx) = script_to_index.get(&script_pubkey) {
                    touched.insert(*idx);
                }
            }

            let mut all = touched.into_iter().collect::<Vec<_>>();
            all.sort_unstable();
            all.dedup();
            if all.len() < 2 {
                continue;
            }
            let first = all[0];
            for other in &all[1..] {
                dsu.union(first, *other);
            }
        }
    }

    let utxos = collect_wallet_utxos(chainstate, mempool, &scripts, true)?;
    let mut balances_zat: Vec<i64> = vec![0; scripts.len()];
    for row in utxos {
        let Some(idx) = script_to_index.get(&row.script_pubkey) else {
            continue;
        };
        balances_zat[*idx] = balances_zat[*idx]
            .checked_add(row.value)
            .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "balance overflow"))?;
    }

    let mut groups: HashMap<usize, Vec<(usize, String, i64)>> = HashMap::new();
    for (idx, value) in balances_zat.into_iter().enumerate() {
        if value <= 0 {
            continue;
        }
        let Some(address) = address_by_index
            .get(idx)
            .and_then(|value| value.as_ref())
            .cloned()
        else {
            continue;
        };
        let root = dsu.find(idx);
        groups.entry(root).or_default().push((idx, address, value));
    }

    let mut out_groups: Vec<Value> = Vec::new();
    for mut entries in groups.into_values() {
        entries.sort_by(|a, b| a.1.cmp(&b.1));
        out_groups.push(Value::Array(
            entries
                .into_iter()
                .map(|(idx, address, value)| {
                    let label = labels_by_index
                        .get(idx)
                        .and_then(|label| label.as_deref())
                        .unwrap_or("");
                    Value::Array(vec![
                        Value::String(address),
                        amount_to_value(value),
                        Value::String(label.to_string()),
                    ])
                })
                .collect(),
        ));
    }
    out_groups.sort_by(|a, b| {
        let a_first = a
            .as_array()
            .and_then(|arr| arr.first())
            .and_then(Value::as_array)
            .and_then(|arr| arr.first())
            .and_then(Value::as_str)
            .unwrap_or("");
        let b_first = b
            .as_array()
            .and_then(|arr| arr.first())
            .and_then(Value::as_array)
            .and_then(|arr| arr.first())
            .and_then(Value::as_str)
            .unwrap_or("");
        a_first.cmp(b_first)
    });

    Ok(Value::Array(out_groups))
}

fn map_wallet_error(err: WalletError) -> RpcError {
    match err {
        WalletError::WalletLocked => RpcError::new(
            RPC_WALLET_UNLOCK_NEEDED,
            "Error: Please enter the wallet passphrase with walletpassphrase first.",
        ),
        WalletError::IncorrectPassphrase => RpcError::new(
            RPC_WALLET_PASSPHRASE_INCORRECT,
            "Error: The wallet passphrase entered was incorrect.",
        ),
        WalletError::InvalidData("invalid wif") => {
            RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "invalid private key encoding")
        }
        err => RpcError::new(RPC_WALLET_ERROR, err.to_string()),
    }
}

#[derive(Clone)]
struct WalletUtxoRow {
    outpoint: OutPoint,
    value: i64,
    script_pubkey: Vec<u8>,
    height: u32,
    is_coinbase: bool,
    confirmations: i32,
}

fn collect_wallet_utxos<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    mempool: &Mutex<Mempool>,
    scripts: &[Vec<u8>],
    include_mempool_outputs: bool,
) -> Result<Vec<WalletUtxoRow>, RpcError> {
    let best_height = chainstate
        .best_block()
        .map_err(map_internal)?
        .map(|tip| tip.height)
        .unwrap_or(0);

    let mut seen: HashSet<OutPoint> = HashSet::new();
    let mut out = Vec::new();
    for script_pubkey in scripts {
        let outpoints = chainstate
            .address_outpoints(script_pubkey)
            .map_err(map_internal)?;
        for outpoint in outpoints {
            if !seen.insert(outpoint.clone()) {
                continue;
            }
            let entry = chainstate
                .utxo_entry(&outpoint)
                .map_err(map_internal)?
                .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "missing utxo entry"))?;
            let height_i32 = i32::try_from(entry.height).unwrap_or(0);
            let confirmations = if best_height >= height_i32 {
                best_height.saturating_sub(height_i32).saturating_add(1)
            } else {
                0
            };
            out.push(WalletUtxoRow {
                outpoint,
                value: entry.value,
                script_pubkey: entry.script_pubkey,
                height: entry.height,
                is_coinbase: entry.is_coinbase,
                confirmations,
            });
        }
    }

    let mempool_guard = mempool
        .lock()
        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "mempool lock poisoned"))?;
    out.retain(|row| !mempool_guard.is_spent(&row.outpoint));

    if include_mempool_outputs {
        for entry in mempool_guard.entries() {
            for (output_index, output) in entry.tx.vout.iter().enumerate() {
                if !scripts
                    .iter()
                    .any(|script| script.as_slice() == output.script_pubkey.as_slice())
                {
                    continue;
                }
                let outpoint = OutPoint {
                    hash: entry.txid,
                    index: output_index as u32,
                };
                if mempool_guard.is_spent(&outpoint) {
                    continue;
                }
                if !seen.insert(outpoint.clone()) {
                    continue;
                }
                out.push(WalletUtxoRow {
                    outpoint,
                    value: output.value,
                    script_pubkey: output.script_pubkey.clone(),
                    height: 0,
                    is_coinbase: false,
                    confirmations: 0,
                });
            }
        }
    }
    Ok(out)
}

fn rpc_getnewaddress(wallet: &Mutex<Wallet>, params: Vec<Value>) -> Result<Value, RpcError> {
    if params.len() > 2 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "getnewaddress expects 0 to 2 parameters",
        ));
    }
    if let Some(value) = params.get(0) {
        if !value.is_null() && value.as_str().is_none() {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                "label must be a string",
            ));
        }
    }
    let label = params
        .get(0)
        .and_then(Value::as_str)
        .unwrap_or("")
        .to_string();
    let mut guard = wallet
        .lock()
        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;
    if guard.is_encrypted() && guard.unlocked_until() == 0 && guard.keypool_size() == 0 {
        return Err(RpcError::new(
            RPC_WALLET_KEYPOOL_RAN_OUT,
            "Error: Keypool ran out, please call keypoolrefill first",
        ));
    }
    let address = guard.generate_new_address(true).map_err(map_wallet_error)?;
    if !label.is_empty() {
        let script_pubkey = address_to_script_pubkey(&address, guard.network())
            .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "invalid wallet address encoding"))?;
        guard
            .set_label_for_script_pubkey(script_pubkey, label)
            .map_err(map_wallet_error)?;
    }
    Ok(Value::String(address))
}

fn rpc_getrawchangeaddress(wallet: &Mutex<Wallet>, params: Vec<Value>) -> Result<Value, RpcError> {
    if params.len() > 1 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "getrawchangeaddress expects 0 or 1 parameter",
        ));
    }
    let mut guard = wallet
        .lock()
        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;
    if guard.is_encrypted() && guard.unlocked_until() == 0 && guard.keypool_size() == 0 {
        return Err(RpcError::new(
            RPC_WALLET_KEYPOOL_RAN_OUT,
            "Error: Keypool ran out, please call keypoolrefill first",
        ));
    }
    let address = guard
        .generate_new_change_address(true)
        .map_err(map_wallet_error)?;
    Ok(Value::String(address))
}

fn rpc_importprivkey<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    wallet: &Mutex<Wallet>,
    params: Vec<Value>,
) -> Result<Value, RpcError> {
    if params.is_empty() || params.len() > 3 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "importprivkey expects 1 to 3 parameters",
        ));
    }
    let wif = params[0]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "privkey must be a string"))?;
    if let Some(value) = params.get(1) {
        if !value.is_null() && value.as_str().is_none() {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                "label must be a string",
            ));
        }
    }
    if let Some(value) = params.get(2) {
        if !value.is_null() && value.as_bool().is_none() {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                "rescan must be a boolean",
            ));
        }
    }

    let label = params
        .get(1)
        .and_then(Value::as_str)
        .unwrap_or("")
        .to_string();
    let rescan = params.get(2).and_then(Value::as_bool).unwrap_or(true);

    let mut guard = wallet
        .lock()
        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;
    guard.import_wif(wif).map_err(map_wallet_error)?;
    if !label.is_empty() {
        let (secret, compressed) = wif_to_secret_key(wif, guard.network())
            .map_err(|_| RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "Invalid private key"))?;
        let secret_key = SecretKey::from_slice(&secret)
            .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "Invalid private key"))?;
        let pubkey = PublicKey::from_secret_key(&Secp256k1::new(), &secret_key);
        let pubkey_bytes = if compressed {
            pubkey.serialize().to_vec()
        } else {
            pubkey.serialize_uncompressed().to_vec()
        };
        let key_hash = hash160(&pubkey_bytes);
        let mut script_pubkey = Vec::with_capacity(25);
        script_pubkey.extend_from_slice(&[0x76, 0xa9, 0x14]);
        script_pubkey.extend_from_slice(&key_hash);
        script_pubkey.extend_from_slice(&[0x88, 0xac]);
        guard
            .set_label_for_script_pubkey(script_pubkey, label)
            .map_err(map_wallet_error)?;
    }
    drop(guard);

    if rescan {
        let _ = rpc_rescanblockchain(chainstate, wallet, Vec::new())?;
    }
    Ok(Value::Null)
}

fn rpc_dumpprivkey(
    wallet: &Mutex<Wallet>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    if params.len() != 1 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "dumpprivkey expects 1 parameter",
        ));
    }
    let address = params[0]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "address must be a string"))?;

    let script_pubkey = address_to_script_pubkey(address, chain_params.network)
        .map_err(|_| RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "Invalid address"))?;
    if classify_script_pubkey(&script_pubkey) != ScriptType::P2Pkh {
        return Err(RpcError::new(
            RPC_TYPE_ERROR,
            "Address does not refer to key",
        ));
    }

    let guard = wallet
        .lock()
        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;
    match guard
        .dump_wif_for_address(address)
        .map_err(map_wallet_error)?
    {
        Some(wif) => Ok(Value::String(wif)),
        None => Err(RpcError::new(
            RPC_WALLET_ERROR,
            "Private key for address is not known",
        )),
    }
}

fn rpc_backupwallet(wallet: &Mutex<Wallet>, params: Vec<Value>) -> Result<Value, RpcError> {
    if params.len() != 1 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "backupwallet expects 1 parameter",
        ));
    }
    let destination = params[0]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "destination must be a string"))?;
    if destination.trim().is_empty() {
        return Err(RpcError::new(RPC_INVALID_PARAMETER, "destination is empty"));
    }
    let mut guard = wallet
        .lock()
        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;
    let path = Path::new(destination);
    guard.backup_to(path).map_err(map_wallet_error)?;
    Ok(Value::Null)
}

fn resolve_wallet_dump_path(data_dir: &Path, filename: &str) -> PathBuf {
    let path = Path::new(filename);
    if path.is_absolute() {
        path.to_path_buf()
    } else {
        data_dir.join(path)
    }
}

fn write_wallet_dump_file(path: &Path, contents: &str) -> Result<(), RpcError> {
    if std::fs::metadata(path).is_ok() {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            format!("Cannot overwrite existing file {}", path.display()),
        ));
    }

    let mut file = std::fs::OpenOptions::new()
        .write(true)
        .create_new(true)
        .open(path)
        .map_err(|_| RpcError::new(RPC_INVALID_PARAMETER, "Cannot open wallet dump file"))?;

    use std::io::Write;
    file.write_all(contents.as_bytes())
        .map_err(|_| RpcError::new(RPC_INVALID_PARAMETER, "Cannot open wallet dump file"))?;
    file.flush()
        .map_err(|_| RpcError::new(RPC_INVALID_PARAMETER, "Cannot open wallet dump file"))?;
    Ok(())
}

fn rpc_dumpwallet(
    wallet: &Mutex<Wallet>,
    params: Vec<Value>,
    data_dir: &Path,
) -> Result<Value, RpcError> {
    if params.len() != 1 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "dumpwallet expects 1 parameter",
        ));
    }
    let filename = params[0]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "filename must be a string"))?;
    if filename.trim().is_empty() {
        return Err(RpcError::new(RPC_INVALID_PARAMETER, "filename is empty"));
    }

    let path = resolve_wallet_dump_path(data_dir, filename);

    let contents = wallet
        .lock()
        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?
        .export_wallet_dump(false)
        .map_err(map_wallet_error)?;

    write_wallet_dump_file(&path, &contents)?;
    Ok(Value::String(path.to_string_lossy().to_string()))
}

fn rpc_zexportwallet(
    wallet: &Mutex<Wallet>,
    params: Vec<Value>,
    data_dir: &Path,
) -> Result<Value, RpcError> {
    if params.len() != 1 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "z_exportwallet expects 1 parameter",
        ));
    }
    let filename = params[0]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "filename must be a string"))?;
    if filename.trim().is_empty() {
        return Err(RpcError::new(RPC_INVALID_PARAMETER, "filename is empty"));
    }

    let path = resolve_wallet_dump_path(data_dir, filename);

    let contents = wallet
        .lock()
        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?
        .export_wallet_dump(true)
        .map_err(map_wallet_error)?;

    write_wallet_dump_file(&path, &contents)?;
    Ok(Value::String(path.to_string_lossy().to_string()))
}

fn rpc_keypoolrefill(wallet: &Mutex<Wallet>, params: Vec<Value>) -> Result<Value, RpcError> {
    if params.len() > 1 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "keypoolrefill expects 0 or 1 parameters",
        ));
    }
    let newsize = match params.first() {
        Some(value) if !value.is_null() => parse_u32(value, "newsize")?,
        _ => 100,
    };
    let newsize = usize::try_from(newsize).unwrap_or(usize::MAX);

    let mut guard = wallet
        .lock()
        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;
    guard.refill_keypool(newsize).map_err(map_wallet_error)?;
    Ok(Value::Null)
}

fn rpc_settxfee(wallet: &Mutex<Wallet>, params: Vec<Value>) -> Result<Value, RpcError> {
    if params.len() != 1 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "settxfee expects 1 parameter",
        ));
    }
    let fee_per_kb = parse_amount(&params[0])?;
    if fee_per_kb < 0 {
        return Err(RpcError::new(RPC_INVALID_PARAMETER, "fee must be >= 0"));
    }
    wallet
        .lock()
        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?
        .set_pay_tx_fee_per_kb(fee_per_kb)
        .map_err(map_wallet_error)?;
    Ok(Value::Bool(true))
}

fn rpc_signmessage(
    wallet: &Mutex<Wallet>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    if params.len() != 2 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "signmessage expects 2 parameters",
        ));
    }
    let address = params[0]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "address must be a string"))?;
    let message = params[1]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "message must be a string"))?;

    let script_pubkey = address_to_script_pubkey(address, chain_params.network)
        .map_err(|_| RpcError::new(RPC_TYPE_ERROR, "Invalid address"))?;
    if classify_script_pubkey(&script_pubkey) != ScriptType::P2Pkh {
        return Err(RpcError::new(
            RPC_TYPE_ERROR,
            "Address does not refer to key",
        ));
    }

    let guard = wallet
        .lock()
        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;
    match guard
        .sign_message(address, message.as_bytes())
        .map_err(map_wallet_error)?
    {
        Some(sig) => Ok(Value::String(
            base64::engine::general_purpose::STANDARD.encode(sig),
        )),
        None => Err(RpcError::new(
            RPC_WALLET_ERROR,
            "Private key for address is not known",
        )),
    }
}

fn rpc_getbalance<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    mempool: &Mutex<Mempool>,
    wallet: &Mutex<Wallet>,
    params: Vec<Value>,
) -> Result<Value, RpcError> {
    if params.len() > 3 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "getbalance expects 0 to 3 parameters",
        ));
    }
    if let Some(value) = params.get(0) {
        if value.is_null() {
            // account omitted
        } else if let Some(account) = value.as_str() {
            if account != "*" && !account.is_empty() {
                return Err(RpcError::new(
                    RPC_INVALID_PARAMETER,
                    "account must be \"\" or \"*\"",
                ));
            }
        } else {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                "account must be a string",
            ));
        }
    }
    let minconf = match params.get(1) {
        Some(value) if !value.is_null() => parse_u32(value, "minconf")? as i32,
        _ => 1,
    };
    if let Some(value) = params.get(2) {
        if !value.is_null() && value.as_bool().is_none() {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                "include_watchonly must be a boolean",
            ));
        }
    }

    let include_watchonly = match params.get(2) {
        Some(Value::Bool(value)) => *value,
        Some(Value::Null) | None => false,
        Some(_) => false,
    };
    let (scripts, locked_outpoints) = {
        let guard = wallet
            .lock()
            .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;
        let scripts = if include_watchonly {
            guard
                .all_script_pubkeys_including_watchonly()
                .map_err(map_wallet_error)?
        } else {
            guard.all_script_pubkeys().map_err(map_wallet_error)?
        };
        let locked = guard.locked_outpoints();
        (scripts, locked)
    };
    let locked_set: HashSet<OutPoint> = locked_outpoints.into_iter().collect();
    let include_mempool_outputs = minconf == 0;
    let utxos = collect_wallet_utxos(chainstate, mempool, &scripts, include_mempool_outputs)?;
    let mut total: i64 = 0;
    for utxo in utxos {
        if utxo.confirmations < minconf {
            continue;
        }
        if utxo.is_coinbase && utxo.confirmations < COINBASE_MATURITY {
            continue;
        }
        if locked_set.contains(&utxo.outpoint) {
            continue;
        }
        total = total
            .checked_add(utxo.value)
            .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "balance overflow"))?;
    }
    Ok(amount_to_value(total))
}

fn rpc_getunconfirmedbalance<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    mempool: &Mutex<Mempool>,
    wallet: &Mutex<Wallet>,
    params: Vec<Value>,
) -> Result<Value, RpcError> {
    ensure_no_params(&params)?;
    let (scripts, locked_outpoints) = {
        let guard = wallet
            .lock()
            .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;
        (
            guard.all_script_pubkeys().map_err(map_wallet_error)?,
            guard.locked_outpoints(),
        )
    };
    let locked_set: HashSet<OutPoint> = locked_outpoints.into_iter().collect();
    let utxos = collect_wallet_utxos(chainstate, mempool, &scripts, true)?;
    let mut total: i64 = 0;
    for utxo in utxos {
        if utxo.confirmations != 0 {
            continue;
        }
        if locked_set.contains(&utxo.outpoint) {
            continue;
        }
        total = total
            .checked_add(utxo.value)
            .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "balance overflow"))?;
    }
    Ok(amount_to_value(total))
}

fn rpc_getreceivedbyaddress<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    mempool: &Mutex<Mempool>,
    wallet: &Mutex<Wallet>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    if params.is_empty() || params.len() > 2 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "getreceivedbyaddress expects 1 to 2 parameters",
        ));
    }
    let address = params[0]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "address must be a string"))?
        .trim();
    if address.is_empty() {
        return Err(RpcError::new(RPC_INVALID_PARAMETER, "address is empty"));
    }
    let minconf = match params.get(1) {
        Some(value) if !value.is_null() => parse_u32(value, "minconf")? as i32,
        _ => 1,
    };

    let script_pubkey = address_to_script_pubkey(address, chain_params.network)
        .map_err(|_| RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "Invalid address"))?;
    {
        let guard = wallet
            .lock()
            .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;
        let scripts = guard
            .scripts_for_filter(&[address.to_string()])
            .map_err(map_wallet_error)?;
        if scripts.is_empty() {
            return Err(RpcError::new(
                RPC_WALLET_ERROR,
                "Address not found in wallet",
            ));
        }
    }

    let best_height = chainstate
        .best_block()
        .map_err(map_internal)?
        .map(|tip| tip.height)
        .unwrap_or(0);
    let best_height_u32 = u32::try_from(best_height).unwrap_or(0);

    let mut received = 0i64;
    let mut visitor = |delta: fluxd_chainstate::address_deltas::AddressDeltaEntry| {
        if delta.satoshis <= 0 {
            return Ok(());
        }
        let confirmations = if best_height_u32 >= delta.height {
            best_height_u32
                .saturating_sub(delta.height)
                .saturating_add(1) as i32
        } else {
            0
        };
        if confirmations < minconf {
            return Ok(());
        }
        received = received.checked_add(delta.satoshis).ok_or_else(|| {
            fluxd_storage::StoreError::Backend("getreceivedbyaddress overflow".to_string())
        })?;
        Ok(())
    };
    chainstate
        .for_each_address_delta(&script_pubkey, &mut visitor)
        .map_err(map_internal)?;

    if minconf == 0 {
        let mempool_guard = mempool
            .lock()
            .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "mempool lock poisoned"))?;
        for entry in mempool_guard.entries() {
            for output in &entry.tx.vout {
                if output.script_pubkey.as_slice() != script_pubkey.as_slice() {
                    continue;
                }
                received = received
                    .checked_add(output.value)
                    .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "amount overflow"))?;
            }
        }
    }

    Ok(amount_to_value(received))
}

fn rpc_gettransaction<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    mempool: &Mutex<Mempool>,
    wallet: &Mutex<Wallet>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    if params.is_empty() || params.len() > 2 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "gettransaction expects 1 or 2 parameters",
        ));
    }
    let txid = parse_hash(&params[0])?;

    let include_watchonly = match params.get(1) {
        None | Some(Value::Null) => false,
        Some(value) => parse_bool(value)?,
    };

    let (
        wallet_scripts,
        owned_set,
        script_labels,
        change_key_hashes,
        tx_received_at,
        wallet_tx_raw,
        wallet_tx_values,
    ) = {
        let guard = wallet
            .lock()
            .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;
        let owned_scripts = guard.all_script_pubkeys().map_err(map_wallet_error)?;
        let change_key_hashes = guard.change_key_hashes();
        let tx_received_at = guard.tx_received_time(&txid);
        let wallet_tx_raw = guard.transaction_bytes(&txid).map(|bytes| bytes.to_vec());
        let wallet_tx_values = guard.transaction_values(&txid).cloned();
        let (scripts, owned_set) = if include_watchonly {
            let scripts = guard
                .all_script_pubkeys_including_watchonly()
                .map_err(map_wallet_error)?;
            let owned_set = owned_scripts.into_iter().collect::<HashSet<_>>();
            (scripts, Some(owned_set))
        } else {
            (owned_scripts, None)
        };

        let mut script_labels = HashMap::new();
        for script_pubkey in &scripts {
            if let Some(label) = guard.label_for_script_pubkey(script_pubkey) {
                script_labels.insert(script_pubkey.clone(), label.to_string());
            }
        }

        (
            scripts,
            owned_set,
            script_labels,
            change_key_hashes,
            tx_received_at,
            wallet_tx_raw,
            wallet_tx_values,
        )
    };
    if wallet_scripts.is_empty() {
        return Err(RpcError::new(
            RPC_INVALID_ADDRESS_OR_KEY,
            "Invalid or non-wallet transaction id",
        ));
    }

    let script_is_watchonly = |script_pubkey: &[u8]| match &owned_set {
        None => false,
        Some(set) => !set.contains(script_pubkey),
    };

    let wallet_script_set: HashSet<Vec<u8>> = wallet_scripts.iter().cloned().collect();
    let change_key_hash_set: HashSet<[u8; 20]> = change_key_hashes.into_iter().collect();
    let owned_spent_keys: HashSet<(u32, [u8; 20])> = match &owned_set {
        Some(set) => set
            .iter()
            .filter_map(|spk| match spent_address_info(spk) {
                (0, _) => None,
                (ty, hash) => Some((ty, hash)),
            })
            .collect(),
        None => wallet_script_set
            .iter()
            .filter_map(|spk| match spent_address_info(spk) {
                (0, _) => None,
                (ty, hash) => Some((ty, hash)),
            })
            .collect(),
    };
    let wallet_spent_keys: HashSet<(u32, [u8; 20])> = wallet_script_set
        .iter()
        .filter_map(|spk| match spent_address_info(spk) {
            (0, _) => None,
            (ty, hash) => Some((ty, hash)),
        })
        .collect();

    if let Ok(mempool_guard) = mempool.lock() {
        if let Some(entry) = mempool_guard.get(&txid) {
            let is_coinbase =
                entry.tx.vin.len() == 1 && entry.tx.vin[0].prevout == OutPoint::null();
            let mut credit_zat: i64 = 0;
            let mut debit_zat: i64 = 0;
            let mut involves_watchonly = false;
            let mut wallet_spent_outpoints: HashSet<OutPoint> = HashSet::new();

            for output in &entry.tx.vout {
                if !wallet_script_set.contains(output.script_pubkey.as_slice()) {
                    continue;
                }
                if script_is_watchonly(&output.script_pubkey) {
                    involves_watchonly = true;
                }
                credit_zat = credit_zat
                    .checked_add(output.value)
                    .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "amount overflow"))?;
            }

            let prevouts = mempool_guard.prevouts_for_tx(&entry.tx);
            for input in &entry.tx.vin {
                let mut prev_value = None;
                let mut prev_script_pubkey = None;

                match chainstate
                    .utxo_entry(&input.prevout)
                    .map_err(map_internal)?
                {
                    Some(utxo) => {
                        prev_value = Some(utxo.value);
                        prev_script_pubkey = Some(utxo.script_pubkey);
                    }
                    None => {
                        if let Some(prev) = prevouts.get(&input.prevout) {
                            prev_value = Some(prev.value);
                            prev_script_pubkey = Some(prev.script_pubkey.clone());
                        } else if let Ok(Some(prev_location)) =
                            chainstate.tx_location(&input.prevout.hash)
                        {
                            if let Ok(prev_bytes) = chainstate.read_block(prev_location.block) {
                                if let Ok(prev_block) = Block::consensus_decode(&prev_bytes) {
                                    let tx_index = prev_location.index as usize;
                                    let vout = input.prevout.index as usize;
                                    if let Some(prev_tx) = prev_block.transactions.get(tx_index) {
                                        if let Some(out) = prev_tx.vout.get(vout) {
                                            prev_value = Some(out.value);
                                            prev_script_pubkey = Some(out.script_pubkey.clone());
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                let (Some(value), Some(script_pubkey)) = (prev_value, prev_script_pubkey) else {
                    continue;
                };
                if !wallet_script_set.contains(script_pubkey.as_slice()) {
                    continue;
                }
                if script_is_watchonly(&script_pubkey) {
                    involves_watchonly = true;
                }
                debit_zat = debit_zat
                    .checked_add(value)
                    .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "amount overflow"))?;
                wallet_spent_outpoints.insert(input.prevout.clone());
            }

            if credit_zat == 0 && debit_zat == 0 {
                return Err(RpcError::new(
                    RPC_INVALID_ADDRESS_OR_KEY,
                    "Invalid or non-wallet transaction id",
                ));
            }

            let mut fee_zat: i64 = 0;
            if debit_zat > 0 {
                let value_out_zat = tx_value_out_for_fee(&entry.tx)?;
                fee_zat = value_out_zat
                    .checked_sub(debit_zat)
                    .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "amount overflow"))?;
            }

            let net_zat = credit_zat
                .checked_sub(debit_zat)
                .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "amount overflow"))?;
            let amount_zat = net_zat
                .checked_sub(fee_zat)
                .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "amount overflow"))?;

            let mut send_details = Vec::new();
            let mut receive_details = Vec::new();
            for (vout, output) in entry.tx.vout.iter().enumerate() {
                if wallet_script_set.contains(output.script_pubkey.as_slice()) {
                    if debit_zat > 0 {
                        if let Some(hash) = extract_p2pkh_hash(&output.script_pubkey) {
                            if change_key_hash_set.contains(&hash) {
                                continue;
                            }
                        }
                    }
                    let address =
                        script_pubkey_to_address(&output.script_pubkey, chain_params.network)
                            .ok_or(RpcError::new(
                                RPC_INTERNAL_ERROR,
                                "invalid wallet script_pubkey",
                            ))?;
                    let mut row = serde_json::Map::new();
                    row.insert(
                        "account".to_string(),
                        Value::String(
                            script_labels
                                .get(&output.script_pubkey)
                                .cloned()
                                .unwrap_or_default(),
                        ),
                    );
                    if involves_watchonly || script_is_watchonly(&output.script_pubkey) {
                        row.insert("involvesWatchonly".to_string(), Value::Bool(true));
                    }
                    row.insert("address".to_string(), Value::String(address));
                    row.insert("category".to_string(), Value::String("receive".to_string()));
                    row.insert("amount".to_string(), amount_to_value(output.value));
                    row.insert("amount_zat".to_string(), Value::Number(output.value.into()));
                    row.insert("vout".to_string(), Value::Number((vout as i64).into()));
                    receive_details.push(Value::Object(row));
                    continue;
                }

                if debit_zat > 0 {
                    let mut row = serde_json::Map::new();
                    row.insert("account".to_string(), Value::String(String::new()));
                    if involves_watchonly {
                        row.insert("involvesWatchonly".to_string(), Value::Bool(true));
                    }
                    if let Some(address) =
                        script_pubkey_to_address(&output.script_pubkey, chain_params.network)
                    {
                        row.insert("address".to_string(), Value::String(address));
                    }
                    row.insert("category".to_string(), Value::String("send".to_string()));
                    row.insert("amount".to_string(), amount_to_value(-output.value));
                    row.insert(
                        "amount_zat".to_string(),
                        Value::Number((-output.value).into()),
                    );
                    row.insert("vout".to_string(), Value::Number((vout as i64).into()));
                    row.insert("fee".to_string(), amount_to_value(fee_zat));
                    row.insert("fee_zat".to_string(), Value::Number(fee_zat.into()));
                    send_details.push(Value::Object(row));
                }
            }

            let mut details = Vec::with_capacity(send_details.len() + receive_details.len());
            details.extend(send_details);
            details.extend(receive_details);

            let walletconflicts = {
                let mut conflicts: BTreeSet<Hash256> = BTreeSet::new();
                for outpoint in &wallet_spent_outpoints {
                    if let Some(spender) = mempool_guard.spender(outpoint) {
                        if spender != txid {
                            conflicts.insert(spender);
                        }
                    }
                    if let Some(info) = chainstate.spent_info(outpoint).map_err(map_internal)? {
                        if info.txid != txid {
                            conflicts.insert(info.txid);
                        }
                    }
                }
                Value::Array(
                    conflicts
                        .into_iter()
                        .map(|conflict| Value::String(hash256_to_hex(&conflict)))
                        .collect(),
                )
            };

            let mut obj = json!({
                "amount": amount_to_value(amount_zat),
                "amount_zat": amount_zat,
                "confirmations": 0,
                "involvesWatchonly": involves_watchonly,
                "txid": hash256_to_hex(&txid),
                "time": entry.time,
                "timereceived": entry.time,
                "details": details,
                "vJoinSplit": joinsplits_to_json(&entry.tx.join_splits),
                "walletconflicts": walletconflicts,
                "hex": hex_bytes(&entry.raw),
            });
            if debit_zat > 0 {
                if let Value::Object(map) = &mut obj {
                    map.insert("fee".to_string(), amount_to_value(fee_zat));
                    map.insert("fee_zat".to_string(), Value::Number(fee_zat.into()));
                }
            }
            if is_coinbase {
                if let Value::Object(map) = &mut obj {
                    map.insert("generated".to_string(), Value::Bool(true));
                }
            }
            if let (Value::Object(map), Some(values)) = (&mut obj, wallet_tx_values.as_ref()) {
                for (key, value) in values {
                    if map.contains_key(key) {
                        continue;
                    }
                    map.insert(key.clone(), Value::String(value.clone()));
                }
            }
            return Ok(obj);
        }
    }

    let location = match chainstate.tx_location(&txid).map_err(map_internal)? {
        Some(location) => location,
        None => {
            let raw = wallet_tx_raw.ok_or_else(|| {
                RpcError::new(
                    RPC_INVALID_ADDRESS_OR_KEY,
                    "Invalid or non-wallet transaction id",
                )
            })?;
            let tx = Transaction::consensus_decode(&raw)
                .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "stored wallet tx decode failed"))?;
            let stored_txid = tx
                .txid()
                .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "stored wallet txid failed"))?;
            if stored_txid != txid {
                return Err(RpcError::new(
                    RPC_INTERNAL_ERROR,
                    "stored wallet txid mismatch",
                ));
            }

            let confirmations = -1;
            let is_coinbase = tx.vin.len() == 1 && tx.vin[0].prevout == OutPoint::null();
            let mut credit_zat: i64 = 0;
            let mut debit_zat: i64 = 0;
            let mut involves_watchonly = false;
            let mut wallet_spent_outpoints: HashSet<OutPoint> = HashSet::new();

            for output in &tx.vout {
                if !wallet_script_set.contains(output.script_pubkey.as_slice()) {
                    continue;
                }
                if script_is_watchonly(&output.script_pubkey) {
                    involves_watchonly = true;
                }
                credit_zat = credit_zat
                    .checked_add(output.value)
                    .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "amount overflow"))?;
            }

            for input in &tx.vin {
                let mut prev_value = None;
                let mut prev_script_pubkey = None;

                match chainstate
                    .utxo_entry(&input.prevout)
                    .map_err(map_internal)?
                {
                    Some(utxo) => {
                        prev_value = Some(utxo.value);
                        prev_script_pubkey = Some(utxo.script_pubkey);
                    }
                    None => {
                        if let Ok(Some(prev_location)) = chainstate.tx_location(&input.prevout.hash)
                        {
                            if let Ok(prev_bytes) = chainstate.read_block(prev_location.block) {
                                if let Ok(prev_block) = Block::consensus_decode(&prev_bytes) {
                                    let tx_index = prev_location.index as usize;
                                    let vout = input.prevout.index as usize;
                                    if let Some(prev_tx) = prev_block.transactions.get(tx_index) {
                                        if let Some(out) = prev_tx.vout.get(vout) {
                                            prev_value = Some(out.value);
                                            prev_script_pubkey = Some(out.script_pubkey.clone());
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                let (Some(value), Some(script_pubkey)) = (prev_value, prev_script_pubkey) else {
                    continue;
                };
                if !wallet_script_set.contains(script_pubkey.as_slice()) {
                    continue;
                }
                if script_is_watchonly(&script_pubkey) {
                    involves_watchonly = true;
                }
                debit_zat = debit_zat
                    .checked_add(value)
                    .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "amount overflow"))?;
                wallet_spent_outpoints.insert(input.prevout.clone());
            }

            if credit_zat == 0 && debit_zat == 0 {
                return Err(RpcError::new(
                    RPC_INVALID_ADDRESS_OR_KEY,
                    "Invalid or non-wallet transaction id",
                ));
            }

            let mut fee_zat: i64 = 0;
            if debit_zat > 0 {
                let value_out_zat = tx_value_out_for_fee(&tx)?;
                fee_zat = value_out_zat
                    .checked_sub(debit_zat)
                    .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "amount overflow"))?;
            }

            let net_zat = credit_zat
                .checked_sub(debit_zat)
                .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "amount overflow"))?;
            let amount_zat = net_zat
                .checked_sub(fee_zat)
                .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "amount overflow"))?;

            let mut send_details = Vec::new();
            let mut receive_details = Vec::new();
            let receive_category = if is_coinbase {
                if confirmations < 1 {
                    "orphan"
                } else if confirmations < COINBASE_MATURITY {
                    "immature"
                } else {
                    "generate"
                }
            } else {
                "receive"
            };
            for (vout, output) in tx.vout.iter().enumerate() {
                if wallet_script_set.contains(output.script_pubkey.as_slice()) {
                    if debit_zat > 0 {
                        if let Some(hash) = extract_p2pkh_hash(&output.script_pubkey) {
                            if change_key_hash_set.contains(&hash) {
                                continue;
                            }
                        }
                    }
                    let address =
                        script_pubkey_to_address(&output.script_pubkey, chain_params.network)
                            .ok_or(RpcError::new(
                                RPC_INTERNAL_ERROR,
                                "invalid wallet script_pubkey",
                            ))?;
                    let mut row = serde_json::Map::new();
                    row.insert(
                        "account".to_string(),
                        Value::String(
                            script_labels
                                .get(&output.script_pubkey)
                                .cloned()
                                .unwrap_or_default(),
                        ),
                    );
                    if involves_watchonly || script_is_watchonly(&output.script_pubkey) {
                        row.insert("involvesWatchonly".to_string(), Value::Bool(true));
                    }
                    row.insert("address".to_string(), Value::String(address));
                    row.insert(
                        "category".to_string(),
                        Value::String(receive_category.to_string()),
                    );
                    row.insert("amount".to_string(), amount_to_value(output.value));
                    row.insert("amount_zat".to_string(), Value::Number(output.value.into()));
                    row.insert("vout".to_string(), Value::Number((vout as i64).into()));
                    receive_details.push(Value::Object(row));
                    continue;
                }

                if debit_zat > 0 {
                    let mut row = serde_json::Map::new();
                    row.insert("account".to_string(), Value::String(String::new()));
                    if involves_watchonly {
                        row.insert("involvesWatchonly".to_string(), Value::Bool(true));
                    }
                    if let Some(address) =
                        script_pubkey_to_address(&output.script_pubkey, chain_params.network)
                    {
                        row.insert("address".to_string(), Value::String(address));
                    }
                    row.insert("category".to_string(), Value::String("send".to_string()));
                    row.insert("amount".to_string(), amount_to_value(-output.value));
                    row.insert(
                        "amount_zat".to_string(),
                        Value::Number((-output.value).into()),
                    );
                    row.insert("vout".to_string(), Value::Number((vout as i64).into()));
                    row.insert("fee".to_string(), amount_to_value(fee_zat));
                    row.insert("fee_zat".to_string(), Value::Number(fee_zat.into()));
                    send_details.push(Value::Object(row));
                }
            }

            let mut details = Vec::with_capacity(send_details.len() + receive_details.len());
            details.extend(send_details);
            details.extend(receive_details);

            let walletconflicts = {
                let mut conflicts: BTreeSet<Hash256> = BTreeSet::new();
                if let Ok(mempool_guard) = mempool.lock() {
                    for outpoint in &wallet_spent_outpoints {
                        if let Some(spender) = mempool_guard.spender(outpoint) {
                            if spender != txid {
                                conflicts.insert(spender);
                            }
                        }
                    }
                }
                for outpoint in &wallet_spent_outpoints {
                    if let Some(info) = chainstate.spent_info(outpoint).map_err(map_internal)? {
                        if info.txid != txid {
                            conflicts.insert(info.txid);
                        }
                    }
                }
                Value::Array(
                    conflicts
                        .into_iter()
                        .map(|conflict| Value::String(hash256_to_hex(&conflict)))
                        .collect(),
                )
            };

            let confirmed_time = tx_received_at
                .filter(|value| *value != 0)
                .unwrap_or_else(current_unix_seconds_u64);

            let mut obj = json!({
                "amount": amount_to_value(amount_zat),
                "amount_zat": amount_zat,
                "confirmations": confirmations,
                "involvesWatchonly": involves_watchonly,
                "txid": hash256_to_hex(&txid),
                "time": confirmed_time,
                "timereceived": confirmed_time,
                "details": details,
                "vJoinSplit": joinsplits_to_json(&tx.join_splits),
                "walletconflicts": walletconflicts,
                "hex": hex_bytes(&raw),
            });
            if debit_zat > 0 {
                if let Value::Object(map) = &mut obj {
                    map.insert("fee".to_string(), amount_to_value(fee_zat));
                    map.insert("fee_zat".to_string(), Value::Number(fee_zat.into()));
                }
            }
            if is_coinbase {
                if let Value::Object(map) = &mut obj {
                    map.insert("generated".to_string(), Value::Bool(true));
                }
            }

            if let (Value::Object(map), Some(values)) = (&mut obj, wallet_tx_values.as_ref()) {
                for (key, value) in values {
                    if map.contains_key(key) {
                        continue;
                    }
                    map.insert(key.clone(), Value::String(value.clone()));
                }
            }

            return Ok(obj);
        }
    };
    let bytes = chainstate
        .read_block(location.block)
        .map_err(map_internal)?;
    let block = fluxd_primitives::block::Block::consensus_decode(&bytes).map_err(map_internal)?;
    let tx_index = location.index as usize;
    let tx = block
        .transactions
        .get(tx_index)
        .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "transaction index out of range"))?;
    let encoded = tx.consensus_encode().map_err(map_internal)?;
    let block_hash = block.header.hash();
    let header_entry = chainstate.header_entry(&block_hash).map_err(map_internal)?;
    let mut confirmations = -1;
    if let Some(entry) = header_entry.as_ref() {
        let best_height = best_block_height(chainstate)?;
        confirmations =
            confirmations_for_height(chainstate, entry.height, best_height, &block_hash)?;
    }
    let is_coinbase = tx.vin.len() == 1 && tx.vin[0].prevout == OutPoint::null();

    let mut credit_zat: i64 = 0;
    let mut debit_zat: i64 = 0;
    let mut involves_watchonly = false;
    let mut wallet_spent_outpoints: HashSet<OutPoint> = HashSet::new();

    for output in &tx.vout {
        if !wallet_script_set.contains(output.script_pubkey.as_slice()) {
            continue;
        }
        if script_is_watchonly(&output.script_pubkey) {
            involves_watchonly = true;
        }
        credit_zat = credit_zat
            .checked_add(output.value)
            .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "amount overflow"))?;
    }

    let mut block_txids: HashMap<Hash256, &Transaction> = HashMap::new();
    for candidate in &block.transactions {
        if let Ok(id) = candidate.txid() {
            block_txids.insert(id, candidate);
        }
    }

    for (vin_index, input) in tx.vin.iter().enumerate() {
        if input.prevout == OutPoint::null() {
            continue;
        }

        let mut handled = false;
        if let Some(info) = chainstate
            .spent_info(&input.prevout)
            .map_err(map_internal)?
        {
            if info.txid == txid && info.input_index == vin_index as u32 {
                if let Some(details) = info.details {
                    if details.address_type != 0 {
                        handled = true;
                        if wallet_spent_keys.contains(&(details.address_type, details.address_hash))
                        {
                            if !owned_spent_keys
                                .contains(&(details.address_type, details.address_hash))
                            {
                                involves_watchonly = true;
                            }
                            debit_zat =
                                debit_zat.checked_add(details.satoshis).ok_or_else(|| {
                                    RpcError::new(RPC_INTERNAL_ERROR, "amount overflow")
                                })?;
                            wallet_spent_outpoints.insert(input.prevout.clone());
                        }
                    }
                }
            }
        }
        if handled {
            continue;
        }

        let mut prev_value = None;
        let mut prev_script = None;
        if let Some(candidate) = block_txids.get(&input.prevout.hash) {
            let idx = input.prevout.index as usize;
            if let Some(out) = candidate.vout.get(idx) {
                prev_value = Some(out.value);
                prev_script = Some(out.script_pubkey.clone());
            }
        }
        if prev_value.is_none() {
            if let Ok(Some(prev_location)) = chainstate.tx_location(&input.prevout.hash) {
                if let Ok(prev_bytes) = chainstate.read_block(prev_location.block) {
                    if let Ok(prev_block) = Block::consensus_decode(&prev_bytes) {
                        let idx = prev_location.index as usize;
                        if let Some(prev_tx) = prev_block.transactions.get(idx) {
                            let vout = input.prevout.index as usize;
                            if let Some(out) = prev_tx.vout.get(vout) {
                                prev_value = Some(out.value);
                                prev_script = Some(out.script_pubkey.clone());
                            }
                        }
                    }
                }
            }
        }
        let (Some(value), Some(script_pubkey)) = (prev_value, prev_script) else {
            continue;
        };
        if !wallet_script_set.contains(script_pubkey.as_slice()) {
            continue;
        }
        if script_is_watchonly(&script_pubkey) {
            involves_watchonly = true;
        }
        debit_zat = debit_zat
            .checked_add(value)
            .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "amount overflow"))?;
        wallet_spent_outpoints.insert(input.prevout.clone());
    }

    if credit_zat == 0 && debit_zat == 0 {
        return Err(RpcError::new(
            RPC_INVALID_ADDRESS_OR_KEY,
            "Invalid or non-wallet transaction id",
        ));
    }

    let mut fee_zat: i64 = 0;
    if debit_zat > 0 {
        let value_out_zat = tx_value_out_for_fee(tx)?;
        fee_zat = value_out_zat
            .checked_sub(debit_zat)
            .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "amount overflow"))?;
    }

    let net_zat = credit_zat
        .checked_sub(debit_zat)
        .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "amount overflow"))?;
    let amount_zat = net_zat
        .checked_sub(fee_zat)
        .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "amount overflow"))?;

    let mut send_details = Vec::new();
    let mut receive_details = Vec::new();
    let receive_category = if is_coinbase {
        if confirmations < 1 {
            "orphan"
        } else if confirmations < COINBASE_MATURITY {
            "immature"
        } else {
            "generate"
        }
    } else {
        "receive"
    };
    for (vout, output) in tx.vout.iter().enumerate() {
        if wallet_script_set.contains(output.script_pubkey.as_slice()) {
            if debit_zat > 0 {
                if let Some(hash) = extract_p2pkh_hash(&output.script_pubkey) {
                    if change_key_hash_set.contains(&hash) {
                        continue;
                    }
                }
            }
            let address =
                script_pubkey_to_address(&output.script_pubkey, chain_params.network).ok_or(
                    RpcError::new(RPC_INTERNAL_ERROR, "invalid wallet script_pubkey"),
                )?;
            let mut row = serde_json::Map::new();
            row.insert(
                "account".to_string(),
                Value::String(
                    script_labels
                        .get(&output.script_pubkey)
                        .cloned()
                        .unwrap_or_default(),
                ),
            );
            if involves_watchonly || script_is_watchonly(&output.script_pubkey) {
                row.insert("involvesWatchonly".to_string(), Value::Bool(true));
            }
            row.insert("address".to_string(), Value::String(address));
            row.insert(
                "category".to_string(),
                Value::String(receive_category.to_string()),
            );
            row.insert("amount".to_string(), amount_to_value(output.value));
            row.insert("amount_zat".to_string(), Value::Number(output.value.into()));
            row.insert("vout".to_string(), Value::Number((vout as i64).into()));
            receive_details.push(Value::Object(row));
            continue;
        }

        if debit_zat > 0 {
            let mut row = serde_json::Map::new();
            row.insert("account".to_string(), Value::String(String::new()));
            if involves_watchonly {
                row.insert("involvesWatchonly".to_string(), Value::Bool(true));
            }
            if let Some(address) =
                script_pubkey_to_address(&output.script_pubkey, chain_params.network)
            {
                row.insert("address".to_string(), Value::String(address));
            }
            row.insert("category".to_string(), Value::String("send".to_string()));
            row.insert("amount".to_string(), amount_to_value(-output.value));
            row.insert(
                "amount_zat".to_string(),
                Value::Number((-output.value).into()),
            );
            row.insert("vout".to_string(), Value::Number((vout as i64).into()));
            row.insert("fee".to_string(), amount_to_value(fee_zat));
            row.insert("fee_zat".to_string(), Value::Number(fee_zat.into()));
            send_details.push(Value::Object(row));
        }
    }

    let mut details = Vec::with_capacity(send_details.len() + receive_details.len());
    details.extend(send_details);
    details.extend(receive_details);

    let walletconflicts = {
        let mut conflicts: BTreeSet<Hash256> = BTreeSet::new();
        if let Ok(mempool_guard) = mempool.lock() {
            for outpoint in &wallet_spent_outpoints {
                if let Some(spender) = mempool_guard.spender(outpoint) {
                    if spender != txid {
                        conflicts.insert(spender);
                    }
                }
            }
        }
        for outpoint in &wallet_spent_outpoints {
            if let Some(info) = chainstate.spent_info(outpoint).map_err(map_internal)? {
                if info.txid != txid {
                    conflicts.insert(info.txid);
                }
            }
        }
        Value::Array(
            conflicts
                .into_iter()
                .map(|conflict| Value::String(hash256_to_hex(&conflict)))
                .collect(),
        )
    };

    let confirmed_time = tx_received_at
        .filter(|value| *value != 0)
        .unwrap_or(u64::from(block.header.time));

    let mut obj = json!({
        "amount": amount_to_value(amount_zat),
        "amount_zat": amount_zat,
        "confirmations": confirmations,
        "involvesWatchonly": involves_watchonly,
        "txid": hash256_to_hex(&txid),
        "time": confirmed_time,
        "timereceived": confirmed_time,
        "details": details,
        "vJoinSplit": joinsplits_to_json(&tx.join_splits),
        "walletconflicts": walletconflicts,
        "hex": hex_bytes(&encoded),
    });
    if debit_zat > 0 {
        if let Value::Object(map) = &mut obj {
            map.insert("fee".to_string(), amount_to_value(fee_zat));
            map.insert("fee_zat".to_string(), Value::Number(fee_zat.into()));
        }
    }
    if is_coinbase {
        if let Value::Object(map) = &mut obj {
            map.insert("generated".to_string(), Value::Bool(true));
        }
    }

    if confirmations > 0 {
        if let Value::Object(map) = &mut obj {
            map.insert(
                "blockhash".to_string(),
                Value::String(hash256_to_hex(&block_hash)),
            );
            map.insert(
                "blockindex".to_string(),
                Value::Number(location.index.into()),
            );
            map.insert(
                "blocktime".to_string(),
                Value::Number(block.header.time.into()),
            );
            map.insert(
                "expiryheight".to_string(),
                Value::Number(i64::from(tx.expiry_height).into()),
            );
        }
    }

    if let (Value::Object(map), Some(values)) = (&mut obj, wallet_tx_values.as_ref()) {
        for (key, value) in values {
            if map.contains_key(key) {
                continue;
            }
            map.insert(key.clone(), Value::String(value.clone()));
        }
    }

    Ok(obj)
}

fn joinsplits_to_json(joinsplits: &[fluxd_primitives::transaction::JoinSplit]) -> Value {
    Value::Array(
        joinsplits
            .iter()
            .map(|joinsplit| {
                json!({
                    "anchor": hash256_to_hex(&joinsplit.anchor),
                    "nullifiers": joinsplit
                        .nullifiers
                        .iter()
                        .map(|hash| hash256_to_hex(hash))
                        .collect::<Vec<_>>(),
                    "commitments": joinsplit
                        .commitments
                        .iter()
                        .map(|hash| hash256_to_hex(hash))
                        .collect::<Vec<_>>(),
                    "macs": joinsplit
                        .macs
                        .iter()
                        .map(|hash| hash256_to_hex(hash))
                        .collect::<Vec<_>>(),
                    "vpub_old": amount_to_value(joinsplit.vpub_old),
                    "vpub_new": amount_to_value(joinsplit.vpub_new),
                })
            })
            .collect(),
    )
}

fn spent_address_info(script_pubkey: &[u8]) -> (u32, [u8; 20]) {
    if script_pubkey.len() == 25
        && script_pubkey[0] == 0x76
        && script_pubkey[1] == 0xa9
        && script_pubkey[2] == 0x14
        && script_pubkey[23] == 0x88
        && script_pubkey[24] == 0xac
    {
        let mut hash = [0u8; 20];
        hash.copy_from_slice(&script_pubkey[3..23]);
        return (1, hash);
    }
    if script_pubkey.len() == 23
        && script_pubkey[0] == 0xa9
        && script_pubkey[1] == 0x14
        && script_pubkey[22] == 0x87
    {
        let mut hash = [0u8; 20];
        hash.copy_from_slice(&script_pubkey[2..22]);
        return (2, hash);
    }
    (0, [0u8; 20])
}

fn tx_value_out_for_fee(tx: &Transaction) -> Result<i64, RpcError> {
    let mut total = 0i64;
    for output in &tx.vout {
        if output.value < 0 || output.value > MAX_MONEY {
            return Err(RpcError::new(RPC_TRANSACTION_ERROR, "value out of range"));
        }
        total = total
            .checked_add(output.value)
            .ok_or_else(|| RpcError::new(RPC_TRANSACTION_ERROR, "value out of range"))?;
        if !money_range(total) {
            return Err(RpcError::new(RPC_TRANSACTION_ERROR, "value out of range"));
        }
    }

    if tx.value_balance <= 0 {
        let balance = -tx.value_balance;
        total = total
            .checked_add(balance)
            .ok_or_else(|| RpcError::new(RPC_TRANSACTION_ERROR, "value out of range"))?;
        if !money_range(balance) || !money_range(total) {
            return Err(RpcError::new(RPC_TRANSACTION_ERROR, "value out of range"));
        }
    }

    for joinsplit in &tx.join_splits {
        total = total
            .checked_add(joinsplit.vpub_old)
            .ok_or_else(|| RpcError::new(RPC_TRANSACTION_ERROR, "value out of range"))?;
        if !money_range(joinsplit.vpub_old) || !money_range(total) {
            return Err(RpcError::new(RPC_TRANSACTION_ERROR, "value out of range"));
        }
    }

    Ok(total)
}

fn rpc_listtransactions<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    mempool: &Mutex<Mempool>,
    wallet: &Mutex<Wallet>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    if params.len() > 4 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "listtransactions expects 0 to 4 parameters",
        ));
    }
    if let Some(value) = params.first() {
        if !value.is_null() && value.as_str().is_none() {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                "account must be a string",
            ));
        }
    }
    let account_filter = match params.first() {
        None | Some(Value::Null) => None,
        Some(value) => {
            let account = value
                .as_str()
                .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "account must be a string"))?
                .trim()
                .to_string();
            if account == "*" {
                None
            } else {
                Some(account)
            }
        }
    };
    let count = match params.get(1) {
        Some(value) if !value.is_null() => {
            if let Some(num) = value.as_i64() {
                if num < 0 {
                    return Err(RpcError::new(RPC_INVALID_PARAMETER, "Negative count"));
                }
            }
            parse_u32(value, "count")?
        }
        _ => 10,
    };
    let from = match params.get(2) {
        Some(value) if !value.is_null() => {
            if let Some(num) = value.as_i64() {
                if num < 0 {
                    return Err(RpcError::new(RPC_INVALID_PARAMETER, "Negative from"));
                }
            }
            parse_u32(value, "from")?
        }
        _ => 0,
    };

    let include_watchonly = match params.get(3) {
        None | Some(Value::Null) => false,
        Some(value) => parse_bool(value)?,
    };

    let (wallet_scripts, stored_transactions) = {
        let guard = wallet
            .lock()
            .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;
        let scripts = if include_watchonly {
            guard
                .all_script_pubkeys_including_watchonly()
                .map_err(map_wallet_error)?
        } else {
            guard.all_script_pubkeys().map_err(map_wallet_error)?
        };
        let stored_transactions = guard.stored_transactions();
        (scripts, stored_transactions)
    };
    if wallet_scripts.is_empty() {
        return Ok(Value::Array(Vec::new()));
    }

    let wallet_contains_script =
        |script_pubkey: &[u8]| wallet_scripts.iter().any(|s| s.as_slice() == script_pubkey);

    #[derive(Clone, Copy)]
    enum CandidateOrder {
        Mempool { time: u64 },
        WalletStore { time: u64 },
        Chain { height: u32, tx_index: u32 },
    }

    #[derive(Clone, Copy)]
    struct Candidate {
        txid: Hash256,
        order: CandidateOrder,
    }

    let mut unconfirmed_candidates = Vec::new();
    if let Ok(mempool_guard) = mempool.lock() {
        for entry in mempool_guard.entries() {
            let mut touches_wallet = entry
                .tx
                .vout
                .iter()
                .any(|out| wallet_contains_script(&out.script_pubkey));
            if !touches_wallet {
                let prevouts = mempool_guard.prevouts_for_tx(&entry.tx);
                for input in &entry.tx.vin {
                    let script_pubkey = match chainstate
                        .utxo_entry(&input.prevout)
                        .map_err(map_internal)?
                    {
                        Some(utxo) => utxo.script_pubkey,
                        None => match prevouts.get(&input.prevout) {
                            Some(prev) => prev.script_pubkey.clone(),
                            None => continue,
                        },
                    };
                    if wallet_contains_script(&script_pubkey) {
                        touches_wallet = true;
                        break;
                    }
                }
            }
            if touches_wallet {
                unconfirmed_candidates.push(Candidate {
                    txid: entry.txid,
                    order: CandidateOrder::Mempool { time: entry.time },
                });
            }
        }
    }

    let mut seen_chain: HashMap<Hash256, (u32, u32)> = HashMap::new();
    for script_pubkey in &wallet_scripts {
        let deltas = chainstate
            .address_deltas(script_pubkey)
            .map_err(map_internal)?;
        for delta in deltas {
            seen_chain
                .entry(delta.txid)
                .and_modify(|entry| {
                    entry.0 = entry.0.max(delta.height);
                    entry.1 = entry.1.max(delta.tx_index);
                })
                .or_insert((delta.height, delta.tx_index));
        }
    }
    let mut chain_candidates = seen_chain
        .into_iter()
        .map(|(txid, (height, tx_index))| Candidate {
            txid,
            order: CandidateOrder::Chain { height, tx_index },
        })
        .collect::<Vec<_>>();
    chain_candidates.sort_by(|a, b| match (a.order, b.order) {
        (
            CandidateOrder::Chain {
                height: a_height,
                tx_index: a_index,
            },
            CandidateOrder::Chain {
                height: b_height,
                tx_index: b_index,
            },
        ) => b_height
            .cmp(&a_height)
            .then_with(|| b_index.cmp(&a_index))
            .then_with(|| b.txid.cmp(&a.txid)),
        _ => std::cmp::Ordering::Equal,
    });

    let mut seen_txids: HashSet<Hash256> = unconfirmed_candidates
        .iter()
        .map(|cand| cand.txid)
        .collect();
    for cand in &chain_candidates {
        seen_txids.insert(cand.txid);
    }

    for (txid, time) in stored_transactions {
        if !seen_txids.insert(txid) {
            continue;
        }
        unconfirmed_candidates.push(Candidate {
            txid,
            order: CandidateOrder::WalletStore { time },
        });
    }

    let order_rank = |order| match order {
        CandidateOrder::Mempool { .. } => 0u8,
        CandidateOrder::WalletStore { .. } => 1u8,
        CandidateOrder::Chain { .. } => 2u8,
    };
    unconfirmed_candidates.sort_by(|a, b| {
        let a_time = match a.order {
            CandidateOrder::Mempool { time } | CandidateOrder::WalletStore { time } => time,
            CandidateOrder::Chain { .. } => 0,
        };
        let b_time = match b.order {
            CandidateOrder::Mempool { time } | CandidateOrder::WalletStore { time } => time,
            CandidateOrder::Chain { .. } => 0,
        };
        b_time
            .cmp(&a_time)
            .then_with(|| order_rank(a.order).cmp(&order_rank(b.order)))
            .then_with(|| b.txid.cmp(&a.txid))
    });

    let mut candidates = Vec::with_capacity(
        unconfirmed_candidates
            .len()
            .saturating_add(chain_candidates.len()),
    );
    candidates.extend(unconfirmed_candidates);
    candidates.extend(chain_candidates);

    let from = usize::try_from(from).unwrap_or(usize::MAX);
    let count = usize::try_from(count).unwrap_or(0);
    if count == 0 {
        return Ok(Value::Array(Vec::new()));
    }

    let target = from.saturating_add(count);
    let mut newest_to_oldest = Vec::new();

    'outer: for cand in candidates {
        if newest_to_oldest.len() >= target {
            break;
        }
        let view = match rpc_gettransaction(
            chainstate,
            mempool,
            wallet,
            vec![
                Value::String(hash256_to_hex(&cand.txid)),
                Value::Bool(include_watchonly),
            ],
            chain_params,
        ) {
            Ok(view) => view,
            Err(err)
                if matches!(cand.order, CandidateOrder::WalletStore { .. })
                    && err.code == RPC_INVALID_ADDRESS_OR_KEY =>
            {
                continue
            }
            Err(err) => return Err(err),
        };
        let obj = view
            .as_object()
            .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "invalid gettransaction result"))?;

        let size = obj
            .get("hex")
            .and_then(Value::as_str)
            .and_then(|hex| (hex.len() % 2 == 0).then_some((hex.len() / 2) as i64))
            .map(|size| Value::Number(size.into()));

        let details = obj.get("details").and_then(Value::as_array);
        let Some(details) = details else {
            continue;
        };

        let mut send_details = Vec::new();
        let mut other_details = Vec::new();
        for detail in details {
            let cat = detail
                .as_object()
                .and_then(|row| row.get("category").and_then(Value::as_str));
            if cat == Some("send") {
                send_details.push(detail);
            } else {
                other_details.push(detail);
            }
        }

        for detail in send_details.into_iter().chain(other_details) {
            let Some(detail) = detail.as_object() else {
                continue;
            };
            if let Some(filter) = account_filter.as_deref() {
                let account = detail
                    .get("account")
                    .and_then(Value::as_str)
                    .unwrap_or_default();
                if account != filter {
                    continue;
                }
            }
            let mut row = serde_json::Map::new();
            row.insert(
                "account".to_string(),
                detail
                    .get("account")
                    .cloned()
                    .unwrap_or_else(|| Value::String(String::new())),
            );
            if let Some(value) = detail.get("involvesWatchonly") {
                row.insert("involvesWatchonly".to_string(), value.clone());
            }
            if let Some(value) = detail.get("address") {
                row.insert("address".to_string(), value.clone());
            }
            if let Some(value) = detail.get("category") {
                row.insert("category".to_string(), value.clone());
            }
            if let Some(value) = detail.get("amount") {
                row.insert("amount".to_string(), value.clone());
            }
            if let Some(value) = detail.get("amount_zat") {
                row.insert("amount_zat".to_string(), value.clone());
            }
            if let Some(value) = detail.get("vout") {
                row.insert("vout".to_string(), value.clone());
            }
            if let Some(value) = detail.get("fee") {
                row.insert("fee".to_string(), value.clone());
            }
            if let Some(value) = detail.get("fee_zat") {
                row.insert("fee_zat".to_string(), value.clone());
            }

            if let Some(value) = obj.get("confirmations") {
                row.insert("confirmations".to_string(), value.clone());
            }
            if let Some(value) = obj.get("txid") {
                row.insert("txid".to_string(), value.clone());
            }
            if let Some(value) = obj.get("blockhash") {
                row.insert("blockhash".to_string(), value.clone());
            }
            if let Some(value) = obj.get("blockindex") {
                row.insert("blockindex".to_string(), value.clone());
            }
            if let Some(value) = obj.get("blocktime") {
                row.insert("blocktime".to_string(), value.clone());
            }
            if let Some(value) = obj.get("time") {
                row.insert("time".to_string(), value.clone());
            }
            if let Some(value) = obj.get("timereceived") {
                row.insert("timereceived".to_string(), value.clone());
            }
            if let Some(value) = obj.get("generated") {
                row.insert("generated".to_string(), value.clone());
            }
            if let Some(value) = obj.get("expiryheight") {
                row.insert("expiryheight".to_string(), value.clone());
            }
            if let Some(value) = obj.get("walletconflicts") {
                row.insert("walletconflicts".to_string(), value.clone());
            }
            if let Some(value) = obj.get("vJoinSplit") {
                row.insert("vJoinSplit".to_string(), value.clone());
            }
            if let Some(value) = obj.get("comment") {
                row.insert("comment".to_string(), value.clone());
            }
            if let Some(value) = obj.get("to") {
                row.insert("to".to_string(), value.clone());
            }
            if let Some(size) = &size {
                row.insert("size".to_string(), size.clone());
            }

            newest_to_oldest.push(Value::Object(row));
            if newest_to_oldest.len() >= target {
                break 'outer;
            }
        }
    }

    let from = from.min(newest_to_oldest.len());
    let count = count.min(newest_to_oldest.len().saturating_sub(from));
    let mut out = newest_to_oldest
        .into_iter()
        .skip(from)
        .take(count)
        .collect::<Vec<_>>();
    out.reverse();
    Ok(Value::Array(out))
}

fn rpc_listsinceblock<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    mempool: &Mutex<Mempool>,
    wallet: &Mutex<Wallet>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    if params.len() > 3 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "listsinceblock expects 0 to 3 parameters",
        ));
    }

    let best_height = best_block_height(chainstate)?;

    let start_height = match params.first() {
        None | Some(Value::Null) => None,
        Some(value) => match parse_hash_sethex(value)? {
            Some(hash) => chainstate
                .header_entry(&hash)
                .map_err(map_internal)?
                .map(|entry| entry.height),
            None => None,
        },
    };

    let target_confirmations = match params.get(1) {
        None | Some(Value::Null) => 1u32,
        Some(value) => {
            if let Some(num) = value.as_i64() {
                if num < 0 {
                    return Err(RpcError::new(RPC_INVALID_PARAMETER, "Invalid parameter"));
                }
            }
            parse_u32(value, "target-confirmations")?
        }
    };
    if target_confirmations < 1 {
        return Err(RpcError::new(RPC_INVALID_PARAMETER, "Invalid parameter"));
    }

    let include_watchonly = match params.get(2) {
        None | Some(Value::Null) => false,
        Some(value) => parse_bool(value)?,
    };

    let (wallet_scripts, stored_transactions) = {
        let guard = wallet
            .lock()
            .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;
        let scripts = if include_watchonly {
            guard
                .all_script_pubkeys_including_watchonly()
                .map_err(map_wallet_error)?
        } else {
            guard.all_script_pubkeys().map_err(map_wallet_error)?
        };
        let stored_transactions = guard.stored_transactions();
        (scripts, stored_transactions)
    };

    #[derive(Clone, Copy)]
    enum CandidateOrder {
        Mempool { time: u64 },
        WalletStore { time: u64 },
        Chain { height: u32, tx_index: u32 },
    }

    #[derive(Clone, Copy)]
    struct Candidate {
        txid: Hash256,
        order: CandidateOrder,
    }

    let wallet_contains_script =
        |script_pubkey: &[u8]| wallet_scripts.iter().any(|s| s.as_slice() == script_pubkey);

    let mut unconfirmed_candidates = Vec::new();
    if !wallet_scripts.is_empty() {
        if let Ok(mempool_guard) = mempool.lock() {
            for entry in mempool_guard.entries() {
                let mut touches_wallet = entry
                    .tx
                    .vout
                    .iter()
                    .any(|out| wallet_contains_script(&out.script_pubkey));
                if !touches_wallet {
                    let prevouts = mempool_guard.prevouts_for_tx(&entry.tx);
                    for input in &entry.tx.vin {
                        let script_pubkey = match chainstate
                            .utxo_entry(&input.prevout)
                            .map_err(map_internal)?
                        {
                            Some(utxo) => utxo.script_pubkey,
                            None => match prevouts.get(&input.prevout) {
                                Some(prev) => prev.script_pubkey.clone(),
                                None => continue,
                            },
                        };
                        if wallet_contains_script(&script_pubkey) {
                            touches_wallet = true;
                            break;
                        }
                    }
                }
                if touches_wallet {
                    unconfirmed_candidates.push(Candidate {
                        txid: entry.txid,
                        order: CandidateOrder::Mempool { time: entry.time },
                    });
                }
            }
        }
    }

    let mut seen_chain: HashMap<Hash256, (u32, u32)> = HashMap::new();
    if !wallet_scripts.is_empty() {
        for script_pubkey in &wallet_scripts {
            let deltas = chainstate
                .address_deltas(script_pubkey)
                .map_err(map_internal)?;
            for delta in deltas {
                if let Some(start_height) = start_height {
                    if i32::try_from(delta.height).unwrap_or(i32::MAX) <= start_height {
                        continue;
                    }
                }
                seen_chain
                    .entry(delta.txid)
                    .and_modify(|entry| {
                        entry.0 = entry.0.max(delta.height);
                        entry.1 = entry.1.max(delta.tx_index);
                    })
                    .or_insert((delta.height, delta.tx_index));
            }
        }
    }
    let mut chain_candidates = seen_chain
        .into_iter()
        .map(|(txid, (height, tx_index))| Candidate {
            txid,
            order: CandidateOrder::Chain { height, tx_index },
        })
        .collect::<Vec<_>>();
    chain_candidates.sort_by(|a, b| match (a.order, b.order) {
        (
            CandidateOrder::Chain {
                height: a_height,
                tx_index: a_index,
            },
            CandidateOrder::Chain {
                height: b_height,
                tx_index: b_index,
            },
        ) => b_height
            .cmp(&a_height)
            .then_with(|| b_index.cmp(&a_index))
            .then_with(|| b.txid.cmp(&a.txid)),
        _ => std::cmp::Ordering::Equal,
    });

    let mut seen_txids: HashSet<Hash256> = unconfirmed_candidates
        .iter()
        .map(|cand| cand.txid)
        .collect();
    for cand in &chain_candidates {
        seen_txids.insert(cand.txid);
    }

    for (txid, time) in stored_transactions {
        if !seen_txids.insert(txid) {
            continue;
        }
        unconfirmed_candidates.push(Candidate {
            txid,
            order: CandidateOrder::WalletStore { time },
        });
    }

    let order_rank = |order| match order {
        CandidateOrder::Mempool { .. } => 0u8,
        CandidateOrder::WalletStore { .. } => 1u8,
        CandidateOrder::Chain { .. } => 2u8,
    };
    unconfirmed_candidates.sort_by(|a, b| {
        let a_time = match a.order {
            CandidateOrder::Mempool { time } | CandidateOrder::WalletStore { time } => time,
            CandidateOrder::Chain { .. } => 0,
        };
        let b_time = match b.order {
            CandidateOrder::Mempool { time } | CandidateOrder::WalletStore { time } => time,
            CandidateOrder::Chain { .. } => 0,
        };
        b_time
            .cmp(&a_time)
            .then_with(|| order_rank(a.order).cmp(&order_rank(b.order)))
            .then_with(|| b.txid.cmp(&a.txid))
    });

    let mut candidates = Vec::with_capacity(
        unconfirmed_candidates
            .len()
            .saturating_add(chain_candidates.len()),
    );
    candidates.extend(unconfirmed_candidates);
    candidates.extend(chain_candidates);

    let mut transactions = Vec::new();
    for cand in candidates {
        let view = match rpc_gettransaction(
            chainstate,
            mempool,
            wallet,
            vec![
                Value::String(hash256_to_hex(&cand.txid)),
                Value::Bool(include_watchonly),
            ],
            chain_params,
        ) {
            Ok(view) => view,
            Err(err)
                if matches!(cand.order, CandidateOrder::WalletStore { .. })
                    && err.code == RPC_INVALID_ADDRESS_OR_KEY =>
            {
                continue
            }
            Err(err) => return Err(err),
        };
        let obj = view
            .as_object()
            .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "invalid gettransaction result"))?;

        let confirmations = obj
            .get("confirmations")
            .and_then(Value::as_i64)
            .unwrap_or(-1);
        if let Some(start_height) = start_height {
            let depth = best_height - start_height + 1;
            if confirmations >= depth as i64 {
                continue;
            }
        }

        let size = obj
            .get("hex")
            .and_then(Value::as_str)
            .and_then(|hex| (hex.len() % 2 == 0).then_some((hex.len() / 2) as i64))
            .map(|size| Value::Number(size.into()));

        let details = obj.get("details").and_then(Value::as_array);
        let Some(details) = details else {
            continue;
        };

        let mut send_details = Vec::new();
        let mut other_details = Vec::new();
        for detail in details {
            let cat = detail
                .as_object()
                .and_then(|row| row.get("category").and_then(Value::as_str));
            if cat == Some("send") {
                send_details.push(detail);
            } else {
                other_details.push(detail);
            }
        }

        for detail in send_details.into_iter().chain(other_details) {
            let Some(detail) = detail.as_object() else {
                continue;
            };
            let mut row = serde_json::Map::new();
            row.insert(
                "account".to_string(),
                detail
                    .get("account")
                    .cloned()
                    .unwrap_or_else(|| Value::String(String::new())),
            );
            if let Some(value) = detail.get("involvesWatchonly") {
                row.insert("involvesWatchonly".to_string(), value.clone());
            }
            if let Some(value) = detail.get("address") {
                row.insert("address".to_string(), value.clone());
            }
            if let Some(value) = detail.get("category") {
                row.insert("category".to_string(), value.clone());
            }
            if let Some(value) = detail.get("amount") {
                row.insert("amount".to_string(), value.clone());
            }
            if let Some(value) = detail.get("amount_zat") {
                row.insert("amount_zat".to_string(), value.clone());
            }
            if let Some(value) = detail.get("vout") {
                row.insert("vout".to_string(), value.clone());
            }
            if let Some(value) = detail.get("fee") {
                row.insert("fee".to_string(), value.clone());
            }
            if let Some(value) = detail.get("fee_zat") {
                row.insert("fee_zat".to_string(), value.clone());
            }

            if let Some(value) = obj.get("confirmations") {
                row.insert("confirmations".to_string(), value.clone());
            }
            if let Some(value) = obj.get("txid") {
                row.insert("txid".to_string(), value.clone());
            }
            if let Some(value) = obj.get("blockhash") {
                row.insert("blockhash".to_string(), value.clone());
            }
            if let Some(value) = obj.get("blockindex") {
                row.insert("blockindex".to_string(), value.clone());
            }
            if let Some(value) = obj.get("blocktime") {
                row.insert("blocktime".to_string(), value.clone());
            }
            if let Some(value) = obj.get("time") {
                row.insert("time".to_string(), value.clone());
            }
            if let Some(value) = obj.get("timereceived") {
                row.insert("timereceived".to_string(), value.clone());
            }
            if let Some(value) = obj.get("generated") {
                row.insert("generated".to_string(), value.clone());
            }
            if let Some(value) = obj.get("expiryheight") {
                row.insert("expiryheight".to_string(), value.clone());
            }
            if let Some(value) = obj.get("walletconflicts") {
                row.insert("walletconflicts".to_string(), value.clone());
            }
            if let Some(value) = obj.get("vJoinSplit") {
                row.insert("vJoinSplit".to_string(), value.clone());
            }
            if let Some(value) = obj.get("comment") {
                row.insert("comment".to_string(), value.clone());
            }
            if let Some(value) = obj.get("to") {
                row.insert("to".to_string(), value.clone());
            }
            if let Some(size) = &size {
                row.insert("size".to_string(), size.clone());
            }

            transactions.push(Value::Object(row));
        }
    }
    transactions.reverse();

    let lastblock_height = best_height.saturating_add(1) - target_confirmations as i32;
    let lastblock = if lastblock_height < 0 {
        [0u8; 32]
    } else {
        chainstate
            .height_hash(lastblock_height)
            .map_err(map_internal)?
            .unwrap_or([0u8; 32])
    };

    Ok(json!({
        "transactions": transactions,
        "lastblock": hash256_to_hex(&lastblock),
    }))
}

fn rpc_listreceivedbyaddress<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    mempool: &Mutex<Mempool>,
    wallet: &Mutex<Wallet>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    if params.len() > 4 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "listreceivedbyaddress expects 0 to 4 parameters",
        ));
    }
    let minconf = match params.get(0) {
        Some(value) if !value.is_null() => parse_u32(value, "minconf")? as i32,
        _ => 1,
    };
    let include_empty = match params.get(1) {
        Some(value) if !value.is_null() => parse_bool(value)?,
        _ => false,
    };
    let include_watchonly = match params.get(2) {
        Some(value) if !value.is_null() => parse_bool(value)?,
        _ => false,
    };
    let address_filter = match params.get(3) {
        None | Some(Value::Null) => None,
        Some(Value::String(addr)) => Some(addr.trim().to_string()),
        Some(value) if value.as_str().is_some() => value.as_str().map(|s| s.trim().to_string()),
        _ => {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                "address_filter must be a string",
            ))
        }
    }
    .filter(|s| !s.is_empty());

    let (wallet_scripts, owned_scripts, script_labels) = {
        let guard = wallet
            .lock()
            .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;
        let owned_scripts = guard.all_script_pubkeys().map_err(map_wallet_error)?;
        let wallet_scripts = if include_watchonly {
            guard
                .all_script_pubkeys_including_watchonly()
                .map_err(map_wallet_error)?
        } else {
            owned_scripts.clone()
        };
        let mut script_labels = HashMap::new();
        for script_pubkey in &wallet_scripts {
            if let Some(label) = guard.label_for_script_pubkey(script_pubkey) {
                script_labels.insert(script_pubkey.clone(), label.to_string());
            }
        }
        (wallet_scripts, owned_scripts, script_labels)
    };
    if wallet_scripts.is_empty() {
        return Ok(Value::Array(Vec::new()));
    }
    let owned_set: HashSet<Vec<u8>> = owned_scripts.into_iter().collect();

    let best_height = chainstate
        .best_block()
        .map_err(map_internal)?
        .map(|tip| tip.height)
        .unwrap_or(0);
    let best_height_u32 = u32::try_from(best_height).unwrap_or(0);

    let mut mempool_received: HashMap<Vec<u8>, i64> = HashMap::new();
    let mut mempool_txids: HashMap<Vec<u8>, std::collections::BTreeSet<Hash256>> = HashMap::new();
    if minconf == 0 {
        if let Ok(mempool_guard) = mempool.lock() {
            for entry in mempool_guard.entries() {
                for output in &entry.tx.vout {
                    if !wallet_scripts
                        .iter()
                        .any(|script| script.as_slice() == output.script_pubkey.as_slice())
                    {
                        continue;
                    }
                    mempool_txids
                        .entry(output.script_pubkey.clone())
                        .or_default()
                        .insert(entry.txid);
                    mempool_received
                        .entry(output.script_pubkey.clone())
                        .and_modify(|sum| *sum = sum.saturating_add(output.value))
                        .or_insert(output.value);
                }
            }
        }
    }

    let mut out: Vec<(i64, Value)> = Vec::new();
    for script_pubkey in &wallet_scripts {
        let Some(address) = script_pubkey_to_address(script_pubkey, chain_params.network) else {
            return Err(RpcError::new(
                RPC_INTERNAL_ERROR,
                "invalid wallet script_pubkey",
            ));
        };
        if let Some(filter) = address_filter.as_deref() {
            if address != filter {
                continue;
            }
        }

        let mut received_zat: i64 = 0;
        let mut last_height: Option<u32> = None;
        let mut txids = std::collections::BTreeSet::<(u32, Hash256)>::new();
        let mut visitor = |delta: fluxd_chainstate::address_deltas::AddressDeltaEntry| {
            if delta.satoshis <= 0 {
                return Ok(());
            }
            let confirmations = if best_height_u32 >= delta.height {
                best_height_u32
                    .saturating_sub(delta.height)
                    .saturating_add(1) as i32
            } else {
                0
            };
            if confirmations < minconf {
                return Ok(());
            }
            received_zat = received_zat.checked_add(delta.satoshis).ok_or_else(|| {
                fluxd_storage::StoreError::Backend("listreceivedbyaddress overflow".to_string())
            })?;
            last_height = Some(last_height.map_or(delta.height, |h| h.max(delta.height)));
            txids.insert((delta.height, delta.txid));
            Ok(())
        };
        chainstate
            .for_each_address_delta(script_pubkey, &mut visitor)
            .map_err(map_internal)?;

        let mut txids = txids
            .into_iter()
            .map(|(_height, txid)| Value::String(hash256_to_hex(&txid)))
            .collect::<Vec<_>>();
        if minconf == 0 {
            if let Some(value) = mempool_received.get(script_pubkey) {
                received_zat = received_zat
                    .checked_add(*value)
                    .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "amount overflow"))?;
            }
            if let Some(entries) = mempool_txids.get(script_pubkey) {
                txids.extend(
                    entries
                        .iter()
                        .map(|txid| Value::String(hash256_to_hex(txid))),
                );
            }
        }

        if received_zat == 0 && !include_empty {
            continue;
        }

        let confirmations = if minconf == 0 {
            0
        } else {
            last_height
                .and_then(|h| best_height_u32.checked_sub(h).map(|d| d.saturating_add(1)))
                .unwrap_or(0) as i32
        };

        let label = script_labels
            .get(script_pubkey)
            .cloned()
            .unwrap_or_default();
        out.push((
            received_zat,
            json!({
                "involvesWatchonly": !owned_set.contains(script_pubkey),
                "address": address,
                "account": label.clone(),
                "amount": amount_to_value(received_zat),
                "confirmations": confirmations,
                "label": label,
                "txids": txids,
            }),
        ));
    }

    out.sort_by(|a, b| b.0.cmp(&a.0));
    Ok(Value::Array(
        out.into_iter().map(|(_amount, row)| row).collect(),
    ))
}

fn rpc_listunspent<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    mempool: &Mutex<Mempool>,
    wallet: &Mutex<Wallet>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    if params.len() > 3 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "listunspent expects 0 to 3 parameters",
        ));
    }
    let minconf = match params.get(0) {
        Some(value) if !value.is_null() => parse_u32(value, "minconf")? as i32,
        _ => 1,
    };
    let maxconf = match params.get(1) {
        Some(value) if !value.is_null() => parse_u32(value, "maxconf")? as i32,
        _ => 9_999_999,
    };
    if maxconf < minconf {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "maxconf must be >= minconf",
        ));
    }

    let addresses: Vec<String> = match params.get(2) {
        None | Some(Value::Null) => Vec::new(),
        Some(Value::Array(values)) => {
            let mut seen: HashSet<String> = HashSet::new();
            let mut out = Vec::with_capacity(values.len());
            for value in values {
                let address = value
                    .as_str()
                    .ok_or_else(|| {
                        RpcError::new(RPC_INVALID_PARAMETER, "addresses must be strings")
                    })?
                    .to_string();
                address_to_script_pubkey(&address, chain_params.network).map_err(|_| {
                    RpcError::new(
                        RPC_INVALID_ADDRESS_OR_KEY,
                        format!("Invalid Flux address: {address}"),
                    )
                })?;
                if !seen.insert(address.clone()) {
                    return Err(RpcError::new(
                        RPC_INVALID_PARAMETER,
                        format!("Invalid parameter, duplicated address: {address}"),
                    ));
                }
                out.push(address);
            }
            out
        }
        _ => {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                "addresses must be an array",
            ))
        }
    };

    let (scripts, owned_scripts, locked_outpoints) = {
        let guard = wallet
            .lock()
            .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;
        let scripts = guard
            .scripts_for_filter(&addresses)
            .map_err(map_wallet_error)?;
        let owned_scripts = guard.all_script_pubkeys().map_err(map_wallet_error)?;
        let locked_outpoints = guard.locked_outpoints();
        (scripts, owned_scripts, locked_outpoints)
    };
    let owned_script_set: HashSet<Vec<u8>> = owned_scripts.into_iter().collect();
    let locked_set: HashSet<OutPoint> = locked_outpoints.into_iter().collect();

    let include_mempool_outputs = minconf == 0;
    let mut utxos = collect_wallet_utxos(chainstate, mempool, &scripts, include_mempool_outputs)?;
    utxos.retain(|utxo| {
        if locked_set.contains(&utxo.outpoint) {
            return false;
        }
        if utxo.confirmations < minconf {
            return false;
        }
        if utxo.confirmations > maxconf {
            return false;
        }
        if utxo.is_coinbase && utxo.confirmations < COINBASE_MATURITY {
            return false;
        }
        true
    });
    utxos.sort_by(|a, b| {
        a.height
            .cmp(&b.height)
            .then_with(|| a.outpoint.hash.cmp(&b.outpoint.hash))
            .then_with(|| a.outpoint.index.cmp(&b.outpoint.index))
    });

    let wallet_guard = wallet
        .lock()
        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;
    let mut out = Vec::with_capacity(utxos.len());
    for row in utxos {
        let address = script_pubkey_to_address(&row.script_pubkey, chain_params.network)
            .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "invalid script_pubkey"))?;
        let owned = owned_script_set.contains(&row.script_pubkey);
        let spendable = owned;
        let mut entry = serde_json::Map::new();
        if let Some(label) = wallet_guard.label_for_script_pubkey(&row.script_pubkey) {
            if !label.is_empty() {
                entry.insert("account".to_string(), Value::String(label.to_string()));
            }
        }
        entry.insert(
            "txid".to_string(),
            Value::String(hash256_to_hex(&row.outpoint.hash)),
        );
        entry.insert("vout".to_string(), Value::Number(row.outpoint.index.into()));
        entry.insert("generated".to_string(), Value::Bool(row.is_coinbase));
        entry.insert("address".to_string(), Value::String(address));
        entry.insert(
            "scriptPubKey".to_string(),
            Value::String(hex_bytes(&row.script_pubkey)),
        );
        entry.insert("amount".to_string(), amount_to_value(row.value));
        entry.insert("amount_zat".to_string(), Value::Number(row.value.into()));
        entry.insert(
            "confirmations".to_string(),
            Value::Number(row.confirmations.into()),
        );
        if let Some(redeem_script) =
            wallet_guard.redeem_script_for_p2sh_script_pubkey(&row.script_pubkey)
        {
            entry.insert(
                "redeemScript".to_string(),
                Value::String(hex_bytes(&redeem_script)),
            );
        }
        entry.insert("spendable".to_string(), Value::Bool(spendable));
        out.push(Value::Object(entry));
    }
    Ok(Value::Array(out))
}

fn rpc_getwalletinfo<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    mempool: &Mutex<Mempool>,
    wallet: &Mutex<Wallet>,
    params: Vec<Value>,
) -> Result<Value, RpcError> {
    ensure_no_params(&params)?;

    let scripts = {
        let guard = wallet
            .lock()
            .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;
        guard.all_script_pubkeys().map_err(map_wallet_error)?
    };
    let utxos = collect_wallet_utxos(chainstate, mempool, &scripts, true)?;
    let mut balance: i64 = 0;
    let mut immature: i64 = 0;
    let mut unconfirmed: i64 = 0;
    for utxo in utxos {
        if utxo.confirmations == 0 {
            unconfirmed = unconfirmed
                .checked_add(utxo.value)
                .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "balance overflow"))?;
            continue;
        }
        if utxo.is_coinbase && utxo.confirmations < COINBASE_MATURITY {
            immature = immature
                .checked_add(utxo.value)
                .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "balance overflow"))?;
            continue;
        }
        balance = balance
            .checked_add(utxo.value)
            .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "balance overflow"))?;
    }

    let (pay_tx_fee_per_kb, tx_count, keypool_oldest, keypool_size, unlocked_until, encrypted) = {
        let mut guard = wallet
            .lock()
            .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;
        let encrypted = guard.is_encrypted();
        let unlocked_until = if encrypted { guard.unlocked_until() } else { 0 };
        (
            guard.pay_tx_fee_per_kb(),
            guard.tx_count(),
            guard.keypool_oldest(),
            guard.keypool_size(),
            unlocked_until,
            encrypted,
        )
    };

    let mut out = serde_json::Map::new();
    out.insert(
        "walletversion".to_string(),
        Value::Number((WALLET_FILE_VERSION as u64).into()),
    );
    out.insert("balance".to_string(), amount_to_value(balance));
    out.insert("balance_zat".to_string(), Value::Number(balance.into()));
    out.insert(
        "unconfirmed_balance".to_string(),
        amount_to_value(unconfirmed),
    );
    out.insert(
        "unconfirmed_balance_zat".to_string(),
        Value::Number(unconfirmed.into()),
    );
    out.insert("immature_balance".to_string(), amount_to_value(immature));
    out.insert(
        "immature_balance_zat".to_string(),
        Value::Number(immature.into()),
    );
    out.insert(
        "txcount".to_string(),
        Value::Number((tx_count as u64).into()),
    );
    out.insert(
        "keypoololdest".to_string(),
        Value::Number(keypool_oldest.into()),
    );
    out.insert(
        "keypoolsize".to_string(),
        Value::Number((keypool_size as u64).into()),
    );
    if encrypted {
        out.insert(
            "unlocked_until".to_string(),
            Value::Number(unlocked_until.into()),
        );
    }
    out.insert("paytxfee".to_string(), amount_to_value(pay_tx_fee_per_kb));
    out.insert(
        "paytxfee_zat".to_string(),
        Value::Number(pay_tx_fee_per_kb.into()),
    );
    Ok(Value::Object(out))
}

fn rpc_getdbinfo<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    store: &Store,
    params: Vec<Value>,
    data_dir: &Path,
) -> Result<Value, RpcError> {
    ensure_no_params(&params)?;
    let backend = match store {
        Store::Fjall(_) => Backend::Fjall,
        Store::Memory(_) => Backend::Memory,
    };
    db_info::collect_db_info(chainstate, store, data_dir, backend, false, false)
        .map_err(|err| RpcError::new(RPC_INTERNAL_ERROR, err))
}

fn rpc_getdeprecationinfo(params: Vec<Value>) -> Result<Value, RpcError> {
    ensure_no_params(&params)?;
    Ok(json!({
        "deprecated": false,
        "version": node_version(),
        "subversion": format!("/fluxd-rust:{}/", env!("CARGO_PKG_VERSION")),
        "warnings": "",
    }))
}

fn rpc_help(params: Vec<Value>) -> Result<Value, RpcError> {
    if params.is_empty() {
        let methods = RPC_METHODS
            .iter()
            .map(|name| Value::String((*name).to_string()))
            .collect::<Vec<_>>();
        return Ok(Value::Array(methods));
    }
    if params.len() > 1 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "help expects 0 or 1 parameter",
        ));
    }
    let name = params[0]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "method name must be a string"))?;
    if RPC_METHODS.contains(&name) {
        Ok(Value::String(format!("{name} is supported")))
    } else {
        Err(RpcError::new(RPC_METHOD_NOT_FOUND, "method not found"))
    }
}

fn rpc_getinfo<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    mempool: &Mutex<Mempool>,
    wallet: &Mutex<Wallet>,
    rpc_params: Vec<Value>,
    chain_params: &ChainParams,
    _data_dir: &Path,
    net_totals: &NetTotals,
    peer_registry: &PeerRegistry,
    mempool_policy: &MempoolPolicy,
) -> Result<Value, RpcError> {
    ensure_no_params(&rpc_params)?;
    let (scripts, locked_outpoints, keypool_oldest, keypool_size, unlocked_until, encrypted) = {
        let mut guard = wallet
            .lock()
            .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;
        let encrypted = guard.is_encrypted();
        let unlocked_until = if encrypted { guard.unlocked_until() } else { 0 };
        (
            guard.all_script_pubkeys().map_err(map_wallet_error)?,
            guard.locked_outpoints(),
            guard.keypool_oldest(),
            guard.keypool_size(),
            unlocked_until,
            encrypted,
        )
    };
    let locked_set: HashSet<OutPoint> = locked_outpoints.into_iter().collect();
    let utxos = collect_wallet_utxos(chainstate, mempool, &scripts, false)?;
    let mut balance: i64 = 0;
    for utxo in utxos {
        if utxo.confirmations < 1 {
            continue;
        }
        if utxo.is_coinbase && utxo.confirmations < COINBASE_MATURITY {
            continue;
        }
        if locked_set.contains(&utxo.outpoint) {
            continue;
        }
        balance = balance
            .checked_add(utxo.value)
            .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "balance overflow"))?;
    }

    let (walletversion, paytxfee) = {
        let guard = wallet
            .lock()
            .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;
        (WALLET_FILE_VERSION, guard.pay_tx_fee_per_kb())
    };
    let connections = net_totals.snapshot().connections.max(peer_registry.count());
    let best_block = chainstate
        .best_block()
        .map_err(map_internal)?
        .map(|tip| tip.height)
        .unwrap_or(0);
    let best_header = chainstate
        .best_header()
        .map_err(map_internal)?
        .map(|tip| tip.hash);
    let difficulty = match best_header {
        Some(hash) => {
            let entry = chainstate
                .header_entry(&hash)
                .map_err(map_internal)?
                .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "missing header entry"))?;
            difficulty_from_bits(entry.bits, chain_params).unwrap_or(0.0)
        }
        None => 0.0,
    };

    let mut out = json!({
        "version": node_version(),
        "protocolversion": PROTOCOL_VERSION,
        "walletversion": walletversion,
        "balance": amount_to_value(balance),
        "blocks": best_block,
        "timeoffset": 0,
        "connections": connections,
        "proxy": "",
        "difficulty": difficulty,
        "testnet": chain_params.network != Network::Mainnet,
        "keypoololdest": keypool_oldest,
        "keypoolsize": keypool_size,
        "paytxfee": amount_to_value(paytxfee),
        "relayfee": amount_to_value(mempool_policy.min_relay_fee_per_kb),
        "errors": ""
    });

    if encrypted {
        out["unlocked_until"] = Value::Number(unlocked_until.into());
    }

    Ok(out)
}

fn rpc_getblockcount<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    params: Vec<Value>,
) -> Result<Value, RpcError> {
    ensure_no_params(&params)?;
    let height = chainstate
        .best_block()
        .map_err(map_internal)?
        .map(|tip| tip.height)
        .unwrap_or(0);
    Ok(Value::Number(height.into()))
}

fn rpc_getbestblockhash<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    params: Vec<Value>,
) -> Result<Value, RpcError> {
    ensure_no_params(&params)?;
    let best = chainstate
        .best_block()
        .map_err(map_internal)?
        .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "best block not found"))?;
    Ok(Value::String(hash256_to_hex(&best.hash)))
}

fn rpc_getblockhash<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    params: Vec<Value>,
) -> Result<Value, RpcError> {
    if params.len() != 1 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "getblockhash expects 1 parameter",
        ));
    }
    let height = parse_height(&params[0])?;
    if height < 0 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "block height out of range",
        ));
    }
    let best_height = chainstate
        .best_block()
        .map_err(map_internal)?
        .map(|tip| tip.height)
        .unwrap_or(0);
    if height > best_height {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "block height out of range",
        ));
    }
    let hash = chainstate
        .height_hash(height)
        .map_err(map_internal)?
        .ok_or_else(|| RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "block not found"))?;
    Ok(Value::String(hash256_to_hex(&hash)))
}

fn rpc_getblockheader<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    if params.is_empty() || params.len() > 2 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "getblockheader expects 1 or 2 parameters",
        ));
    }
    let hash = parse_hash(&params[0])?;
    let verbose = if params.len() > 1 {
        parse_bool(&params[1])?
    } else {
        true
    };
    let entry = chainstate
        .header_entry(&hash)
        .map_err(map_internal)?
        .ok_or_else(|| RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "block not found"))?;
    let header_bytes = chainstate
        .block_header_bytes(&hash)
        .map_err(map_internal)?
        .ok_or_else(|| RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "block not found"))?;
    let header = fluxd_primitives::block::BlockHeader::consensus_decode(&header_bytes)
        .map_err(map_internal)?;

    if !verbose {
        return Ok(Value::String(hex_bytes(&header_bytes)));
    }

    let best_height = best_block_height(chainstate)?;
    let confirmations = confirmations_for_height(chainstate, entry.height, best_height, &hash)?;
    let next_block_hash = next_hash_for_height(chainstate, entry.height, best_height, &hash)?;
    let mut result = json!({
        "hash": hash256_to_hex(&hash),
        "confirmations": confirmations,
        "height": entry.height,
        "version": header.version,
        "merkleroot": hash256_to_hex(&header.merkle_root),
        "finalsaplingroot": hash256_to_hex(&header.final_sapling_root),
        "time": header.time,
        "bits": format!("{:08x}", header.bits),
        "difficulty": difficulty_from_bits(header.bits, chain_params).unwrap_or(0.0),
        "chainwork": hex_bytes(&entry.chainwork),
    });

    if header.is_pon() {
        result["type"] = Value::String("PON".to_string());
        result["collateral"] = Value::String(format_outpoint(&header.nodes_collateral));
        result["blocksig"] = Value::String(hex_bytes(&header.block_sig));
    } else {
        result["type"] = Value::String("POW".to_string());
        result["nonce"] = Value::String(hash256_to_hex(&header.nonce));
        result["solution"] = Value::String(hex_bytes(&header.solution));
    }

    if entry.height > 0 {
        result["previousblockhash"] = Value::String(hash256_to_hex(&entry.prev_hash));
    }
    if let Some(next_hash) = next_block_hash {
        result["nextblockhash"] = Value::String(hash256_to_hex(&next_hash));
    }

    Ok(result)
}

fn rpc_getblock<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    if params.is_empty() || params.len() > 2 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "getblock expects 1 or 2 parameters",
        ));
    }
    let (hash, entry) = resolve_block_hash(chainstate, &params[0])?;
    let verbosity = if params.len() > 1 {
        parse_verbosity(&params[1])?
    } else {
        1
    };

    let location = chainstate
        .block_location(&hash)
        .map_err(map_internal)?
        .ok_or_else(|| RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "block not found"))?;
    let bytes = chainstate.read_block(location).map_err(map_internal)?;
    let block = fluxd_primitives::block::Block::consensus_decode(&bytes).map_err(map_internal)?;

    if verbosity == 0 {
        return Ok(Value::String(hex_bytes(&bytes)));
    }

    let best_height = best_block_height(chainstate)?;
    let confirmations = confirmations_for_height(chainstate, entry.height, best_height, &hash)?;
    let next_block_hash = next_hash_for_height(chainstate, entry.height, best_height, &hash)?;

    #[derive(Default)]
    struct FluxnodeTierCounts {
        cumulus: u32,
        nimbus: u32,
        stratus: u32,
        starting: u32,
        unknown: u32,
    }

    let mut regular_tx_count = 0u32;
    let mut fluxnode_tx_count = 0u32;
    let mut tier_counts = FluxnodeTierCounts::default();

    let mut txs = Vec::with_capacity(block.transactions.len());
    for tx in &block.transactions {
        match tx.fluxnode.as_ref() {
            None => regular_tx_count = regular_tx_count.saturating_add(1),
            Some(fluxnode) => {
                fluxnode_tx_count = fluxnode_tx_count.saturating_add(1);
                match fluxnode {
                    FluxnodeTx::V5(FluxnodeTxV5::Start(_))
                    | FluxnodeTx::V6(FluxnodeTxV6::Start(_)) => {
                        tier_counts.starting = tier_counts.starting.saturating_add(1);
                    }
                    FluxnodeTx::V5(FluxnodeTxV5::Confirm(confirm))
                    | FluxnodeTx::V6(FluxnodeTxV6::Confirm(confirm)) => match confirm.benchmark_tier
                    {
                        1 => tier_counts.cumulus = tier_counts.cumulus.saturating_add(1),
                        2 => tier_counts.nimbus = tier_counts.nimbus.saturating_add(1),
                        3 => tier_counts.stratus = tier_counts.stratus.saturating_add(1),
                        _ => tier_counts.unknown = tier_counts.unknown.saturating_add(1),
                    },
                }
            }
        }

        if verbosity >= 2 {
            txs.push(tx_to_json(tx, chain_params.network)?);
        } else {
            let txid = tx.txid().map_err(map_internal)?;
            txs.push(Value::String(hash256_to_hex(&txid)));
        }
    }

    let mut result = json!({
        "hash": hash256_to_hex(&hash),
        "confirmations": confirmations,
        "size": bytes.len(),
        "height": entry.height,
        "version": block.header.version,
        "merkleroot": hash256_to_hex(&block.header.merkle_root),
        "finalsaplingroot": hash256_to_hex(&block.header.final_sapling_root),
        "tx": Value::Array(txs),
        "time": block.header.time,
        "bits": format!("{:08x}", block.header.bits),
        "difficulty": difficulty_from_bits(block.header.bits, chain_params).unwrap_or(0.0),
        "chainwork": hex_bytes(&entry.chainwork),
    });

    result["regularTxCount"] = Value::Number((regular_tx_count as i64).into());
    result["nodeConfirmationCount"] = Value::Number((fluxnode_tx_count as i64).into());
    result["tierCounts"] = json!({
        "cumulus": tier_counts.cumulus,
        "nimbus": tier_counts.nimbus,
        "stratus": tier_counts.stratus,
        "starting": tier_counts.starting,
        "unknown": tier_counts.unknown,
    });

    if block.header.is_pon() {
        result["type"] = Value::String("PON".to_string());
        result["collateral"] = Value::String(format_outpoint(&block.header.nodes_collateral));
        result["blocksig"] = Value::String(hex_bytes(&block.header.block_sig));
    } else {
        result["type"] = Value::String("POW".to_string());
        result["nonce"] = Value::String(hash256_to_hex(&block.header.nonce));
        result["solution"] = Value::String(hex_bytes(&block.header.solution));
    }

    if entry.height > 0 {
        result["previousblockhash"] = Value::String(hash256_to_hex(&entry.prev_hash));
    }
    if let Some(next_hash) = next_block_hash {
        result["nextblockhash"] = Value::String(hash256_to_hex(&next_hash));
    }

    Ok(result)
}

fn rpc_getblockchaininfo<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    params: Vec<Value>,
    chain_params: &ChainParams,
    data_dir: &Path,
) -> Result<Value, RpcError> {
    ensure_no_params(&params)?;
    let best_header = chainstate.best_header().map_err(map_internal)?;
    let best_block = chainstate.best_block().map_err(map_internal)?;
    let best_header_height = best_header.as_ref().map(|tip| tip.height).unwrap_or(-1);
    let best_block_height = best_block.as_ref().map(|tip| tip.height).unwrap_or(-1);
    let best_block_hash = best_block.as_ref().map(|tip| tip.hash);
    let best_header_hash = best_header.as_ref().map(|tip| tip.hash);
    let difficulty = match best_header_hash {
        Some(hash) => {
            let entry = chainstate
                .header_entry(&hash)
                .map_err(map_internal)?
                .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "missing header entry"))?;
            difficulty_from_bits(entry.bits, chain_params).unwrap_or(0.0)
        }
        None => 0.0,
    };
    let chainwork = best_block
        .as_ref()
        .map(|tip| hex_bytes(&tip.chainwork))
        .unwrap_or_else(|| "00".to_string());
    let size_on_disk = db_info::dir_size_cached(data_dir, Duration::from_secs(30)).unwrap_or(0);
    let verificationprogress = if best_header_height > 0 && best_block_height >= 0 {
        (best_block_height as f64 / best_header_height as f64).min(1.0)
    } else {
        0.0
    };

    let upgrades = build_upgrade_info(chain_params, best_block_height);
    let consensus = json!({
        "chaintip": format!("{:08x}", current_epoch_branch_id(best_block_height, &chain_params.consensus.upgrades)),
        "nextblock": format!("{:08x}", current_epoch_branch_id(best_block_height + 1, &chain_params.consensus.upgrades)),
    });

    let commitments = chainstate.sprout_commitment_count().map_err(map_internal)?;
    let softforks = build_softfork_info(chainstate, best_block_hash, &chain_params.consensus)?;
    let value_pools = chainstate.value_pools_or_compute().map_err(map_internal)?;
    let utxo_stats = chainstate.utxo_stats_or_compute().map_err(map_internal)?;
    let shielded_total = value_pools
        .sprout
        .checked_add(value_pools.sapling)
        .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "shielded value pool overflow"))?;
    let total_supply = utxo_stats
        .total_amount
        .checked_add(shielded_total)
        .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "total supply overflow"))?;

    Ok(json!({
        "chain": network_name(chain_params.network),
        "blocks": best_block_height.max(0),
        "headers": best_header_height.max(0),
        "bestblockhash": best_block_hash.map(|hash| hash256_to_hex(&hash)),
        "difficulty": difficulty,
        "verificationprogress": verificationprogress,
        "chainwork": chainwork,
        "pruned": false,
        "size_on_disk": size_on_disk,
        "commitments": commitments,
        "valuePools": [
            {
                "id": "sprout",
                "monitored": true,
                "chainValue": amount_to_value(value_pools.sprout),
                "chainValueZat": value_pools.sprout,
            },
            {
                "id": "sapling",
                "monitored": true,
                "chainValue": amount_to_value(value_pools.sapling),
                "chainValueZat": value_pools.sapling,
            }
        ],
        "total_supply": amount_to_value(total_supply),
        "total_supply_zat": total_supply,
        "softforks": softforks,
        "upgrades": upgrades,
        "consensus": consensus
    }))
}

fn rpc_getdifficulty<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    ensure_no_params(&params)?;
    let best_header = chainstate
        .best_header()
        .map_err(map_internal)?
        .map(|tip| tip.hash);
    let difficulty = match best_header {
        Some(hash) => {
            let entry = chainstate
                .header_entry(&hash)
                .map_err(map_internal)?
                .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "missing header entry"))?;
            difficulty_from_bits(entry.bits, chain_params).unwrap_or(0.0)
        }
        None => 0.0,
    };
    Number::from_f64(difficulty)
        .map(Value::Number)
        .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "difficulty out of range"))
}

fn rpc_getchaintips<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    params: Vec<Value>,
) -> Result<Value, RpcError> {
    if params.len() > 1 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "getchaintips expects 0 or 1 parameter",
        ));
    }

    let current_height = chainstate
        .best_block()
        .map_err(map_internal)?
        .map(|tip| tip.height)
        .unwrap_or(0);

    let min_height = match params.first() {
        None | Some(Value::Null) => 0,
        Some(value) => {
            let requested = parse_i64(value, "blockheight")?;
            if requested < 0 || requested > current_height as i64 {
                0
            } else {
                requested as i32
            }
        }
    };

    let entries = chainstate.scan_headers().map_err(map_internal)?;
    if entries.is_empty() {
        return Ok(Value::Array(Vec::new()));
    }

    let best_block = chainstate.best_block().map_err(map_internal)?;
    let best_hash = best_block.as_ref().map(|tip| tip.hash);

    let mut referenced = HashSet::new();
    let mut candidates = Vec::new();
    for (hash, entry) in entries {
        if entry.height < min_height {
            continue;
        }
        if entry.height > min_height {
            referenced.insert(entry.prev_hash);
        }
        candidates.push((hash, entry));
    }

    let mut tips = Vec::new();
    for (hash, entry) in candidates {
        if Some(hash) != best_hash && referenced.contains(&hash) {
            continue;
        }

        let status = if Some(hash) == best_hash {
            "active"
        } else if entry.is_failed() {
            "invalid"
        } else if entry.has_block() {
            "valid-fork"
        } else if chainstate
            .unconnected_block_bytes(&hash)
            .map_err(map_internal)?
            .is_some()
        {
            "valid-headers"
        } else {
            "headers-only"
        };

        let branchlen = if status == "active" {
            0
        } else {
            branch_len(chainstate, &hash, entry.height)?
        };
        tips.push(json!({
            "height": entry.height,
            "hash": hash256_to_hex(&hash),
            "branchlen": branchlen,
            "status": status,
        }));
    }

    Ok(Value::Array(tips))
}

fn rpc_getblocksubsidy<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    if params.len() > 1 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "getblocksubsidy expects 0 or 1 parameter",
        ));
    }
    let height = if params.is_empty() {
        chainstate
            .best_block()
            .map_err(map_internal)?
            .map(|tip| tip.height)
            .unwrap_or(0)
    } else {
        parse_height(&params[0])?
    };
    if height < 0 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "block height out of range",
        ));
    }
    let subsidy = block_subsidy(height, &chain_params.consensus);
    Ok(json!({
        "miner": amount_to_value(subsidy),
    }))
}

fn rpc_createrawtransaction<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    const DEFAULT_TX_EXPIRY_DELTA: u32 = 20;

    if params.len() < 2 || params.len() > 4 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "createrawtransaction expects 2 to 4 parameters",
        ));
    }
    let inputs = params[0]
        .as_array()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "transactions must be a json array"))?;
    let outputs = params[1]
        .as_object()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "addresses must be a json object"))?;

    let next_height = chainstate
        .best_block()
        .map_err(map_internal)?
        .map(|tip| tip.height.saturating_add(1))
        .unwrap_or(1);
    let sapling_active = network_upgrade_active(
        next_height,
        &chain_params.consensus.upgrades,
        UpgradeIndex::Acadia,
    );

    let mut tx = Transaction {
        f_overwintered: sapling_active,
        version: if sapling_active { 4 } else { 1 },
        version_group_id: if sapling_active {
            SAPLING_VERSION_GROUP_ID
        } else {
            0
        },
        vin: Vec::new(),
        vout: Vec::new(),
        lock_time: 0,
        expiry_height: if sapling_active {
            (next_height as u32).saturating_add(DEFAULT_TX_EXPIRY_DELTA)
        } else {
            0
        },
        value_balance: 0,
        shielded_spends: Vec::new(),
        shielded_outputs: Vec::new(),
        join_splits: Vec::new(),
        join_split_pub_key: [0u8; 32],
        join_split_sig: [0u8; 64],
        binding_sig: [0u8; 64],
        fluxnode: None,
    };

    if params.len() > 2 && !params[2].is_null() {
        tx.lock_time = parse_u32(&params[2], "locktime")?;
    }
    if params.len() > 3 && !params[3].is_null() {
        if !sapling_active {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                "expiryheight can only be used if sapling is active when the transaction is mined",
            ));
        }
        let expiry_height = parse_u32(&params[3], "expiryheight")?;
        if expiry_height >= fluxd_consensus::constants::TX_EXPIRY_HEIGHT_THRESHOLD {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                "expiryheight too high",
            ));
        }
        if expiry_height != 0
            && (next_height as u32)
                .saturating_add(fluxd_consensus::constants::TX_EXPIRING_SOON_THRESHOLD)
                > expiry_height
        {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                "expiryheight too soon",
            ));
        }
        tx.expiry_height = expiry_height;
    }

    let default_sequence = if tx.lock_time != 0 {
        u32::MAX.saturating_sub(1)
    } else {
        u32::MAX
    };
    for input in inputs {
        let obj = input.as_object().ok_or_else(|| {
            RpcError::new(
                RPC_INVALID_PARAMETER,
                "transactions entries must be objects",
            )
        })?;
        let txid_value = obj
            .get("txid")
            .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "missing txid key"))?;
        let vout_value = obj
            .get("vout")
            .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "missing vout key"))?;
        let txid = parse_hash(txid_value)?;
        let vout = parse_u32(vout_value, "vout")?;

        let sequence = match obj.get("sequence") {
            Some(value) => parse_u32(value, "sequence")?,
            None => default_sequence,
        };

        tx.vin.push(TxIn {
            prevout: OutPoint {
                hash: txid,
                index: vout,
            },
            script_sig: Vec::new(),
            sequence,
        });
    }

    for (address, amount) in outputs {
        let script_pubkey =
            address_to_script_pubkey(address, chain_params.network).map_err(|err| match err {
                AddressError::InvalidLength
                | AddressError::InvalidCharacter
                | AddressError::InvalidChecksum
                | AddressError::UnknownPrefix => RpcError::new(
                    RPC_INVALID_ADDRESS_OR_KEY,
                    format!("Invalid Flux address: {address}"),
                ),
            })?;
        let value = parse_amount(amount)?;
        tx.vout.push(TxOut {
            value,
            script_pubkey,
        });
    }

    let encoded = tx.consensus_encode().map_err(map_internal)?;
    Ok(Value::String(hex_bytes(&encoded)))
}

fn rpc_decoderawtransaction(
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    if params.len() != 1 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "decoderawtransaction expects 1 parameter",
        ));
    }
    let hex = params[0]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "hexstring must be a string"))?;
    let raw = bytes_from_hex(hex)
        .ok_or_else(|| RpcError::new(RPC_DESERIALIZATION_ERROR, "TX decode failed"))?;
    let tx = Transaction::consensus_decode(&raw)
        .map_err(|_| RpcError::new(RPC_DESERIALIZATION_ERROR, "TX decode failed"))?;
    tx_to_json(&tx, chain_params.network)
}

fn rpc_decodescript(params: Vec<Value>, chain_params: &ChainParams) -> Result<Value, RpcError> {
    if params.len() != 1 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "decodescript expects 1 parameter",
        ));
    }
    let hex = params[0]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "hexstring must be a string"))?;
    let script = if hex.is_empty() {
        Vec::new()
    } else {
        bytes_from_hex(hex)
            .ok_or_else(|| RpcError::new(RPC_DESERIALIZATION_ERROR, "script decode failed"))?
    };

    let mut map = match script_pubkey_json(&script, chain_params.network) {
        Value::Object(map) => map,
        _ => return Err(RpcError::new(RPC_INTERNAL_ERROR, "invalid script json")),
    };
    map.insert(
        "p2sh".to_string(),
        Value::String(script_p2sh_address(&script, chain_params.network)),
    );
    Ok(Value::Object(map))
}

fn rpc_zcrawkeygen(params: Vec<Value>, chain_params: &ChainParams) -> Result<Value, RpcError> {
    ensure_no_params(&params)?;

    let key = fluxd_shielded::SproutSpendingKey::random();
    let address = key.address();
    let viewing_key = key.viewing_key();

    Ok(json!({
        "zcaddress": encode_sprout_payment_address(&address, chain_params.network),
        "zcsecretkey": encode_sprout_spending_key(key, chain_params.network),
        "zcviewingkey": encode_sprout_viewing_key(&viewing_key.a_pk, &viewing_key.sk_enc, chain_params.network),
    }))
}

fn rpc_zcrawreceive<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    if params.len() != 2 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "zcrawreceive expects 2 parameters",
        ));
    }

    let spending_key_str = params[0]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "zcsecretkey must be a string"))?;
    let spending_key = decode_sprout_spending_key(spending_key_str, chain_params.network)?;

    let encrypted_note_hex = params[1]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "encryptednote must be a string"))?;
    let encrypted_note = bytes_from_hex(encrypted_note_hex)
        .ok_or_else(|| RpcError::new(RPC_MISC_ERROR, "encrypted_note could not be decoded"))?;
    if encrypted_note.len() < fluxd_shielded::SPROUT_ENCRYPTED_NOTE_SIZE {
        return Err(RpcError::new(
            RPC_MISC_ERROR,
            "encrypted_note could not be decoded",
        ));
    }

    let encrypted_note: [u8; fluxd_shielded::SPROUT_ENCRYPTED_NOTE_SIZE] = encrypted_note
        [..fluxd_shielded::SPROUT_ENCRYPTED_NOTE_SIZE]
        .try_into()
        .expect("slice length checked");
    let encrypted_note = fluxd_shielded::SproutEncryptedNote::from_bytes(&encrypted_note)
        .map_err(|_| RpcError::new(RPC_MISC_ERROR, "encrypted_note could not be decoded"))?;

    let decryptor = fluxd_shielded::ZCNoteDecryption::new(spending_key.receiving_key());
    let plaintext = fluxd_shielded::SproutNotePlaintext::decrypt(
        &decryptor,
        &encrypted_note.ciphertext,
        &encrypted_note.epk,
        &encrypted_note.h_sig,
        encrypted_note.nonce,
    )
    .map_err(|err| RpcError::new(RPC_MISC_ERROR, err.to_string()))?;

    let note = plaintext.note(spending_key.address());
    let commitments = [note.cm()];
    let (witnesses, _) = chainstate
        .sprout_witness_paths(&commitments)
        .map_err(map_internal)?;
    let exists = witnesses
        .get(0)
        .map(|witness| witness.is_some())
        .unwrap_or(false);

    let plaintext_bytes = plaintext.to_bytes();
    let amount = i64::try_from(note.value).map_err(|_| {
        RpcError::new(
            RPC_INTERNAL_ERROR,
            "sprout note value out of range for json encoding",
        )
    })?;

    Ok(json!({
        "amount": amount_to_value(amount),
        "note": hex_bytes(&plaintext_bytes),
        "exists": exists,
    }))
}

fn rpc_zcrawjoinsplit<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    params: Vec<Value>,
    chain_params: &ChainParams,
    params_dir: &Path,
) -> Result<Value, RpcError> {
    if params.len() != 5 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "zcrawjoinsplit expects 5 parameters",
        ));
    }

    let tx_hex = params[0]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "rawtx must be a string"))?;
    let raw = bytes_from_hex(tx_hex)
        .ok_or_else(|| RpcError::new(RPC_DESERIALIZATION_ERROR, "TX decode failed"))?;
    let mut tx = Transaction::consensus_decode(&raw)
        .map_err(|_| RpcError::new(RPC_DESERIALIZATION_ERROR, "TX decode failed"))?;

    let inputs = params[1]
        .as_object()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "inputs must be an object"))?;
    let outputs = params[2]
        .as_object()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "outputs must be an object"))?;

    if inputs.len() > 2 || outputs.len() > 2 {
        return Err(RpcError::new(
            RPC_MISC_ERROR,
            "unsupported joinsplit input/output counts",
        ));
    }

    let vpub_old = u64::try_from(parse_amount(&params[3])?)
        .map_err(|_| RpcError::new(RPC_INVALID_PARAMETER, "nonsensical vpub_old value"))?;
    let vpub_new = u64::try_from(parse_amount(&params[4])?)
        .map_err(|_| RpcError::new(RPC_INVALID_PARAMETER, "nonsensical vpub_new value"))?;

    let mut input_keys = Vec::with_capacity(inputs.len());
    let mut input_notes = Vec::with_capacity(inputs.len());
    let mut commitments = Vec::with_capacity(inputs.len());
    for (note_hex, key_value) in inputs {
        let key_str = key_value
            .as_str()
            .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "zcsecretkey must be a string"))?;
        let key = decode_sprout_spending_key(key_str, chain_params.network)?;

        let note_bytes = bytes_from_hex(note_hex)
            .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "note could not be decoded"))?;
        if note_bytes.len() < fluxd_shielded::ZC_NOTEPLAINTEXT_SIZE {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                "note could not be decoded",
            ));
        }
        let note_bytes: [u8; fluxd_shielded::ZC_NOTEPLAINTEXT_SIZE] = note_bytes
            [..fluxd_shielded::ZC_NOTEPLAINTEXT_SIZE]
            .try_into()
            .expect("slice length checked");

        let plaintext = fluxd_shielded::SproutNotePlaintext::from_bytes(&note_bytes)
            .map_err(|_| RpcError::new(RPC_INVALID_PARAMETER, "note could not be decoded"))?;
        let note = plaintext.note(key.address());

        commitments.push(note.cm());
        input_keys.push(key);
        input_notes.push(note);
    }

    let (witnesses, anchor) = chainstate
        .sprout_witness_paths(&commitments)
        .map_err(map_internal)?;

    if witnesses.len() != commitments.len() {
        return Err(RpcError::new(
            RPC_INTERNAL_ERROR,
            "sprout witness lookup returned mismatched lengths",
        ));
    }

    let mut js_inputs = Vec::with_capacity(2);
    for i in 0..witnesses.len() {
        let Some(auth_path) = witnesses[i] else {
            return Err(RpcError::new(
                RPC_MISC_ERROR,
                "joinsplit input could not be found in tree",
            ));
        };
        js_inputs.push(fluxd_shielded::SproutJoinSplitInput {
            key: input_keys[i],
            note: input_notes[i],
            auth_path,
        });
    }
    while js_inputs.len() < 2 {
        js_inputs.push(fluxd_shielded::dummy_joinsplit_input());
    }
    if js_inputs.len() != 2 {
        return Err(RpcError::new(
            RPC_MISC_ERROR,
            "unsupported joinsplit input/output counts",
        ));
    }

    let mut js_outputs = Vec::with_capacity(2);
    for (addr_str, amount_value) in outputs {
        let addr = decode_sprout_joinsplit_address(addr_str, chain_params.network)?;
        let value = u64::try_from(parse_amount(amount_value)?)
            .map_err(|_| RpcError::new(RPC_INVALID_PARAMETER, "amount out of range"))?;
        let mut memo = [0u8; 512];
        memo[0] = 0xF6;
        js_outputs.push(fluxd_shielded::SproutJoinSplitOutput { addr, value, memo });
    }
    while js_outputs.len() < 2 {
        js_outputs.push(fluxd_shielded::SproutJoinSplitOutput::dummy());
    }
    if js_outputs.len() != 2 {
        return Err(RpcError::new(
            RPC_MISC_ERROR,
            "unsupported joinsplit input/output counts",
        ));
    }

    let js_inputs: [fluxd_shielded::SproutJoinSplitInput; 2] =
        js_inputs.try_into().expect("length checked");
    let js_outputs: [fluxd_shielded::SproutJoinSplitOutput; 2] =
        js_outputs.try_into().expect("length checked");

    let join_split_keypair = fluxd_shielded::JoinSplitKeypair::generate();
    let params_path = sprout_param_path(params_dir, chain_params.network)
        .map_err(|message| RpcError::new(RPC_WALLET_ERROR, message))?;
    let proving_key = fluxd_shielded::sprout_proving_key(&params_path)
        .map_err(|err| RpcError::new(RPC_WALLET_ERROR, err.to_string()))?;

    let result = fluxd_shielded::prove_joinsplit(
        proving_key.as_ref(),
        anchor,
        join_split_keypair.pubkey,
        js_inputs,
        js_outputs,
        vpub_old,
        vpub_new,
    )
    .map_err(|err| RpcError::new(RPC_MISC_ERROR, err.to_string()))?;

    tx.f_overwintered = true;
    tx.version = 4;
    tx.version_group_id = SAPLING_VERSION_GROUP_ID;
    tx.join_split_pub_key = join_split_keypair.pubkey;
    tx.join_splits.push(result.joinsplit);

    let next_height = chainstate
        .best_block()
        .map_err(map_internal)?
        .map(|block| block.height + 1)
        .unwrap_or(0);
    let branch_id = current_epoch_branch_id(next_height, &chain_params.consensus.upgrades);
    let sighash = signature_hash(&tx, None, &[], 0, SighashType(SIGHASH_ALL), branch_id)
        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "failed to compute joinsplit sighash"))?;
    tx.join_split_sig = join_split_keypair.sign(&sighash);

    let raw = tx
        .consensus_encode()
        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "failed to encode transaction"))?;
    let enc1 = result.encrypted_notes[0].to_bytes();
    let enc2 = result.encrypted_notes[1].to_bytes();

    Ok(json!({
        "encryptednote1": hex_bytes(&enc1),
        "encryptednote2": hex_bytes(&enc2),
        "rawtxn": hex_bytes(&raw),
    }))
}

fn rpc_zvalidateaddress(
    wallet: &Mutex<Wallet>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    if params.len() != 1 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "zvalidateaddress expects 1 parameter",
        ));
    }

    let address = params[0]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "zaddr must be a string"))?;

    if let Ok((payingkey, transmissionkey)) =
        decode_sprout_payment_address(address, chain_params.network)
    {
        return Ok(json!({
            "isvalid": true,
            "address": address,
            "type": "sprout",
            "ismine": false,
            "iswatchonly": false,
            "payingkey": hex_bytes(&payingkey),
            "transmissionkey": hex_bytes(&transmissionkey),
        }));
    }

    if let Some((diversifier, diversified_transmission_key)) =
        decode_sapling_payment_address(address, chain_params.network)
    {
        let addr_bytes = {
            let mut bytes = [0u8; 43];
            bytes[..11].copy_from_slice(&diversifier);
            bytes[11..].copy_from_slice(&diversified_transmission_key);
            bytes
        };
        let wallet_guard = wallet
            .lock()
            .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;
        let ismine = wallet_guard
            .sapling_address_is_mine(&addr_bytes)
            .unwrap_or(false);
        let iswatchonly = if ismine {
            false
        } else {
            wallet_guard
                .sapling_address_is_watchonly(&addr_bytes)
                .unwrap_or(false)
        };
        return Ok(json!({
            "isvalid": true,
            "address": address,
            "type": "sapling",
            "ismine": ismine,
            "iswatchonly": iswatchonly,
            "diversifier": hex_bytes(&diversifier),
            "diversifiedtransmissionkey": hex_bytes(&diversified_transmission_key),
        }));
    }

    Ok(json!({
        "isvalid": false,
    }))
}

fn rpc_zgetnewaddress<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    wallet: &Mutex<Wallet>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    if params.len() > 1 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "zgetnewaddress expects 0 or 1 parameters",
        ));
    }

    let addr_type = params.first().and_then(Value::as_str).unwrap_or("sapling");

    if addr_type != "sapling" {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "only sapling addresses are supported",
        ));
    }

    let bytes = {
        let mut guard = wallet
            .lock()
            .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;
        let had_sapling_keys = guard.has_sapling_keys();
        let bytes = guard
            .generate_new_sapling_address_bytes()
            .map_err(|_| RpcError::new(RPC_WALLET_ERROR, "failed to generate sapling address"))?;
        if !had_sapling_keys {
            guard
                .ensure_sapling_scan_initialized_to_tip(chainstate)
                .map_err(map_wallet_error)?;
        }
        bytes
    };

    let hrp = match chain_params.network {
        Network::Mainnet => "za",
        Network::Testnet => "ztestacadia",
        Network::Regtest => "zregtestsapling",
    };
    let hrp = Hrp::parse(hrp).map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "invalid hrp"))?;
    let encoded = bech32::encode::<Bech32>(hrp, bytes.as_slice())
        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "failed to encode sapling address"))?;
    Ok(Value::String(encoded))
}

fn parse_sapling_zaddr_bytes(
    address: &str,
    chain_params: &ChainParams,
) -> Result<[u8; 43], RpcError> {
    if decode_sprout_payment_address(address, chain_params.network).is_ok() {
        return Err(RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "Invalid zaddr"));
    }

    let Some((diversifier, diversified_transmission_key)) =
        decode_sapling_payment_address(address, chain_params.network)
    else {
        return Err(RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "Invalid zaddr"));
    };

    let mut addr_bytes = [0u8; 43];
    addr_bytes[..11].copy_from_slice(&diversifier);
    addr_bytes[11..].copy_from_slice(&diversified_transmission_key);
    Ok(addr_bytes)
}

fn new_opid() -> String {
    let mut bytes = [0u8; 16];
    rand::rngs::OsRng.fill_bytes(&mut bytes);
    let mut out = String::with_capacity(5 + 36);
    out.push_str("opid-");
    for (idx, byte) in bytes.iter().enumerate() {
        if matches!(idx, 4 | 6 | 8 | 10) {
            out.push('-');
        }
        out.push(hex_digit(byte >> 4));
        out.push(hex_digit(byte & 0x0f));
    }
    out
}

fn sapling_activation_height(chain_params: &ChainParams) -> BlockHeight {
    let raw = chain_params.consensus.upgrades[UpgradeIndex::Acadia.as_usize()].activation_height;
    let height = u32::try_from(raw.max(0)).unwrap_or(0);
    BlockHeight::from_u32(height)
}

#[derive(Clone)]
struct FluxZcashParams {
    network: Network,
    sapling_activation: BlockHeight,
}

impl Parameters for FluxZcashParams {
    fn network_type(&self) -> NetworkType {
        match self.network {
            Network::Mainnet => NetworkType::Main,
            Network::Testnet => NetworkType::Test,
            Network::Regtest => NetworkType::Regtest,
        }
    }

    fn activation_height(&self, nu: NetworkUpgrade) -> Option<BlockHeight> {
        match nu {
            NetworkUpgrade::Overwinter | NetworkUpgrade::Sapling => Some(self.sapling_activation),
            _ => None,
        }
    }
}

struct LocalTxProverState {
    network: Network,
    params_dir: PathBuf,
    prover: Arc<LocalTxProver>,
}

static LOCAL_TX_PROVER_STATE: OnceLock<Result<LocalTxProverState, String>> = OnceLock::new();

fn local_tx_prover(params_dir: &Path, network: Network) -> Result<Arc<LocalTxProver>, RpcError> {
    let state = LOCAL_TX_PROVER_STATE.get_or_init(|| {
        let params_dir = params_dir.to_path_buf();
        let (spend_path, output_path) = sapling_param_paths(&params_dir, network)?;
        let prover = std::panic::catch_unwind(|| LocalTxProver::new(&spend_path, &output_path))
            .map_err(|_| "failed to parse Sapling proving parameters".to_string())?;
        Ok(LocalTxProverState {
            network,
            params_dir,
            prover: Arc::new(prover),
        })
    });

    match state {
        Ok(state) => {
            if state.network != network || state.params_dir != params_dir {
                return Err(RpcError::new(
                    RPC_INTERNAL_ERROR,
                    "shielded prover initialized with different network/params-dir",
                ));
            }
            Ok(Arc::clone(&state.prover))
        }
        Err(err) => Err(RpcError::new(RPC_WALLET_ERROR, err.clone())),
    }
}

fn sapling_param_paths(params_dir: &Path, network: Network) -> Result<(PathBuf, PathBuf), String> {
    const SAPLING_SPEND: &str = "sapling-spend.params";
    const SAPLING_OUTPUT: &str = "sapling-output.params";
    const SAPLING_SPEND_TESTNET: &str = "sapling-spend-testnet.params";
    const SAPLING_OUTPUT_TESTNET: &str = "sapling-output-testnet.params";

    let (spend_primary, output_primary, spend_fallback, output_fallback) = match network {
        Network::Testnet => (
            SAPLING_SPEND_TESTNET,
            SAPLING_OUTPUT_TESTNET,
            Some(SAPLING_SPEND),
            Some(SAPLING_OUTPUT),
        ),
        _ => (SAPLING_SPEND, SAPLING_OUTPUT, None, None),
    };

    fn pick(params_dir: &Path, primary: &str, fallback: Option<&str>) -> Option<PathBuf> {
        let primary_path = params_dir.join(primary);
        if primary_path.exists() {
            return Some(primary_path);
        }
        let fallback = fallback?;
        let fallback_path = params_dir.join(fallback);
        fallback_path.exists().then_some(fallback_path)
    }

    let spend = pick(params_dir, spend_primary, spend_fallback).ok_or_else(|| {
        format!(
            "missing Sapling spend parameters ({spend_primary}) in {} (run with --fetch-params)",
            params_dir.display()
        )
    })?;
    let output = pick(params_dir, output_primary, output_fallback).ok_or_else(|| {
        format!(
            "missing Sapling output parameters ({output_primary}) in {} (run with --fetch-params)",
            params_dir.display()
        )
    })?;

    Ok((spend, output))
}

fn sprout_param_path(params_dir: &Path, network: Network) -> Result<PathBuf, String> {
    const SPROUT_GROTH16: &str = "sprout-groth16.params";
    const SPROUT_GROTH16_TESTNET: &str = "sprout-groth16-testnet.params";

    let (primary, fallback) = match network {
        Network::Testnet => (SPROUT_GROTH16_TESTNET, Some(SPROUT_GROTH16)),
        _ => (SPROUT_GROTH16, None),
    };

    let primary_path = params_dir.join(primary);
    if primary_path.exists() {
        return Ok(primary_path);
    }
    if let Some(fallback) = fallback {
        let fallback_path = params_dir.join(fallback);
        if fallback_path.exists() {
            return Ok(fallback_path);
        }
    }

    Err(format!(
        "missing Sprout Groth16 parameters ({primary}) in {} (run with --fetch-params)",
        params_dir.display()
    ))
}

struct SaplingOutputRef<'a> {
    output: &'a fluxd_primitives::transaction::OutputDescription,
}

impl ShieldedOutput<SaplingDomain, ENC_CIPHERTEXT_SIZE> for SaplingOutputRef<'_> {
    fn ephemeral_key(&self) -> EphemeralKeyBytes {
        EphemeralKeyBytes(self.output.ephemeral_key)
    }

    fn cmstar_bytes(
        &self,
    ) -> <SaplingDomain as zcash_note_encryption::Domain>::ExtractedCommitmentBytes {
        self.output.cm
    }

    fn enc_ciphertext(&self) -> &[u8; ENC_CIPHERTEXT_SIZE] {
        &self.output.enc_ciphertext
    }
}

fn transparent_address_from_flux_address(
    address: &str,
    network: Network,
) -> Result<TransparentAddress, RpcError> {
    let script_pubkey = address_to_script_pubkey(address, network)
        .map_err(|_| RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "invalid address"))?;
    if script_pubkey.len() == 25
        && script_pubkey[0] == 0x76
        && script_pubkey[1] == 0xa9
        && script_pubkey[2] == 0x14
        && script_pubkey[23] == 0x88
        && script_pubkey[24] == 0xac
    {
        let mut hash = [0u8; 20];
        hash.copy_from_slice(&script_pubkey[3..23]);
        return Ok(TransparentAddress::PublicKeyHash(hash));
    }
    if script_pubkey.len() == 23
        && script_pubkey[0] == 0xa9
        && script_pubkey[1] == 0x14
        && script_pubkey[22] == 0x87
    {
        let mut hash = [0u8; 20];
        hash.copy_from_slice(&script_pubkey[2..22]);
        return Ok(TransparentAddress::ScriptHash(hash));
    }
    Err(RpcError::new(
        RPC_INVALID_ADDRESS_OR_KEY,
        "unsupported transparent address script",
    ))
}

fn read_sapling_output_by_key<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    txid: &Hash256,
    out_index: u32,
) -> Result<fluxd_primitives::transaction::OutputDescription, RpcError> {
    let tx = read_transaction_by_id(chainstate, txid)?;
    let idx = usize::try_from(out_index)
        .map_err(|_| RpcError::new(RPC_INVALID_PARAMETER, "output index out of range"))?;
    tx.shielded_outputs
        .get(idx)
        .cloned()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "sapling output not found"))
}

fn read_transaction_by_id<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    txid: &Hash256,
) -> Result<Transaction, RpcError> {
    let location = chainstate
        .tx_location(txid)
        .map_err(map_internal)?
        .ok_or_else(|| RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "tx not found"))?;
    let bytes = chainstate
        .read_block(location.block)
        .map_err(map_internal)?;
    let block = Block::consensus_decode(&bytes)
        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "invalid block encoding"))?;
    let tx_index = usize::try_from(location.index)
        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "invalid tx location"))?;
    let tx = block
        .transactions
        .into_iter()
        .nth(tx_index)
        .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "missing transaction in block"))?;
    let actual_txid = tx
        .txid()
        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "invalid transaction encoding"))?;
    if &actual_txid != txid {
        return Err(RpcError::new(
            RPC_INTERNAL_ERROR,
            "tx index mismatch (reorg?)",
        ));
    }
    Ok(tx)
}

#[derive(Clone)]
enum ZSendDest {
    Transparent(TransparentAddress),
    Sapling([u8; 43], MemoBytes),
}

#[derive(Clone)]
struct ZSendRecipient {
    dest: ZSendDest,
    amount: i64,
}

fn parse_zsendmany_recipients(
    value: &Value,
    chain_params: &ChainParams,
) -> Result<Vec<ZSendRecipient>, RpcError> {
    let recipients = value
        .as_array()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "amounts must be an array"))?;
    if recipients.is_empty() {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "amounts array is empty",
        ));
    }

    let mut out = Vec::with_capacity(recipients.len());
    let mut seen_addresses = HashSet::new();
    for recipient in recipients {
        let obj = recipient.as_object().ok_or_else(|| {
            RpcError::new(RPC_INVALID_PARAMETER, "Invalid parameter, expected object")
        })?;
        for key in obj.keys() {
            if key != "address" && key != "amount" && key != "memo" {
                return Err(RpcError::new(
                    RPC_INVALID_PARAMETER,
                    format!("Invalid parameter, unknown key: {key}"),
                ));
            }
        }
        let address = obj
            .get("address")
            .and_then(Value::as_str)
            .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "missing address"))?;
        if !seen_addresses.insert(address.to_string()) {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                "Invalid parameter, duplicated address",
            ));
        }
        let amount_value = obj
            .get("amount")
            .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "missing amount"))?;
        let amount = parse_amount(amount_value)?;
        if amount <= 0 {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                "Invalid parameter, amount must be positive",
            ));
        }

        let memo = obj.get("memo");
        if address_to_script_pubkey(address, chain_params.network).is_ok() {
            if memo.is_some_and(|v| !v.is_null()) {
                return Err(RpcError::new(
                    RPC_INVALID_PARAMETER,
                    "memo is only supported for zaddrs",
                ));
            }
            let dest = transparent_address_from_flux_address(address, chain_params.network)?;
            out.push(ZSendRecipient {
                dest: ZSendDest::Transparent(dest),
                amount,
            });
            continue;
        }

        let sapling_bytes = parse_sapling_zaddr_bytes(address, chain_params)?;
        if PaymentAddress::from_bytes(&sapling_bytes).is_none() {
            return Err(RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "Invalid zaddr"));
        }

        let memo_bytes = match memo {
            None | Some(Value::Null) => MemoBytes::empty(),
            Some(Value::String(raw)) => {
                let bytes = bytes_from_hex(raw).ok_or_else(|| {
                    RpcError::new(RPC_INVALID_PARAMETER, "Memo must be in hexadecimal format")
                })?;
                MemoBytes::from_bytes(&bytes).map_err(|_| {
                    RpcError::new(
                        RPC_INVALID_PARAMETER,
                        "Memo size is larger than maximum allowed 512",
                    )
                })?
            }
            Some(_) => {
                return Err(RpcError::new(
                    RPC_INVALID_PARAMETER,
                    "memo must be a string",
                ))
            }
        };

        out.push(ZSendRecipient {
            dest: ZSendDest::Sapling(sapling_bytes, memo_bytes),
            amount,
        });
    }
    Ok(out)
}

fn zsendmany_execute<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    mempool: &Mutex<Mempool>,
    mempool_policy: &MempoolPolicy,
    mempool_metrics: &MempoolMetrics,
    fee_estimator: &Mutex<FeeEstimator>,
    mempool_flags: &ValidationFlags,
    chain_params: &ChainParams,
    params_dir: &Path,
    tx_announce: &broadcast::Sender<Hash256>,
    wallet: &Mutex<Wallet>,
    from_bytes: [u8; 43],
    recipients: &[ZSendRecipient],
    minconf: i32,
    fee: i64,
) -> Result<Hash256, RpcError> {
    let tip_height = chainstate
        .best_block()
        .map_err(map_internal)?
        .map(|tip| tip.height)
        .unwrap_or(0);
    let target_height_i32 = tip_height.saturating_add(1);
    if !network_upgrade_active(
        target_height_i32,
        &chain_params.consensus.upgrades,
        UpgradeIndex::Acadia,
    ) {
        return Err(RpcError::new(
            RPC_TRANSACTION_REJECTED,
            "sapling is not active",
        ));
    }

    let best_height = tip_height;
    let required_amount = recipients
        .iter()
        .try_fold(0i64, |acc, recipient| {
            acc.checked_add(recipient.amount)
                .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "value out of range"))
        })?
        .checked_add(fee)
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "value out of range"))?;

    #[derive(Clone)]
    struct Candidate {
        key: crate::wallet::SaplingNoteKey,
        note: crate::wallet::SaplingNoteRecord,
        witness: SaplingIncrementalWitness,
    }

    let (extsk_bytes, fvk, ivk, candidates): (
        [u8; 169],
        SaplingFullViewingKey,
        PreparedIncomingViewingKey,
        Vec<Candidate>,
    ) = {
        let mut guard = wallet
            .lock()
            .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;
        guard
            .sync_sapling_notes(chainstate)
            .map_err(map_wallet_error)?;
        let extsk_bytes = guard
            .sapling_extsk_for_address(&from_bytes)
            .map_err(map_wallet_error)?
            .ok_or_else(|| RpcError::new(RPC_WALLET_ERROR, "zaddr spending key not found"))?;

        let extsk = sapling_crypto::zip32::ExtendedSpendingKey::from_bytes(&extsk_bytes)
            .map_err(|_| RpcError::new(RPC_WALLET_ERROR, "invalid sapling spending key"))?;
        let dfvk = extsk.to_diversifiable_full_viewing_key();
        let fvk = dfvk.fvk().clone();
        let ivk = PreparedIncomingViewingKey::new(&fvk.vk.ivk());

        let mut out = Vec::new();
        for (&key, note) in guard.sapling_note_map() {
            if note.address != from_bytes {
                continue;
            }
            let confirmations = best_height.saturating_sub(note.height).saturating_add(1);
            if confirmations < minconf {
                continue;
            }
            if chainstate
                .sapling_nullifier_spent(&note.nullifier)
                .map_err(map_internal)?
            {
                continue;
            }
            let witness = guard
                .sapling_witness_map()
                .get(&key)
                .cloned()
                .ok_or_else(|| RpcError::new(RPC_WALLET_ERROR, "missing sapling witness"))?;
            out.push(Candidate {
                key,
                note: note.clone(),
                witness,
            });
        }
        (extsk_bytes, fvk, ivk, out)
    };

    let mut available: Vec<Candidate> = Vec::new();
    {
        let guard = mempool
            .lock()
            .map_err(|_| map_internal("mempool lock poisoned"))?;
        for candidate in candidates {
            if guard
                .sapling_nullifier_spender(&candidate.note.nullifier)
                .is_some()
            {
                continue;
            }
            available.push(candidate);
        }
    }

    available.sort_by(|a, b| {
        b.note
            .value
            .cmp(&a.note.value)
            .then_with(|| a.note.height.cmp(&b.note.height))
            .then_with(|| a.key.0.cmp(&b.key.0))
            .then_with(|| a.key.1.cmp(&b.key.1))
    });

    let mut selected: Vec<Candidate> = Vec::new();
    let mut selected_value: i64 = 0;
    for candidate in available {
        selected_value = selected_value
            .checked_add(candidate.note.value)
            .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "value out of range"))?;
        selected.push(candidate);
        if selected_value >= required_amount {
            break;
        }
    }
    if selected_value < required_amount {
        return Err(RpcError::new(RPC_WALLET_ERROR, "insufficient funds"));
    }

    let change = selected_value
        .checked_sub(required_amount)
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "value out of range"))?;

    let anchor = selected
        .first()
        .ok_or_else(|| RpcError::new(RPC_WALLET_ERROR, "no notes to spend"))?
        .witness
        .root()
        .into();

    let sapling_activation = sapling_activation_height(chain_params);
    let params = FluxZcashParams {
        network: chain_params.network,
        sapling_activation,
    };
    let target_height = BlockHeight::from_u32(u32::try_from(target_height_i32).unwrap_or(0));
    let build_config = BuildConfig::Standard {
        sapling_anchor: Some(anchor),
        orchard_anchor: None,
    };
    let mut builder = ZcashTxBuilder::new(params, target_height, build_config);

    for candidate in &selected {
        let cached_note = candidate
            .note
            .rseed
            .and_then(|rseed| rseed.to_rseed())
            .and_then(|rseed| {
                let recipient = PaymentAddress::from_bytes(&candidate.note.address)?;
                let value_u64 = u64::try_from(candidate.note.value).ok()?;
                let note_value = sapling_crypto::value::NoteValue::from_raw(value_u64);
                Some(recipient.create_note(note_value, rseed))
            });

        let (note, rseed_backfill) = if let Some(note) = cached_note {
            (note, None)
        } else {
            let output = read_sapling_output_by_key(chainstate, &candidate.key.0, candidate.key.1)?;
            let output_ref = SaplingOutputRef { output: &output };
            let (note, recipient, _memo) =
                try_sapling_note_decryption(&ivk, &output_ref, Zip212Enforcement::GracePeriod)
                    .ok_or_else(|| {
                        RpcError::new(RPC_WALLET_ERROR, "failed to decrypt sapling note")
                    })?;
            if recipient.to_bytes() != candidate.note.address {
                return Err(RpcError::new(
                    RPC_WALLET_ERROR,
                    "sapling note recipient mismatch",
                ));
            }
            let rseed = crate::wallet::SaplingRseedBytes::from_rseed(note.rseed());
            (note, Some(rseed))
        };

        if candidate.note.rseed.is_none() {
            if let Some(rseed) = rseed_backfill {
                if let Ok(mut guard) = wallet.lock() {
                    let _ = guard.backfill_sapling_note_rseed(candidate.key, rseed);
                }
            }
        }

        let witness_path: SaplingMerklePath = candidate
            .witness
            .path()
            .ok_or_else(|| RpcError::new(RPC_WALLET_ERROR, "invalid sapling witness"))?;
        builder
            .add_sapling_spend::<core::convert::Infallible>(fvk.clone(), note, witness_path)
            .map_err(|err| RpcError::new(RPC_TRANSACTION_REJECTED, err.to_string()))?;
    }

    let extsk = sapling_crypto::zip32::ExtendedSpendingKey::from_bytes(&extsk_bytes)
        .map_err(|_| RpcError::new(RPC_WALLET_ERROR, "invalid sapling spending key"))?;
    let ovk = Some(extsk.expsk.ovk);

    for recipient in recipients {
        let amount_u64 = u64::try_from(recipient.amount)
            .map_err(|_| RpcError::new(RPC_INVALID_PARAMETER, "amount out of range"))?;
        let value = Zatoshis::from_u64(amount_u64)
            .map_err(|_| RpcError::new(RPC_INVALID_PARAMETER, "amount out of range"))?;
        match &recipient.dest {
            ZSendDest::Transparent(addr) => builder
                .add_transparent_output(addr, value)
                .map_err(|err| RpcError::new(RPC_TRANSACTION_REJECTED, err.to_string()))?,
            ZSendDest::Sapling(addr_bytes, memo) => {
                let addr = PaymentAddress::from_bytes(addr_bytes)
                    .ok_or_else(|| RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "Invalid zaddr"))?;
                builder
                    .add_sapling_output::<core::convert::Infallible>(ovk, addr, value, memo.clone())
                    .map_err(|err| RpcError::new(RPC_TRANSACTION_REJECTED, err.to_string()))?
            }
        }
    }

    if change > 0 {
        let change_u64 = u64::try_from(change)
            .map_err(|_| RpcError::new(RPC_INVALID_PARAMETER, "amount out of range"))?;
        let change_value = Zatoshis::from_u64(change_u64)
            .map_err(|_| RpcError::new(RPC_INVALID_PARAMETER, "amount out of range"))?;
        let to = PaymentAddress::from_bytes(&from_bytes)
            .ok_or_else(|| RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "Invalid zaddr"))?;
        builder
            .add_sapling_output::<core::convert::Infallible>(
                ovk,
                to,
                change_value,
                MemoBytes::empty(),
            )
            .map_err(|err| RpcError::new(RPC_TRANSACTION_REJECTED, err.to_string()))?;
    }

    let prover = local_tx_prover(params_dir, chain_params.network)?;
    let fee_u64 =
        u64::try_from(fee).map_err(|_| RpcError::new(RPC_INVALID_PARAMETER, "fee out of range"))?;
    let fee_value = Zatoshis::from_u64(fee_u64)
        .map_err(|_| RpcError::new(RPC_INVALID_PARAMETER, "fee out of range"))?;
    let fee_rule = zcash_primitives::transaction::fees::fixed::FeeRule::non_standard(fee_value);
    let transparent_signing_set = transparent::builder::TransparentSigningSet::new();
    let sapling_extsks = [extsk];
    let build = builder
        .build(
            &transparent_signing_set,
            &sapling_extsks,
            &[],
            rand::rngs::OsRng,
            prover.as_ref(),
            prover.as_ref(),
            &fee_rule,
        )
        .map_err(|err| RpcError::new(RPC_TRANSACTION_REJECTED, err.to_string()))?;

    let ztx = build.transaction();
    let mut raw = Vec::new();
    ztx.write(&mut raw)
        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "tx encode failed"))?;

    let txid = submit_raw_transaction(
        chainstate,
        mempool,
        mempool_policy,
        mempool_metrics,
        fee_estimator,
        mempool_flags,
        chain_params,
        tx_announce,
        true,
        raw,
    )?;

    mempool_metrics.note_rpc_accept();

    if let Ok(mut guard) = wallet.lock() {
        let _ = guard.record_txids([txid]);
    }

    Ok(txid)
}

fn rpc_zsendmany<S: fluxd_storage::KeyValueStore + 'static>(
    ctx: &RpcContext<S>,
    params: Vec<Value>,
) -> Result<Value, RpcError> {
    if params.len() < 2 || params.len() > 4 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "zsendmany expects 2 to 4 parameters",
        ));
    }

    let from_address = params[0]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "fromaddress must be a string"))?;
    let recipients_value = params[1].clone();
    let minconf = match params.get(2) {
        Some(value) if !value.is_null() => parse_u32(value, "minconf")? as i32,
        _ => 1,
    };
    if minconf <= 0 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "minconf must be greater than zero when sending from zaddr",
        ));
    }
    let fee = match params.get(3) {
        Some(value) if !value.is_null() => parse_amount(value)?,
        _ => 10_000, // 0.0001 FLUX
    };

    let recipients = parse_zsendmany_recipients(&recipients_value, &ctx.chain_params)?;

    let from_bytes = parse_sapling_zaddr_bytes(from_address, &ctx.chain_params)?;
    {
        let guard = ctx
            .wallet
            .lock()
            .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;
        let spendable = guard
            .sapling_extsk_for_address(&from_bytes)
            .map_err(map_wallet_error)?
            .is_some();
        if !spendable {
            return Err(RpcError::new(
                RPC_WALLET_ERROR,
                "From address does not belong to this node, zaddr spending key not found.",
            ));
        }
    }

    let opid = new_opid();
    let op_params = json!({
        "fromaddress": from_address,
        "amounts": recipients_value,
        "minconf": minconf,
        "fee": amount_to_value(fee),
    });
    {
        let mut guard = async_ops()
            .lock()
            .map_err(|_| map_internal("operation manager lock poisoned"))?;
        guard.insert(AsyncOpEntry {
            operationid: opid.clone(),
            status: AsyncOpState::Queued,
            method: "z_sendmany".to_string(),
            params: op_params,
            creation_time: current_unix_seconds_u64(),
            started_time: None,
            finished_time: None,
            result: None,
            error: None,
        });
    }

    let opid_task = opid.clone();
    let chainstate = Arc::clone(&ctx.chainstate);
    let mempool = Arc::clone(&ctx.mempool);
    let mempool_policy = Arc::clone(&ctx.mempool_policy);
    let mempool_metrics = Arc::clone(&ctx.mempool_metrics);
    let fee_estimator = Arc::clone(&ctx.fee_estimator);
    let mempool_flags = ctx.mempool_flags.clone();
    let chain_params = ctx.chain_params.clone();
    let params_dir = ctx.params_dir.clone();
    let tx_announce = ctx.tx_announce.clone();
    let wallet = Arc::clone(&ctx.wallet);

    tokio::task::spawn_blocking(move || {
        {
            if let Ok(mut ops) = async_ops().lock() {
                ops.update_status(&opid_task, AsyncOpState::Executing);
            }
        }

        let outcome: Result<String, RpcError> = (|| {
            let txid = zsendmany_execute(
                chainstate.as_ref(),
                mempool.as_ref(),
                mempool_policy.as_ref(),
                mempool_metrics.as_ref(),
                fee_estimator.as_ref(),
                &mempool_flags,
                &chain_params,
                &params_dir,
                &tx_announce,
                wallet.as_ref(),
                from_bytes,
                &recipients,
                minconf,
                fee,
            )?;
            Ok(hash256_to_hex(&txid))
        })();

        match outcome {
            Ok(txid_hex) => {
                if let Ok(mut ops) = async_ops().lock() {
                    ops.set_result(&opid_task, json!({ "txid": txid_hex }));
                    ops.update_status(&opid_task, AsyncOpState::Success);
                }
            }
            Err(err) => {
                mempool_metrics.note_rpc_reject();
                if let Ok(mut ops) = async_ops().lock() {
                    ops.set_error(&opid_task, err.code, err.message);
                    ops.update_status(&opid_task, AsyncOpState::Failed);
                }
            }
        }
    });

    Ok(Value::String(opid))
}

fn rpc_zgetbalance<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    mempool: &Mutex<Mempool>,
    wallet: &Mutex<Wallet>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    if params.is_empty() || params.len() > 3 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "zgetbalance expects 1 to 3 parameters",
        ));
    }

    let address = params[0]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "zaddr must be a string"))?;
    let minconf = match params.get(1) {
        Some(value) if !value.is_null() => {
            let raw = parse_i64(value, "minconf")?;
            if raw < 0 {
                return Err(RpcError::new(
                    RPC_INVALID_PARAMETER,
                    "Minimum number of confirmations cannot be less than 0",
                ));
            }
            i32::try_from(raw)
                .map_err(|_| RpcError::new(RPC_INVALID_PARAMETER, "minconf too large"))?
        }
        _ => 1,
    };
    let include_watchonly = match params.get(2) {
        Some(Value::Bool(value)) => *value,
        Some(Value::Null) | None => true,
        Some(_) => {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                "includeWatchonly must be a boolean",
            ));
        }
    };

    if let Ok(script_pubkey) = address_to_script_pubkey(address, chain_params.network) {
        let (scripts, locked_outpoints) = {
            let guard = wallet
                .lock()
                .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;
            let scripts = if include_watchonly {
                guard
                    .all_script_pubkeys_including_watchonly()
                    .map_err(map_wallet_error)?
            } else {
                guard.all_script_pubkeys().map_err(map_wallet_error)?
            };
            (scripts, guard.locked_outpoints())
        };

        if !scripts
            .iter()
            .any(|spk| spk.as_slice() == script_pubkey.as_slice())
        {
            return Ok(amount_to_value(0));
        }

        let locked_set: HashSet<OutPoint> = locked_outpoints.into_iter().collect();
        let include_mempool_outputs = minconf == 0;
        let utxos = collect_wallet_utxos(
            chainstate,
            mempool,
            &[script_pubkey],
            include_mempool_outputs,
        )?;

        let mut total = 0i64;
        for utxo in utxos {
            if utxo.confirmations < minconf {
                continue;
            }
            if utxo.is_coinbase && utxo.confirmations < COINBASE_MATURITY {
                continue;
            }
            if locked_set.contains(&utxo.outpoint) {
                continue;
            }
            total = total
                .checked_add(utxo.value)
                .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "balance overflow"))?;
        }
        return Ok(amount_to_value(total));
    }

    let addr_bytes = parse_sapling_zaddr_bytes(address, chain_params)?;
    let notes = {
        let mut guard = wallet
            .lock()
            .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;
        guard
            .sync_sapling_notes(chainstate)
            .map_err(map_wallet_error)?;

        let is_mine = guard
            .sapling_address_is_mine(&addr_bytes)
            .map_err(map_wallet_error)?;
        let is_watchonly = guard
            .sapling_address_is_watchonly(&addr_bytes)
            .map_err(map_wallet_error)?;
        if !is_mine && !is_watchonly {
            return Err(RpcError::new(
                RPC_INVALID_ADDRESS_OR_KEY,
                "From address does not belong to this node, spending key or viewing key not found.",
            ));
        }
        if !is_mine && !include_watchonly {
            return Err(RpcError::new(
                RPC_WALLET_ERROR,
                "Wallet does not hold private key for this zaddr",
            ));
        }

        guard
            .sapling_note_map()
            .values()
            .filter(|note| note.address == addr_bytes)
            .cloned()
            .collect::<Vec<_>>()
    };

    let best_height = chainstate
        .best_block()
        .map_err(map_internal)?
        .map(|tip| tip.height)
        .unwrap_or(0);

    let mut total = 0i64;
    for note in notes {
        let confirmations = best_height.saturating_sub(note.height).saturating_add(1);
        if confirmations < minconf {
            continue;
        }
        if chainstate
            .sapling_nullifier_spent(&note.nullifier)
            .map_err(map_internal)?
        {
            continue;
        }
        if mempool
            .lock()
            .map_err(|_| map_internal("mempool lock poisoned"))?
            .sapling_nullifier_spender(&note.nullifier)
            .is_some()
        {
            continue;
        }
        total = total
            .checked_add(note.value)
            .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "balance overflow"))?;
    }

    Ok(amount_to_value(total))
}

fn rpc_zgettotalbalance<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    mempool: &Mutex<Mempool>,
    wallet: &Mutex<Wallet>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    if params.len() > 2 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "zgettotalbalance expects 0 to 2 parameters",
        ));
    }

    let minconf = match params.get(0) {
        Some(value) if !value.is_null() => parse_u32(value, "minconf")? as i32,
        _ => 1,
    };
    let include_watchonly = match params.get(1) {
        Some(Value::Bool(value)) => *value,
        Some(Value::Null) | None => false,
        Some(_) => {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                "includeWatchonly must be a boolean",
            ));
        }
    };

    let (scripts, locked_outpoints, notes) = {
        let mut guard = wallet
            .lock()
            .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;
        guard
            .sync_sapling_notes(chainstate)
            .map_err(map_wallet_error)?;

        let scripts = if include_watchonly {
            guard
                .all_script_pubkeys_including_watchonly()
                .map_err(map_wallet_error)?
        } else {
            guard.all_script_pubkeys().map_err(map_wallet_error)?
        };
        let locked_outpoints = guard.locked_outpoints();

        let mut notes = Vec::new();
        for note in guard.sapling_note_map().values() {
            if !include_watchonly {
                let is_mine = guard
                    .sapling_address_is_mine(&note.address)
                    .map_err(map_wallet_error)?;
                if !is_mine {
                    continue;
                }
            }
            notes.push(note.clone());
        }

        (scripts, locked_outpoints, notes)
    };

    let locked_set: HashSet<OutPoint> = locked_outpoints.into_iter().collect();
    let include_mempool_outputs = minconf == 0;
    let utxos = collect_wallet_utxos(chainstate, mempool, &scripts, include_mempool_outputs)?;
    let mut transparent_total = 0i64;
    for utxo in utxos {
        if utxo.confirmations < minconf {
            continue;
        }
        if utxo.is_coinbase && utxo.confirmations < COINBASE_MATURITY {
            continue;
        }
        if locked_set.contains(&utxo.outpoint) {
            continue;
        }
        transparent_total = transparent_total
            .checked_add(utxo.value)
            .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "balance overflow"))?;
    }

    let best_height = chainstate
        .best_block()
        .map_err(map_internal)?
        .map(|tip| tip.height)
        .unwrap_or(0);
    let mut shielded_total = 0i64;
    for note in notes {
        let confirmations = best_height.saturating_sub(note.height).saturating_add(1);
        if confirmations < minconf {
            continue;
        }
        if chainstate
            .sapling_nullifier_spent(&note.nullifier)
            .map_err(map_internal)?
        {
            continue;
        }
        if mempool
            .lock()
            .map_err(|_| map_internal("mempool lock poisoned"))?
            .sapling_nullifier_spender(&note.nullifier)
            .is_some()
        {
            continue;
        }
        shielded_total = shielded_total
            .checked_add(note.value)
            .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "balance overflow"))?;
    }

    let total = transparent_total
        .checked_add(shielded_total)
        .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "balance overflow"))?;

    let _ = chain_params;
    Ok(json!({
        "transparent": amount_to_value(transparent_total),
        "private": amount_to_value(shielded_total),
        "total": amount_to_value(total),
    }))
}

fn rpc_zlistunspent<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    mempool: &Mutex<Mempool>,
    wallet: &Mutex<Wallet>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    if params.len() > 4 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "zlistunspent expects 0 to 4 parameters",
        ));
    }

    let minconf = match params.get(0) {
        Some(value) if !value.is_null() => parse_u32(value, "minconf")? as i32,
        _ => 1,
    };
    let maxconf = match params.get(1) {
        Some(value) if !value.is_null() => parse_u32(value, "maxconf")? as i32,
        _ => i32::MAX,
    };
    if maxconf < minconf {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "maxconf must be >= minconf",
        ));
    }
    let include_watchonly = match params.get(2) {
        Some(Value::Bool(value)) => *value,
        Some(Value::Null) | None => false,
        Some(_) => {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                "includeWatchonly must be a boolean",
            ));
        }
    };
    let filter_addresses: HashSet<[u8; 43]> = match params.get(3) {
        Some(Value::Array(values)) => {
            if values.is_empty() {
                return Err(RpcError::new(
                    RPC_INVALID_PARAMETER,
                    "addresses array is empty",
                ));
            }
            let mut out = HashSet::new();
            for value in values {
                let addr = value.as_str().ok_or_else(|| {
                    RpcError::new(RPC_INVALID_PARAMETER, "addresses must be strings")
                })?;
                let bytes = parse_sapling_zaddr_bytes(addr, chain_params)?;
                if !out.insert(bytes) {
                    return Err(RpcError::new(RPC_INVALID_PARAMETER, "duplicated address"));
                }
            }
            out
        }
        Some(Value::Null) | None => HashSet::new(),
        Some(_) => {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                "addresses must be an array",
            ));
        }
    };

    #[derive(Clone)]
    struct NoteRow {
        txid: Hash256,
        out_index: u32,
        note: crate::wallet::SaplingNoteRecord,
        spendable: bool,
    }

    let (notes, ivk_by_address, nullifier_set): (
        Vec<NoteRow>,
        HashMap<[u8; 43], PreparedIncomingViewingKey>,
        HashSet<([u8; 43], [u8; 32])>,
    ) = {
        let mut guard = wallet
            .lock()
            .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;
        guard
            .sync_sapling_notes(chainstate)
            .map_err(map_wallet_error)?;

        let mut out = Vec::new();
        let mut address_set = HashSet::new();

        if !include_watchonly && !filter_addresses.is_empty() {
            for address in &filter_addresses {
                let is_mine = guard
                    .sapling_address_is_mine(address)
                    .map_err(map_wallet_error)?;
                if !is_mine {
                    return Err(RpcError::new(
                        RPC_INVALID_PARAMETER,
                        "spending key for address does not belong to wallet",
                    ));
                }
            }
        }

        for (&(txid, out_index), note) in guard.sapling_note_map() {
            if !filter_addresses.is_empty() && !filter_addresses.contains(&note.address) {
                continue;
            }
            let is_mine = guard
                .sapling_address_is_mine(&note.address)
                .map_err(map_wallet_error)?;
            if !include_watchonly && !is_mine {
                continue;
            }
            let spendable = is_mine;
            address_set.insert(note.address);
            out.push(NoteRow {
                txid,
                out_index,
                note: note.clone(),
                spendable,
            });
        }

        let mut extfvk_to_addresses: HashMap<[u8; 169], Vec<[u8; 43]>> = HashMap::new();
        let mut ivk_by_address: HashMap<[u8; 43], PreparedIncomingViewingKey> = HashMap::new();
        for address in &address_set {
            let extfvk_bytes = guard
                .sapling_extfvk_for_address(address)
                .map_err(map_wallet_error)?
                .ok_or_else(|| RpcError::new(RPC_WALLET_ERROR, "missing Sapling viewing key"))?;
            extfvk_to_addresses
                .entry(extfvk_bytes)
                .or_default()
                .push(*address);

            let extfvk =
                sapling_crypto::zip32::ExtendedFullViewingKey::read(extfvk_bytes.as_slice())
                    .map_err(|_| RpcError::new(RPC_WALLET_ERROR, "invalid Sapling viewing key"))?;
            ivk_by_address.insert(
                *address,
                PreparedIncomingViewingKey::new(&extfvk.fvk.vk.ivk()),
            );
        }

        let mut nullifier_set: HashSet<([u8; 43], [u8; 32])> = HashSet::new();
        let mut extfvk_cache: HashMap<[u8; 43], [u8; 169]> = HashMap::new();
        for (_key, note) in guard.sapling_note_map().iter() {
            let extfvk = match extfvk_cache.get(&note.address) {
                Some(bytes) => *bytes,
                None => {
                    let Some(bytes) = guard
                        .sapling_extfvk_for_address(&note.address)
                        .map_err(map_wallet_error)?
                    else {
                        continue;
                    };
                    extfvk_cache.insert(note.address, bytes);
                    bytes
                }
            };

            let Some(addresses) = extfvk_to_addresses.get(&extfvk) else {
                continue;
            };
            for address in addresses {
                nullifier_set.insert((*address, note.nullifier));
            }
        }

        (out, ivk_by_address, nullifier_set)
    };

    let best_height = chainstate
        .best_block()
        .map_err(map_internal)?
        .map(|tip| tip.height)
        .unwrap_or(0);

    let hrp = match chain_params.network {
        Network::Mainnet => "za",
        Network::Testnet => "ztestacadia",
        Network::Regtest => "zregtestsapling",
    };
    let hrp = Hrp::parse(hrp).map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "invalid hrp"))?;

    let mempool_guard = mempool
        .lock()
        .map_err(|_| map_internal("mempool lock poisoned"))?;
    let mut tx_cache: HashMap<Hash256, Transaction> = HashMap::new();
    let mut out = Vec::new();
    for row in notes {
        let confirmations = best_height
            .saturating_sub(row.note.height)
            .saturating_add(1);
        if confirmations < minconf || confirmations > maxconf {
            continue;
        }
        if chainstate
            .sapling_nullifier_spent(&row.note.nullifier)
            .map_err(map_internal)?
        {
            continue;
        }
        if mempool_guard
            .sapling_nullifier_spender(&row.note.nullifier)
            .is_some()
        {
            continue;
        }

        let address = bech32::encode::<Bech32>(hrp, row.note.address.as_slice())
            .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "failed to encode sapling address"))?;

        let ivk = ivk_by_address.get(&row.note.address).ok_or_else(|| {
            RpcError::new(
                RPC_WALLET_ERROR,
                "missing Sapling incoming viewing key for note address",
            )
        })?;

        let tx = match tx_cache.entry(row.txid) {
            std::collections::hash_map::Entry::Occupied(entry) => entry.into_mut(),
            std::collections::hash_map::Entry::Vacant(entry) => {
                entry.insert(read_transaction_by_id(chainstate, &row.txid)?)
            }
        };
        let idx = usize::try_from(row.out_index)
            .map_err(|_| RpcError::new(RPC_INVALID_PARAMETER, "output index out of range"))?;
        let output = tx
            .shielded_outputs
            .get(idx)
            .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "sapling output not found"))?;
        let output_ref = SaplingOutputRef { output };
        let (_note, recipient, memo) =
            try_sapling_note_decryption(ivk, &output_ref, Zip212Enforcement::GracePeriod)
                .ok_or_else(|| RpcError::new(RPC_WALLET_ERROR, "failed to decrypt Sapling note"))?;
        if recipient.to_bytes() != row.note.address {
            return Err(RpcError::new(
                RPC_INTERNAL_ERROR,
                "sapling note recipient mismatch",
            ));
        }
        let memo = hex_bytes(&memo);

        if row.spendable {
            let change = tx
                .shielded_spends
                .iter()
                .any(|spend| nullifier_set.contains(&(row.note.address, spend.nullifier)));
            out.push(json!({
                "txid": hash256_to_hex(&row.txid),
                "outindex": row.out_index,
                "address": address,
                "amount": amount_to_value(row.note.value),
                "amountZat": row.note.value,
                "memo": memo,
                "confirmations": confirmations,
                "spendable": row.spendable,
                "change": change,
            }));
        } else {
            out.push(json!({
                "txid": hash256_to_hex(&row.txid),
                "outindex": row.out_index,
                "address": address,
                "amount": amount_to_value(row.note.value),
                "amountZat": row.note.value,
                "memo": memo,
                "confirmations": confirmations,
                "spendable": row.spendable,
            }));
        }
    }

    Ok(Value::Array(out))
}

fn rpc_zlistreceivedbyaddress<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    wallet: &Mutex<Wallet>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    if params.is_empty() || params.len() > 2 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "zlistreceivedbyaddress expects 1 to 2 parameters",
        ));
    }

    let address = params[0]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "zaddr must be a string"))?;
    let minconf = match params.get(1) {
        Some(value) if !value.is_null() => parse_u32(value, "minconf")? as i32,
        _ => 1,
    };
    let addr_bytes = parse_sapling_zaddr_bytes(address, chain_params)?;

    #[derive(Clone)]
    struct NoteRow {
        txid: Hash256,
        out_index: u32,
        note: crate::wallet::SaplingNoteRecord,
        spendable: bool,
    }

    let (notes, ivk, nullifier_set): (
        Vec<NoteRow>,
        PreparedIncomingViewingKey,
        HashSet<([u8; 43], [u8; 32])>,
    ) = {
        let mut guard = wallet
            .lock()
            .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;
        guard
            .sync_sapling_notes(chainstate)
            .map_err(map_wallet_error)?;

        let is_mine = guard
            .sapling_address_is_mine(&addr_bytes)
            .map_err(map_wallet_error)?;
        let is_watchonly = guard
            .sapling_address_is_watchonly(&addr_bytes)
            .map_err(map_wallet_error)?;
        if !is_mine && !is_watchonly {
            return Err(RpcError::new(
                RPC_WALLET_ERROR,
                "Wallet does not hold private key or viewing key for this zaddr",
            ));
        }

        let spendable = is_mine;

        let extfvk_bytes = guard
            .sapling_extfvk_for_address(&addr_bytes)
            .map_err(map_wallet_error)?
            .ok_or_else(|| RpcError::new(RPC_WALLET_ERROR, "missing Sapling viewing key"))?;
        let extfvk = sapling_crypto::zip32::ExtendedFullViewingKey::read(extfvk_bytes.as_slice())
            .map_err(|_| RpcError::new(RPC_WALLET_ERROR, "invalid Sapling viewing key"))?;
        let ivk = PreparedIncomingViewingKey::new(&extfvk.fvk.vk.ivk());

        let notes = guard
            .sapling_note_map()
            .iter()
            .filter_map(|(&(txid, out_index), note)| {
                if note.address != addr_bytes {
                    return None;
                }
                Some(NoteRow {
                    txid,
                    out_index,
                    note: note.clone(),
                    spendable,
                })
            })
            .collect::<Vec<_>>();

        let mut nullifier_set = HashSet::new();
        if spendable {
            let mut extfvk_cache: HashMap<[u8; 43], [u8; 169]> = HashMap::new();
            for (_key, note) in guard.sapling_note_map().iter() {
                let extfvk = match extfvk_cache.get(&note.address) {
                    Some(bytes) => *bytes,
                    None => {
                        let Some(bytes) = guard
                            .sapling_extfvk_for_address(&note.address)
                            .map_err(map_wallet_error)?
                        else {
                            continue;
                        };
                        extfvk_cache.insert(note.address, bytes);
                        bytes
                    }
                };
                if extfvk != extfvk_bytes {
                    continue;
                }
                nullifier_set.insert((addr_bytes, note.nullifier));
            }
        }

        (notes, ivk, nullifier_set)
    };

    let best_height = chainstate
        .best_block()
        .map_err(map_internal)?
        .map(|tip| tip.height)
        .unwrap_or(0);

    let mut tx_cache: HashMap<Hash256, Transaction> = HashMap::new();
    let mut out = Vec::new();
    for row in notes {
        let confirmations = best_height
            .saturating_sub(row.note.height)
            .saturating_add(1);
        if confirmations < minconf {
            continue;
        }

        let spent = chainstate
            .sapling_nullifier_spent(&row.note.nullifier)
            .map_err(map_internal)?;

        let tx = match tx_cache.entry(row.txid) {
            std::collections::hash_map::Entry::Occupied(entry) => entry.into_mut(),
            std::collections::hash_map::Entry::Vacant(entry) => {
                entry.insert(read_transaction_by_id(chainstate, &row.txid)?)
            }
        };
        let idx = usize::try_from(row.out_index)
            .map_err(|_| RpcError::new(RPC_INVALID_PARAMETER, "output index out of range"))?;
        let output = tx
            .shielded_outputs
            .get(idx)
            .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "sapling output not found"))?;
        let output_ref = SaplingOutputRef { output };
        let (_note, recipient, memo) =
            try_sapling_note_decryption(&ivk, &output_ref, Zip212Enforcement::GracePeriod)
                .ok_or_else(|| RpcError::new(RPC_WALLET_ERROR, "failed to decrypt Sapling note"))?;
        if recipient.to_bytes() != row.note.address {
            return Err(RpcError::new(
                RPC_INTERNAL_ERROR,
                "sapling note recipient mismatch",
            ));
        }
        let memo = hex_bytes(&memo);

        if row.spendable {
            let change = tx
                .shielded_spends
                .iter()
                .any(|spend| nullifier_set.contains(&(addr_bytes, spend.nullifier)));
            out.push(json!({
                "txid": hash256_to_hex(&row.txid),
                "amount": amount_to_value(row.note.value),
                "amountZat": row.note.value,
                "memo": memo,
                "confirmations": confirmations,
                "outindex": row.out_index,
                "blockheight": row.note.height,
                "spent": spent,
                "spendable": row.spendable,
                "change": change,
            }));
        } else {
            out.push(json!({
                "txid": hash256_to_hex(&row.txid),
                "amount": amount_to_value(row.note.value),
                "amountZat": row.note.value,
                "memo": memo,
                "confirmations": confirmations,
                "outindex": row.out_index,
                "blockheight": row.note.height,
                "spent": spent,
                "spendable": row.spendable,
            }));
        }
    }

    out.sort_by(|a, b| {
        let a_height = a.get("blockheight").and_then(Value::as_i64).unwrap_or(0);
        let b_height = b.get("blockheight").and_then(Value::as_i64).unwrap_or(0);
        b_height
            .cmp(&a_height)
            .then_with(|| {
                let a_txid = a.get("txid").and_then(Value::as_str).unwrap_or("");
                let b_txid = b.get("txid").and_then(Value::as_str).unwrap_or("");
                a_txid.cmp(b_txid)
            })
            .then_with(|| {
                let a_out = a.get("outindex").and_then(Value::as_u64).unwrap_or(0);
                let b_out = b.get("outindex").and_then(Value::as_u64).unwrap_or(0);
                a_out.cmp(&b_out)
            })
    });

    Ok(Value::Array(out))
}

fn rpc_zlistaddresses(
    wallet: &Mutex<Wallet>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    if params.len() > 1 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "zlistaddresses expects 0 or 1 parameters",
        ));
    }

    let include_watchonly = match params.first() {
        Some(Value::Bool(value)) => *value,
        Some(_) => {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                "includeWatchonly must be a boolean",
            ));
        }
        None => false,
    };

    let guard = wallet
        .lock()
        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;

    let mut bytes = guard
        .sapling_addresses_bytes()
        .map_err(|_| RpcError::new(RPC_WALLET_ERROR, "failed to list sapling addresses"))?;

    if include_watchonly {
        let watch_only = guard
            .sapling_viewing_addresses_bytes()
            .map_err(|_| RpcError::new(RPC_WALLET_ERROR, "failed to list sapling addresses"))?;
        bytes.extend(watch_only);
    }

    let hrp = match chain_params.network {
        Network::Mainnet => "za",
        Network::Testnet => "ztestacadia",
        Network::Regtest => "zregtestsapling",
    };
    let hrp = Hrp::parse(hrp).map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "invalid hrp"))?;

    let mut out = BTreeSet::new();
    for addr_bytes in bytes {
        let encoded = bech32::encode::<Bech32>(hrp, addr_bytes.as_slice())
            .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "failed to encode sapling address"))?;
        out.insert(encoded);
    }

    Ok(Value::Array(out.into_iter().map(Value::String).collect()))
}

fn rpc_zexportkey(
    wallet: &Mutex<Wallet>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    if params.len() != 1 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "zexportkey expects 1 parameter",
        ));
    }

    let address = params[0]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "zaddr must be a string"))?;

    if decode_sprout_payment_address(address, chain_params.network).is_ok() {
        return Err(RpcError::new(
            RPC_WALLET_ERROR,
            "wallet does not hold private zkey for this zaddr",
        ));
    }

    let Some((diversifier, diversified_transmission_key)) =
        decode_sapling_payment_address(address, chain_params.network)
    else {
        return Err(RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "Invalid zaddr"));
    };

    let mut addr_bytes = [0u8; 43];
    addr_bytes[..11].copy_from_slice(&diversifier);
    addr_bytes[11..].copy_from_slice(&diversified_transmission_key);

    let extsk_bytes = wallet
        .lock()
        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?
        .sapling_extsk_for_address(&addr_bytes)
        .map_err(|_| RpcError::new(RPC_WALLET_ERROR, "failed to lookup sapling key"))?
        .ok_or_else(|| {
            RpcError::new(
                RPC_WALLET_ERROR,
                "wallet does not hold private zkey for this zaddr",
            )
        })?;

    let hrp = match chain_params.network {
        Network::Mainnet => "secret-extended-key-main",
        Network::Testnet => "secret-extended-key-test",
        Network::Regtest => "secret-extended-key-regtest",
    };
    let hrp = Hrp::parse(hrp).map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "invalid hrp"))?;
    let encoded = bech32::encode::<Bech32>(hrp, extsk_bytes.as_slice())
        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "failed to encode sapling spending key"))?;
    Ok(Value::String(encoded))
}

fn rpc_zexportviewingkey(
    wallet: &Mutex<Wallet>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    if params.len() != 1 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "zexportviewingkey expects 1 parameter",
        ));
    }

    let address = params[0]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "zaddr must be a string"))?;

    if decode_sprout_payment_address(address, chain_params.network).is_ok() {
        return Err(RpcError::new(
            RPC_INVALID_ADDRESS_OR_KEY,
            "Currently, only Sapling zaddrs are supported",
        ));
    }

    let Some((diversifier, diversified_transmission_key)) =
        decode_sapling_payment_address(address, chain_params.network)
    else {
        return Err(RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "Invalid zaddr"));
    };

    let mut addr_bytes = [0u8; 43];
    addr_bytes[..11].copy_from_slice(&diversifier);
    addr_bytes[11..].copy_from_slice(&diversified_transmission_key);

    let extfvk_bytes = wallet
        .lock()
        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?
        .sapling_extfvk_for_address(&addr_bytes)
        .map_err(|_| RpcError::new(RPC_WALLET_ERROR, "failed to lookup sapling key"))?
        .ok_or_else(|| {
            RpcError::new(
                RPC_WALLET_ERROR,
                "Wallet does not hold private key or viewing key for this zaddr",
            )
        })?;

    let hrp = match chain_params.network {
        Network::Mainnet => "zviewa",
        Network::Testnet => "zviewtestacadia",
        Network::Regtest => "zviewregtestsapling",
    };
    let hrp = Hrp::parse(hrp).map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "invalid hrp"))?;
    let encoded = bech32::encode::<Bech32>(hrp, extfvk_bytes.as_slice())
        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "failed to encode sapling viewing key"))?;
    Ok(Value::String(encoded))
}

fn rpc_zimportkey(
    wallet: &Mutex<Wallet>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    if params.is_empty() || params.len() > 3 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "zimportkey expects 1 to 3 parameters",
        ));
    }

    let zkey = params[0]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "zkey must be a string"))?;

    if let Some(rescan) = params.get(1) {
        let ok = match rescan {
            Value::String(value) => matches!(value.as_str(), "yes" | "no" | "whenkeyisnew"),
            Value::Bool(_) => true,
            _ => false,
        };
        if !ok {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                "rescan must be \"yes\", \"no\" or \"whenkeyisnew\"",
            ));
        }
    }

    if let Some(start_height) = params.get(2) {
        let height = start_height.as_i64().ok_or_else(|| {
            RpcError::new(RPC_INVALID_PARAMETER, "startHeight must be an integer")
        })?;
        if height < 0 {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                "Block height out of range",
            ));
        }
    }

    let expected_hrp = match chain_params.network {
        Network::Mainnet => "secret-extended-key-main",
        Network::Testnet => "secret-extended-key-test",
        Network::Regtest => "secret-extended-key-regtest",
    };

    let checked = CheckedHrpstring::new::<Bech32>(zkey)
        .map_err(|_| RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "Invalid spending key"))?;
    if checked.hrp().as_str() != expected_hrp {
        return Err(RpcError::new(
            RPC_INVALID_ADDRESS_OR_KEY,
            "Invalid spending key",
        ));
    }

    let data: Vec<u8> = checked.byte_iter().collect();
    let extsk: [u8; 169] = data
        .as_slice()
        .try_into()
        .map_err(|_| RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "Invalid spending key"))?;

    let inserted = {
        let mut guard = wallet
            .lock()
            .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;
        let inserted = guard
            .import_sapling_extsk(extsk)
            .map_err(|_| RpcError::new(RPC_WALLET_ERROR, "Error adding spending key to wallet"))?;
        if inserted {
            guard.reset_sapling_scan().map_err(|_| {
                RpcError::new(RPC_WALLET_ERROR, "Error adding spending key to wallet")
            })?;
        }
        inserted
    };

    if !inserted {
        return Ok(Value::Null);
    }

    Ok(Value::Null)
}

fn rpc_zimportviewingkey(
    wallet: &Mutex<Wallet>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    if params.is_empty() || params.len() > 3 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "zimportviewingkey expects 1 to 3 parameters",
        ));
    }

    let vkey = params[0]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "vkey must be a string"))?;

    if let Some(rescan) = params.get(1) {
        let ok = match rescan {
            Value::String(value) => matches!(value.as_str(), "yes" | "no" | "whenkeyisnew"),
            Value::Bool(_) => true,
            _ => false,
        };
        if !ok {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                "rescan must be \"yes\", \"no\" or \"whenkeyisnew\"",
            ));
        }
    }

    if let Some(start_height) = params.get(2) {
        let height = start_height.as_i64().ok_or_else(|| {
            RpcError::new(RPC_INVALID_PARAMETER, "startHeight must be an integer")
        })?;
        if height < 0 {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                "Block height out of range",
            ));
        }
    }

    let expected_hrp = match chain_params.network {
        Network::Mainnet => "zviewa",
        Network::Testnet => "zviewtestacadia",
        Network::Regtest => "zviewregtestsapling",
    };

    let checked = CheckedHrpstring::new::<Bech32>(vkey)
        .map_err(|_| RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "Invalid viewing key"))?;
    if checked.hrp().as_str() != expected_hrp {
        return Err(RpcError::new(
            RPC_INVALID_ADDRESS_OR_KEY,
            "Invalid viewing key",
        ));
    }

    let data: Vec<u8> = checked.byte_iter().collect();
    let extfvk: [u8; 169] = data
        .as_slice()
        .try_into()
        .map_err(|_| RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "Invalid viewing key"))?;

    let inserted = {
        let mut guard = wallet
            .lock()
            .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;
        let inserted = guard
            .import_sapling_extfvk(extfvk)
            .map_err(|err| match err {
                WalletError::InvalidData("invalid sapling viewing key encoding") => {
                    RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "Invalid viewing key")
                }
                _ => RpcError::new(RPC_WALLET_ERROR, "Error adding viewing key to wallet"),
            })?;
        if inserted {
            guard.reset_sapling_scan().map_err(|_| {
                RpcError::new(RPC_WALLET_ERROR, "Error adding viewing key to wallet")
            })?;
        }
        inserted
    };

    if !inserted {
        return Ok(Value::Null);
    }

    Ok(Value::Null)
}

fn rpc_zimportwallet(
    wallet: &Mutex<Wallet>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    if params.len() != 1 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "zimportwallet expects 1 parameter",
        ));
    }

    let filename = params[0]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "filename must be a string"))?;
    if filename.trim().is_empty() {
        return Err(RpcError::new(RPC_INVALID_PARAMETER, "filename is empty"));
    }

    let contents = std::fs::read_to_string(filename)
        .map_err(|_| RpcError::new(RPC_INVALID_PARAMETER, "Cannot open wallet dump file"))?;

    let expected_hrp = match chain_params.network {
        Network::Mainnet => "secret-extended-key-main",
        Network::Testnet => "secret-extended-key-test",
        Network::Regtest => "secret-extended-key-regtest",
    };

    let mut guard = wallet
        .lock()
        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;

    let mut failed = false;
    let mut imported_sapling_key = false;
    for line in contents.lines() {
        let trimmed = line.trim();
        if trimmed.is_empty() || trimmed.starts_with('#') {
            continue;
        }

        let Some(token) = trimmed.split_whitespace().next() else {
            continue;
        };

        if let Ok(checked) = CheckedHrpstring::new::<Bech32>(token) {
            if checked.hrp().as_str() == expected_hrp {
                let data: Vec<u8> = checked.byte_iter().collect();
                if let Ok(extsk) = <[u8; 169]>::try_from(data.as_slice()) {
                    match guard.import_sapling_extsk(extsk) {
                        Ok(inserted) => {
                            imported_sapling_key |= inserted;
                            continue;
                        }
                        Err(WalletError::InvalidData("invalid sapling spending key encoding")) => {}
                        Err(_) => {
                            failed = true;
                            continue;
                        }
                    }
                }
            }
        }

        match guard.import_wif(token) {
            Ok(()) => {}
            Err(WalletError::InvalidData("invalid wif")) => {}
            Err(_) => {
                failed = true;
            }
        }
    }

    if failed {
        return Err(RpcError::new(
            RPC_WALLET_ERROR,
            "Error adding some keys to wallet",
        ));
    }

    if imported_sapling_key {
        guard
            .reset_sapling_scan()
            .map_err(|_| RpcError::new(RPC_WALLET_ERROR, "Error adding some keys to wallet"))?;
    }

    Ok(Value::Null)
}

fn decode_sprout_payment_address(
    address: &str,
    network: Network,
) -> Result<([u8; 32], [u8; 32]), AddressError> {
    const SPROUT_SIZE: usize = 64;
    const PREFIX_MAINNET: [u8; 2] = [0x16, 0x9a];
    const PREFIX_TESTNET: [u8; 2] = [0x16, 0xb6];

    let prefix: &[u8] = match network {
        Network::Mainnet => &PREFIX_MAINNET,
        Network::Testnet | Network::Regtest => &PREFIX_TESTNET,
    };

    let payload = base58check_decode(address)?;
    if !payload.starts_with(prefix) {
        return Err(AddressError::UnknownPrefix);
    }

    let body = &payload[prefix.len()..];
    if body.len() != SPROUT_SIZE {
        return Err(AddressError::InvalidLength);
    }

    let payingkey: [u8; 32] = body[..32]
        .try_into()
        .map_err(|_| AddressError::InvalidLength)?;
    let transmissionkey: [u8; 32] = body[32..]
        .try_into()
        .map_err(|_| AddressError::InvalidLength)?;

    Ok((payingkey, transmissionkey))
}

fn encode_sprout_payment_address(
    address: &fluxd_shielded::SproutPaymentAddress,
    network: Network,
) -> String {
    const PREFIX_MAINNET: [u8; 2] = [0x16, 0x9a];
    const PREFIX_TESTNET: [u8; 2] = [0x16, 0xb6];

    let prefix: &[u8] = match network {
        Network::Mainnet => &PREFIX_MAINNET,
        Network::Testnet | Network::Regtest => &PREFIX_TESTNET,
    };

    let mut payload = Vec::with_capacity(prefix.len() + 64);
    payload.extend_from_slice(prefix);
    payload.extend_from_slice(&address.a_pk);
    payload.extend_from_slice(&address.pk_enc);
    base58check_encode(&payload)
}

fn is_valid_sapling_spending_key(zkey: &str, network: Network) -> bool {
    let expected_hrp = match network {
        Network::Mainnet => "secret-extended-key-main",
        Network::Testnet => "secret-extended-key-test",
        Network::Regtest => "secret-extended-key-regtest",
    };

    let Ok(checked) = CheckedHrpstring::new::<Bech32>(zkey) else {
        return false;
    };
    if checked.hrp().as_str() != expected_hrp {
        return false;
    }
    let data: Vec<u8> = checked.byte_iter().collect();
    let Ok(extsk) = <[u8; 169]>::try_from(data.as_slice()) else {
        return false;
    };
    sapling_crypto::zip32::ExtendedSpendingKey::from_bytes(&extsk).is_ok()
}

fn decode_sprout_spending_key(
    zkey: &str,
    network: Network,
) -> Result<fluxd_shielded::SproutSpendingKey, RpcError> {
    const SPROUT_KEY_SIZE: usize = 32;
    const PREFIX_MAINNET: [u8; 2] = [0xAB, 0x36];
    const PREFIX_TESTNET: [u8; 2] = [0xAC, 0x08];

    let prefix: &[u8] = match network {
        Network::Mainnet => &PREFIX_MAINNET,
        Network::Testnet | Network::Regtest => &PREFIX_TESTNET,
    };

    if let Ok(payload) = base58check_decode(zkey) {
        if payload.starts_with(prefix) && payload.len() == prefix.len() + SPROUT_KEY_SIZE {
            let bytes: [u8; 32] = payload[prefix.len()..]
                .try_into()
                .map_err(|_| RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "Invalid spending key"))?;
            return fluxd_shielded::SproutSpendingKey::from_bytes(bytes)
                .map_err(|_| RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "Invalid spending key"));
        }
    }

    if is_valid_sapling_spending_key(zkey, network) {
        return Err(RpcError::new(
            RPC_INVALID_ADDRESS_OR_KEY,
            "Only works with Sprout spending keys",
        ));
    }

    Err(RpcError::new(
        RPC_INVALID_ADDRESS_OR_KEY,
        "Invalid spending key",
    ))
}

fn encode_sprout_spending_key(key: fluxd_shielded::SproutSpendingKey, network: Network) -> String {
    const PREFIX_MAINNET: [u8; 2] = [0xAB, 0x36];
    const PREFIX_TESTNET: [u8; 2] = [0xAC, 0x08];

    let prefix: &[u8] = match network {
        Network::Mainnet => &PREFIX_MAINNET,
        Network::Testnet | Network::Regtest => &PREFIX_TESTNET,
    };

    let key_bytes = key.to_bytes();
    let mut payload = Vec::with_capacity(prefix.len() + key_bytes.len());
    payload.extend_from_slice(prefix);
    payload.extend_from_slice(&key_bytes);
    base58check_encode(&payload)
}

fn encode_sprout_viewing_key(a_pk: &[u8; 32], sk_enc: &[u8; 32], network: Network) -> String {
    const PREFIX_MAINNET: [u8; 3] = [0xA8, 0xAB, 0xD3];
    const PREFIX_TESTNET: [u8; 3] = [0xA8, 0xAC, 0x0C];

    let prefix: &[u8] = match network {
        Network::Mainnet => &PREFIX_MAINNET,
        Network::Testnet | Network::Regtest => &PREFIX_TESTNET,
    };

    let mut payload = Vec::with_capacity(prefix.len() + 64);
    payload.extend_from_slice(prefix);
    payload.extend_from_slice(a_pk);
    payload.extend_from_slice(sk_enc);
    base58check_encode(&payload)
}

fn decode_sapling_payment_address(address: &str, network: Network) -> Option<([u8; 11], [u8; 32])> {
    const SAPLING_SIZE: usize = 43;
    const DIVERSIFIER_SIZE: usize = 11;
    const PK_D_SIZE: usize = 32;

    let expected_hrp = match network {
        Network::Mainnet => "za",
        Network::Testnet => "ztestacadia",
        Network::Regtest => "zregtestsapling",
    };

    let expected_hrp = Hrp::parse(expected_hrp).ok()?;
    let checked = CheckedHrpstring::new::<Bech32>(address).ok()?;
    if checked.hrp() != expected_hrp {
        return None;
    }

    let decoded: Vec<u8> = checked.byte_iter().collect();
    if decoded.len() != SAPLING_SIZE {
        return None;
    }

    let diversifier: [u8; DIVERSIFIER_SIZE] = decoded[..DIVERSIFIER_SIZE].try_into().ok()?;
    let diversified_transmission_key: [u8; PK_D_SIZE] =
        decoded[DIVERSIFIER_SIZE..].try_into().ok()?;

    Some((diversifier, diversified_transmission_key))
}

fn decode_sprout_joinsplit_address(
    address: &str,
    network: Network,
) -> Result<fluxd_shielded::SproutPaymentAddress, RpcError> {
    if let Ok((payingkey, transmissionkey)) = decode_sprout_payment_address(address, network) {
        return Ok(fluxd_shielded::SproutPaymentAddress {
            a_pk: payingkey,
            pk_enc: transmissionkey,
        });
    }

    if decode_sapling_payment_address(address, network).is_some() {
        return Err(RpcError::new(
            RPC_INVALID_ADDRESS_OR_KEY,
            "Only works with Sprout payment addresses",
        ));
    }

    Err(RpcError::new(
        RPC_INVALID_ADDRESS_OR_KEY,
        "Invalid recipient address.",
    ))
}

fn rpc_validateaddress(
    wallet: &Mutex<Wallet>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    if params.len() != 1 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "validateaddress expects 1 parameter",
        ));
    }
    let address = params[0]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "address must be a string"))?;
    let script_pubkey = match address_to_script_pubkey(address, chain_params.network) {
        Ok(script) => script,
        Err(_) => {
            return Ok(json!({
                "isvalid": false,
            }))
        }
    };

    let (ismine, iswatchonly, pubkey, redeem_script, account) = {
        let wallet_guard = wallet
            .lock()
            .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;
        let ismine = wallet_guard.can_spend_script_pubkey(&script_pubkey);
        let iswatchonly = if ismine {
            false
        } else {
            wallet_guard.script_pubkey_is_watchonly(&script_pubkey)
        };
        let stored_label = wallet_guard
            .label_for_script_pubkey(&script_pubkey)
            .map(|label| label.to_string());
        let account = if ismine || iswatchonly {
            Some(stored_label.clone().unwrap_or_default())
        } else {
            stored_label
        };
        let pubkey = wallet_guard
            .pubkey_bytes_for_p2pkh_script_pubkey(&script_pubkey)
            .map_err(map_wallet_error)?;
        let redeem_script = wallet_guard.redeem_script_for_p2sh_script_pubkey(&script_pubkey);
        (ismine, iswatchonly, pubkey, redeem_script, account)
    };

    let isscript = matches!(
        classify_script_pubkey(&script_pubkey),
        ScriptType::P2Sh | ScriptType::P2Wsh
    );

    let mut out = serde_json::Map::new();
    out.insert("isvalid".to_string(), Value::Bool(true));
    out.insert("address".to_string(), Value::String(address.to_string()));
    out.insert(
        "scriptPubKey".to_string(),
        Value::String(hex_bytes(&script_pubkey)),
    );
    out.insert("ismine".to_string(), Value::Bool(ismine));
    out.insert("iswatchonly".to_string(), Value::Bool(iswatchonly));
    out.insert("isscript".to_string(), Value::Bool(isscript));
    if let Some(account) = account {
        out.insert("account".to_string(), Value::String(account));
    }

    if let Some(pubkey) = pubkey {
        out.insert("pubkey".to_string(), Value::String(hex_bytes(&pubkey)));
        out.insert("iscompressed".to_string(), Value::Bool(pubkey.len() == 33));
    }

    if isscript {
        if let Some(redeem_script) = redeem_script {
            if let Some((required, pubkeys)) =
                parse_multisig_redeem_script_with_required(&redeem_script)
            {
                out.insert("script".to_string(), Value::String("multisig".to_string()));
                out.insert("hex".to_string(), Value::String(hex_bytes(&redeem_script)));
                let addresses = pubkeys
                    .iter()
                    .filter_map(|pubkey| {
                        let key_hash = hash160(&pubkey.serialize());
                        let mut p2pkh = Vec::with_capacity(25);
                        p2pkh.extend_from_slice(&[0x76, 0xa9, 0x14]);
                        p2pkh.extend_from_slice(&key_hash);
                        p2pkh.extend_from_slice(&[0x88, 0xac]);
                        script_pubkey_to_address(&p2pkh, chain_params.network)
                    })
                    .map(Value::String)
                    .collect::<Vec<_>>();
                out.insert("addresses".to_string(), Value::Array(addresses));
                out.insert(
                    "sigsrequired".to_string(),
                    Value::Number((required as u64).into()),
                );
            } else {
                if let Value::Object(map) = script_pubkey_json(&redeem_script, chain_params.network)
                {
                    if let Some(Value::String(script_type)) = map.get("type") {
                        out.insert("script".to_string(), Value::String(script_type.clone()));
                    }
                    if let Some(Value::String(hex)) = map.get("hex") {
                        out.insert("hex".to_string(), Value::String(hex.clone()));
                    }
                    if let Some(Value::Array(addresses)) = map.get("addresses") {
                        out.insert("addresses".to_string(), Value::Array(addresses.clone()));
                    }
                }
            }
        }
    }

    Ok(Value::Object(out))
}

fn rpc_verifymessage(params: Vec<Value>, chain_params: &ChainParams) -> Result<Value, RpcError> {
    if params.len() != 3 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "verifymessage expects 3 parameters",
        ));
    }
    let address = params[0]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "address must be a string"))?;
    let signature = params[1]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "signature must be a string"))?;
    let message = params[2]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "message must be a string"))?;

    let script_pubkey = address_to_script_pubkey(address, chain_params.network)
        .map_err(|_| RpcError::new(RPC_TYPE_ERROR, "Invalid address"))?;
    if classify_script_pubkey(&script_pubkey) != ScriptType::P2Pkh {
        return Err(RpcError::new(
            RPC_TYPE_ERROR,
            "Address does not refer to key",
        ));
    }
    if script_pubkey.len() < 23 {
        return Err(RpcError::new(RPC_INTERNAL_ERROR, "invalid scriptPubKey"));
    }
    let expected_key_hash: [u8; 20] = script_pubkey[3..23]
        .try_into()
        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "invalid scriptPubKey"))?;

    let sig_bytes = base64::engine::general_purpose::STANDARD
        .decode(signature.as_bytes())
        .map_err(|_| RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "Malformed base64 encoding"))?;

    let recovered_pubkey = match recover_signed_message_pubkey(&sig_bytes, message.as_bytes()) {
        Ok(pubkey) => pubkey,
        Err(_) => return Ok(Value::Bool(false)),
    };
    let recovered_hash = hash160(&recovered_pubkey);
    Ok(Value::Bool(recovered_hash == expected_key_hash))
}

fn multisig_pubkey_from_input(
    wallet: &Wallet,
    key: &str,
    chain_params: &ChainParams,
) -> Result<Vec<u8>, RpcError> {
    if let Ok(script_pubkey) = address_to_script_pubkey(key, chain_params.network) {
        if classify_script_pubkey(&script_pubkey) != ScriptType::P2Pkh {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                format!("{key} does not refer to a key"),
            ));
        }
        let pubkey = wallet
            .pubkey_bytes_for_p2pkh_script_pubkey(&script_pubkey)
            .map_err(map_wallet_error)?
            .ok_or_else(|| {
                RpcError::new(
                    RPC_INVALID_PARAMETER,
                    format!("no full public key for address {key}"),
                )
            })?;
        PublicKey::from_slice(&pubkey).map_err(|_| {
            RpcError::new(RPC_INVALID_PARAMETER, format!(" Invalid public key: {key}"))
        })?;
        return Ok(pubkey);
    }

    if let Some(bytes) = bytes_from_hex(key) {
        PublicKey::from_slice(&bytes).map_err(|_| {
            RpcError::new(RPC_INVALID_PARAMETER, format!(" Invalid public key: {key}"))
        })?;
        return Ok(bytes);
    }

    Err(RpcError::new(
        RPC_INVALID_PARAMETER,
        format!(" Invalid public key: {key}"),
    ))
}

fn rpc_addmultisigaddress(
    wallet: &Mutex<Wallet>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    const MAX_PUBKEYS: usize = 16;
    const MAX_SCRIPT_ELEMENT_SIZE: usize = 520;

    if params.len() < 2 || params.len() > 3 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "addmultisigaddress expects 2 or 3 parameters",
        ));
    }

    let required = parse_u32(&params[0], "nrequired")? as usize;
    if required < 1 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "a multisignature address must require at least one key to redeem",
        ));
    }
    let keys = params[1].as_array().ok_or_else(|| {
        RpcError::new(
            RPC_INVALID_PARAMETER,
            "keys must be a json array of strings",
        )
    })?;
    if keys.len() < required {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            format!(
                "not enough keys supplied (got {} keys, but need at least {required} to redeem)",
                keys.len()
            ),
        ));
    }
    if keys.len() > MAX_PUBKEYS {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "Number of addresses involved in the multisignature address creation > 16\nReduce the number",
        ));
    }

    let label = match params.get(2) {
        None | Some(Value::Null) => String::new(),
        Some(value) => {
            let account = value
                .as_str()
                .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "account must be a string"))?;
            if !account.is_empty() {
                return Err(RpcError::new(RPC_INVALID_PARAMETER, "account must be \"\""));
            }
            String::new()
        }
    };

    let mut wallet_guard = wallet
        .lock()
        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;

    let mut pubkeys = Vec::with_capacity(keys.len());
    for key in keys {
        let key = key
            .as_str()
            .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "keys must be strings"))?;
        pubkeys.push(multisig_pubkey_from_input(
            &wallet_guard,
            key,
            chain_params,
        )?);
    }

    let mut redeem_script = Vec::new();
    redeem_script.push(multisig_small_int_opcode(required)?);
    for pubkey in &pubkeys {
        redeem_script.push(pubkey.len() as u8);
        redeem_script.extend_from_slice(pubkey);
    }
    redeem_script.push(multisig_small_int_opcode(pubkeys.len())?);
    redeem_script.push(0xae);

    if redeem_script.len() > MAX_SCRIPT_ELEMENT_SIZE {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            format!(
                "redeemScript exceeds size limit: {} > {}",
                redeem_script.len(),
                MAX_SCRIPT_ELEMENT_SIZE
            ),
        ));
    }

    let address = script_p2sh_address(&redeem_script, chain_params.network);

    let hash = hash160(&redeem_script);
    let mut script_pubkey = Vec::with_capacity(23);
    script_pubkey.push(0xa9);
    script_pubkey.push(0x14);
    script_pubkey.extend_from_slice(&hash);
    script_pubkey.push(0x87);

    wallet_guard
        .import_redeem_script(redeem_script)
        .map_err(map_wallet_error)?;
    wallet_guard
        .import_watch_script_pubkey(script_pubkey.clone())
        .map_err(map_wallet_error)?;
    if !label.is_empty() {
        wallet_guard
            .set_label_for_script_pubkey(script_pubkey, label)
            .map_err(map_wallet_error)?;
    }

    Ok(Value::String(address))
}

fn rpc_createmultisig(
    wallet: &Mutex<Wallet>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    const MAX_PUBKEYS: usize = 16;
    const MAX_SCRIPT_ELEMENT_SIZE: usize = 520;

    if params.len() != 2 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "createmultisig expects 2 parameters",
        ));
    }
    let required = parse_u32(&params[0], "nrequired")? as usize;
    if required < 1 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "a multisignature address must require at least one key to redeem",
        ));
    }
    let keys = params[1].as_array().ok_or_else(|| {
        RpcError::new(
            RPC_INVALID_PARAMETER,
            "keys must be a json array of strings",
        )
    })?;
    if keys.len() < required {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            format!(
                "not enough keys supplied (got {} keys, but need at least {required} to redeem)",
                keys.len()
            ),
        ));
    }
    if keys.len() > MAX_PUBKEYS {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "Number of addresses involved in the multisignature address creation > 16\nReduce the number",
        ));
    }

    let wallet_guard = wallet
        .lock()
        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;

    let mut pubkeys = Vec::with_capacity(keys.len());
    for key in keys {
        let key = key
            .as_str()
            .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "keys must be strings"))?;
        pubkeys.push(multisig_pubkey_from_input(
            &wallet_guard,
            key,
            chain_params,
        )?);
    }

    let mut redeem_script = Vec::new();
    redeem_script.push(multisig_small_int_opcode(required)?);
    for pubkey in &pubkeys {
        redeem_script.push(pubkey.len() as u8);
        redeem_script.extend_from_slice(pubkey);
    }
    redeem_script.push(multisig_small_int_opcode(pubkeys.len())?);
    redeem_script.push(0xae);

    if redeem_script.len() > MAX_SCRIPT_ELEMENT_SIZE {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            format!(
                "redeemScript exceeds size limit: {} > {}",
                redeem_script.len(),
                MAX_SCRIPT_ELEMENT_SIZE
            ),
        ));
    }

    Ok(json!({
        "address": script_p2sh_address(&redeem_script, chain_params.network),
        "redeemScript": hex_bytes(&redeem_script),
    }))
}

fn rpc_getrawtransaction<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    mempool: &Mutex<Mempool>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    if params.is_empty() || params.len() > 2 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "getrawtransaction expects 1 or 2 parameters",
        ));
    }
    let txid = parse_hash(&params[0])?;
    let verbose = if params.len() > 1 {
        parse_verbose_flag(&params[1])?
    } else {
        false
    };
    if let Ok(guard) = mempool.lock() {
        if let Some(entry) = guard.get(&txid) {
            if !verbose {
                return Ok(Value::String(hex_bytes(&entry.raw)));
            }
            let mut obj = match tx_to_json(&entry.tx, chain_params.network)? {
                Value::Object(map) => map,
                _ => return Err(RpcError::new(RPC_INTERNAL_ERROR, "invalid tx json")),
            };
            obj.insert("hex".to_string(), Value::String(hex_bytes(&entry.raw)));
            return Ok(Value::Object(obj));
        }
    }
    let location = chainstate
        .tx_location(&txid)
        .map_err(map_internal)?
        .ok_or_else(|| RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "transaction not found"))?;
    let bytes = chainstate
        .read_block(location.block)
        .map_err(map_internal)?;
    let block = fluxd_primitives::block::Block::consensus_decode(&bytes).map_err(map_internal)?;
    let tx_index = location.index as usize;
    let tx = block
        .transactions
        .get(tx_index)
        .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "transaction index out of range"))?;
    let encoded = tx.consensus_encode().map_err(map_internal)?;
    if !verbose {
        return Ok(Value::String(hex_bytes(&encoded)));
    }
    let mut obj = match tx_to_json(tx, chain_params.network)? {
        Value::Object(map) => map,
        _ => return Err(RpcError::new(RPC_INTERNAL_ERROR, "invalid tx json")),
    };
    obj.insert("hex".to_string(), Value::String(hex_bytes(&encoded)));
    let block_hash = block.header.hash();
    if let Ok(Some(entry)) = chainstate.header_entry(&block_hash) {
        let best_height = best_block_height(chainstate)?;
        let confirmations =
            confirmations_for_height(chainstate, entry.height, best_height, &block_hash)?;
        obj.insert(
            "blockhash".to_string(),
            Value::String(hash256_to_hex(&block_hash)),
        );
        obj.insert(
            "confirmations".to_string(),
            Value::Number(confirmations.into()),
        );
        obj.insert("time".to_string(), Value::Number(block.header.time.into()));
        obj.insert(
            "blocktime".to_string(),
            Value::Number(block.header.time.into()),
        );
        obj.insert("height".to_string(), Value::Number(entry.height.into()));
    }
    Ok(Value::Object(obj))
}

#[derive(Clone, Debug)]
struct PrevoutInfo {
    value: i64,
    script_pubkey: Vec<u8>,
    redeem_script: Option<Vec<u8>>,
}

fn p2pkh_script_pubkey(key_hash: &[u8; 20]) -> Vec<u8> {
    let mut script = Vec::with_capacity(25);
    script.extend_from_slice(&[0x76, 0xa9, 0x14]);
    script.extend_from_slice(key_hash);
    script.extend_from_slice(&[0x88, 0xac]);
    script
}

fn push_script_bytes(script: &mut Vec<u8>, data: &[u8]) -> Result<(), RpcError> {
    const OP_PUSHDATA1: u8 = 0x4c;
    const OP_PUSHDATA2: u8 = 0x4d;
    const OP_PUSHDATA4: u8 = 0x4e;

    if data.len() < OP_PUSHDATA1 as usize {
        script.push(data.len() as u8);
        script.extend_from_slice(data);
        return Ok(());
    }
    if data.len() <= u8::MAX as usize {
        script.extend_from_slice(&[OP_PUSHDATA1, data.len() as u8]);
        script.extend_from_slice(data);
        return Ok(());
    }
    if data.len() <= u16::MAX as usize {
        script.push(OP_PUSHDATA2);
        script.extend_from_slice(&(data.len() as u16).to_le_bytes());
        script.extend_from_slice(data);
        return Ok(());
    }
    let len = u32::try_from(data.len())
        .map_err(|_| RpcError::new(RPC_INVALID_PARAMETER, "pushdata too large"))?;
    script.push(OP_PUSHDATA4);
    script.extend_from_slice(&len.to_le_bytes());
    script.extend_from_slice(data);
    Ok(())
}

fn parse_sighash_type(value: Option<&Value>) -> Result<SighashType, RpcError> {
    let Some(value) = value else {
        return Ok(SighashType(SIGHASH_ALL));
    };
    if value.is_null() {
        return Ok(SighashType(SIGHASH_ALL));
    }
    let text = value.as_str().ok_or_else(|| {
        RpcError::new(
            RPC_INVALID_PARAMETER,
            "sighashtype must be a string (e.g. ALL)",
        )
    })?;
    let normalized = text.trim().to_ascii_uppercase();
    let (base, anyone_can_pay) = match normalized.as_str() {
        "ALL" => (SIGHASH_ALL, false),
        "NONE" => (SIGHASH_NONE, false),
        "SINGLE" => (SIGHASH_SINGLE, false),
        "ALL|ANYONECANPAY" => (SIGHASH_ALL, true),
        "NONE|ANYONECANPAY" => (SIGHASH_NONE, true),
        "SINGLE|ANYONECANPAY" => (SIGHASH_SINGLE, true),
        _ => {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                format!("unsupported sighashtype {text}"),
            ))
        }
    };
    Ok(SighashType(
        base | if anyone_can_pay {
            SIGHASH_ANYONECANPAY
        } else {
            0
        },
    ))
}

fn parse_prevtxs_map(value: &Value) -> Result<HashMap<OutPoint, PrevoutInfo>, RpcError> {
    let entries = value.as_array().ok_or_else(|| {
        RpcError::new(RPC_INVALID_PARAMETER, "prevtxs must be an array of objects")
    })?;
    let mut out = HashMap::new();
    for entry in entries {
        let obj = entry.as_object().ok_or_else(|| {
            RpcError::new(RPC_INVALID_PARAMETER, "prevtxs entries must be objects")
        })?;
        let txid_value = obj
            .get("txid")
            .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "missing txid"))?;
        let vout_value = obj
            .get("vout")
            .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "missing vout"))?;
        let script_value = obj
            .get("scriptPubKey")
            .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "missing scriptPubKey"))?;
        let amount_value = obj.get("amount");
        let redeem_script_value = obj.get("redeemScript");

        let txid = parse_hash(txid_value)?;
        let vout = parse_u32(vout_value, "vout")?;
        let script_hex = script_value
            .as_str()
            .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "scriptPubKey must be a string"))?;
        let script_pubkey = bytes_from_hex(script_hex)
            .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "scriptPubKey must be hex"))?;
        let value = match amount_value {
            Some(value) if !value.is_null() => parse_amount(value)?,
            _ => 0,
        };
        let redeem_script = match redeem_script_value {
            None | Some(Value::Null) => None,
            Some(value) => {
                let hex = value.as_str().ok_or_else(|| {
                    RpcError::new(RPC_INVALID_PARAMETER, "redeemScript must be a string")
                })?;
                let bytes = bytes_from_hex(hex).ok_or_else(|| {
                    RpcError::new(RPC_INVALID_PARAMETER, "redeemScript must be hex")
                })?;
                Some(bytes)
            }
        };

        out.insert(
            OutPoint {
                hash: txid,
                index: vout,
            },
            PrevoutInfo {
                value,
                script_pubkey,
                redeem_script,
            },
        );
    }
    Ok(out)
}

fn parse_branch_id(value: Option<&Value>) -> Result<Option<u32>, RpcError> {
    let Some(value) = value else {
        return Ok(None);
    };
    if value.is_null() {
        return Ok(None);
    }
    let text = value.as_str().ok_or_else(|| {
        RpcError::new(RPC_INVALID_PARAMETER, "branchid must be a string (hex u32)")
    })?;
    let mut text = text.trim();
    if let Some(stripped) = text.strip_prefix("0x").or_else(|| text.strip_prefix("0X")) {
        text = stripped;
    }
    if text.is_empty() {
        return Err(RpcError::new(RPC_INVALID_PARAMETER, "branchid is empty"));
    }
    let branch_id = u32::from_str_radix(text, 16)
        .map_err(|_| RpcError::new(RPC_INVALID_PARAMETER, "invalid branchid"))?;
    if !fluxd_consensus::upgrades::is_consensus_branch_id(branch_id) {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            format!("{text} is not a valid consensus branch id"),
        ));
    }
    Ok(Some(branch_id))
}

fn resolve_prevout_info<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    mempool: &Mutex<Mempool>,
    outpoint: &OutPoint,
    overrides: &HashMap<OutPoint, PrevoutInfo>,
) -> Result<Option<PrevoutInfo>, RpcError> {
    if let Some(prevout) = overrides.get(outpoint) {
        return Ok(Some(prevout.clone()));
    }
    if let Some(entry) = chainstate.utxo_entry(outpoint).map_err(map_internal)? {
        return Ok(Some(PrevoutInfo {
            value: entry.value,
            script_pubkey: entry.script_pubkey,
            redeem_script: None,
        }));
    }
    let guard = mempool
        .lock()
        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "mempool lock poisoned"))?;
    Ok(guard.prevout(outpoint).map(|prev| PrevoutInfo {
        value: prev.value,
        script_pubkey: prev.script_pubkey,
        redeem_script: None,
    }))
}

fn decode_small_int_opcode(opcode: u8) -> Option<usize> {
    match opcode {
        0x00 => Some(0),
        0x51..=0x60 => Some((opcode - 0x50) as usize),
        _ => None,
    }
}

fn parse_multisig_redeem_script_with_required(script: &[u8]) -> Option<(usize, Vec<PublicKey>)> {
    const OP_CHECKMULTISIG: u8 = 0xae;
    const OP_PUSHDATA1: u8 = 0x4c;
    const OP_PUSHDATA2: u8 = 0x4d;
    const OP_PUSHDATA4: u8 = 0x4e;

    if script.len() < 3 {
        return None;
    }
    if script.last().copied() != Some(OP_CHECKMULTISIG) {
        return None;
    }
    let n = decode_small_int_opcode(*script.get(script.len().saturating_sub(2))?)?;
    let m = decode_small_int_opcode(*script.first()?)?;
    if m == 0 || n == 0 || m > n || n > 16 {
        return None;
    }

    let mut pubkeys = Vec::new();
    let mut cursor = 1usize;
    let end = script.len().saturating_sub(2);
    while cursor < end {
        let opcode = *script.get(cursor)?;
        let (len, advance) = match opcode {
            len @ 1..=75 => (len as usize, 1usize),
            OP_PUSHDATA1 => (*script.get(cursor + 1)? as usize, 2usize),
            OP_PUSHDATA2 => {
                let bytes: [u8; 2] = script.get(cursor + 1..cursor + 3)?.try_into().ok()?;
                (u16::from_le_bytes(bytes) as usize, 3usize)
            }
            OP_PUSHDATA4 => {
                let bytes: [u8; 4] = script.get(cursor + 1..cursor + 5)?.try_into().ok()?;
                (u32::from_le_bytes(bytes) as usize, 5usize)
            }
            _ => return None,
        };
        cursor = cursor.saturating_add(advance);
        if len != 33 && len != 65 {
            return None;
        }
        let start = cursor;
        let stop = start.saturating_add(len);
        if stop > end {
            return None;
        }
        let pubkey = PublicKey::from_slice(script.get(start..stop)?).ok()?;
        pubkeys.push(pubkey);
        cursor = stop;
    }
    if cursor != end {
        return None;
    }
    if pubkeys.len() != n {
        return None;
    }
    Some((m, pubkeys))
}

fn rpc_signrawtransaction<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    mempool: &Mutex<Mempool>,
    wallet: &Mutex<Wallet>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    if params.is_empty() || params.len() > 5 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "signrawtransaction expects 1 to 5 parameters",
        ));
    }
    let hex = params[0]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "hexstring must be a string"))?;
    let raw = bytes_from_hex(hex)
        .ok_or_else(|| RpcError::new(RPC_DESERIALIZATION_ERROR, "TX decode failed"))?;
    let mut tx = Transaction::consensus_decode(&raw)
        .map_err(|_| RpcError::new(RPC_DESERIALIZATION_ERROR, "TX decode failed"))?;
    if tx.fluxnode.is_some() {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "signrawtransaction does not support fluxnode transactions",
        ));
    }
    if tx.version == FLUXNODE_TX_VERSION || tx.version == FLUXNODE_TX_UPGRADEABLE_VERSION {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "signrawtransaction does not support fluxnode transactions",
        ));
    }

    let prevtxs = match params.get(1) {
        Some(value) if !value.is_null() => parse_prevtxs_map(value)?,
        _ => HashMap::new(),
    };

    let secp = Secp256k1::signing_only();

    let given_keys = params.get(2).is_some_and(|value| !value.is_null());
    let mut key_overrides: HashMap<Vec<u8>, (SecretKey, Vec<u8>)> = HashMap::new();
    let mut key_overrides_by_pubkey: HashMap<[u8; 33], SecretKey> = HashMap::new();
    if let Some(value) = params.get(2) {
        if !value.is_null() {
            let keys = value.as_array().ok_or_else(|| {
                RpcError::new(
                    RPC_INVALID_PARAMETER,
                    "privkeys must be an array of strings",
                )
            })?;
            for entry in keys {
                let wif = entry.as_str().ok_or_else(|| {
                    RpcError::new(RPC_INVALID_PARAMETER, "privkeys must be strings")
                })?;
                let (secret, compressed) = parse_wif_secret_key(wif, chain_params.network)?;
                let pubkey_bytes = secret_key_pubkey_bytes(&secret, compressed);
                let key_hash = hash160(&pubkey_bytes);
                let script_pubkey = p2pkh_script_pubkey(&key_hash);
                let pubkey = PublicKey::from_secret_key(&secp, &secret);
                key_overrides_by_pubkey.insert(pubkey.serialize(), secret.clone());
                key_overrides.insert(script_pubkey, (secret, pubkey_bytes));
            }
        }
    }

    let sighash_type = parse_sighash_type(params.get(3))?;
    if sighash_type.0 > 0xff {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "sighashtype must fit in one byte",
        ));
    }

    let best_block_height = chainstate
        .best_block()
        .map_err(map_internal)?
        .map(|tip| tip.height)
        .unwrap_or(0);
    let best_header_height = chainstate
        .best_header()
        .map_err(map_internal)?
        .map(|tip| tip.height)
        .unwrap_or(best_block_height);
    let next_height = best_block_height.max(best_header_height).saturating_add(1);
    let mut branch_id = current_epoch_branch_id(next_height, &chain_params.consensus.upgrades);
    if let Some(override_branch_id) = parse_branch_id(params.get(4))? {
        branch_id = override_branch_id;
    }

    let mut errors: Vec<Value> = Vec::new();

    let wallet_guard = wallet
        .lock()
        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;

    let wallet_signing_key_for_script_pubkey =
        |script_pubkey: &[u8]| -> Result<Option<(SecretKey, Vec<u8>)>, RpcError> {
            match wallet_guard.signing_key_for_script_pubkey(script_pubkey) {
                Ok(key) => Ok(key),
                Err(err) => {
                    if given_keys {
                        Ok(None)
                    } else {
                        Err(map_wallet_error(err))
                    }
                }
            }
        };

    let wallet_signing_key_for_pubkey =
        |pubkey: &PublicKey| -> Result<Option<SecretKey>, RpcError> {
            match wallet_guard.signing_key_for_pubkey(pubkey) {
                Ok(key) => Ok(key),
                Err(err) => {
                    if given_keys {
                        Ok(None)
                    } else {
                        Err(map_wallet_error(err))
                    }
                }
            }
        };

    for input_index in 0..tx.vin.len() {
        let outpoint = tx
            .vin
            .get(input_index)
            .map(|input| input.prevout.clone())
            .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "input index out of range"))?;
        let prevout = match resolve_prevout_info(chainstate, mempool, &outpoint, &prevtxs)? {
            Some(prevout) => prevout,
            None => {
                errors.push(json!({
                    "txid": hash256_to_hex(&outpoint.hash),
                    "vout": outpoint.index,
                    "scriptSig": hex_bytes(&tx.vin[input_index].script_sig),
                    "sequence": tx.vin[input_index].sequence,
                    "error": "Missing inputs",
                }));
                continue;
            }
        };

        match classify_script_pubkey(&prevout.script_pubkey) {
            ScriptType::P2Pkh => {
                let (secret, pubkey_bytes) = match key_overrides.get(&prevout.script_pubkey) {
                    Some((secret, pubkey)) => (secret.clone(), pubkey.clone()),
                    None => match wallet_signing_key_for_script_pubkey(&prevout.script_pubkey)? {
                        Some((secret, pubkey)) => (secret, pubkey),
                        None => {
                            errors.push(json!({
                                "txid": hash256_to_hex(&outpoint.hash),
                                "vout": outpoint.index,
                                "scriptSig": hex_bytes(&tx.vin[input_index].script_sig),
                                "sequence": tx.vin[input_index].sequence,
                                "error": "Private key not available for this input",
                            }));
                            continue;
                        }
                    },
                };

                let sighash = match signature_hash(
                    &tx,
                    Some(input_index),
                    &prevout.script_pubkey,
                    prevout.value,
                    sighash_type,
                    branch_id,
                ) {
                    Ok(hash) => hash,
                    Err(err) => {
                        errors.push(json!({
                            "txid": hash256_to_hex(&outpoint.hash),
                            "vout": outpoint.index,
                            "scriptSig": hex_bytes(&tx.vin[input_index].script_sig),
                            "sequence": tx.vin[input_index].sequence,
                            "error": format!("sighash failed: {err}"),
                        }));
                        continue;
                    }
                };

                let msg = Message::from_digest_slice(&sighash)
                    .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "Invalid sighash digest"))?;
                let mut sig = secp.sign_ecdsa(&msg, &secret);
                sig.normalize_s();
                let mut sig_bytes = sig.serialize_der().as_ref().to_vec();
                sig_bytes.push(sighash_type.0 as u8);

                let mut script_sig = Vec::new();
                push_script_bytes(&mut script_sig, &sig_bytes)?;
                push_script_bytes(&mut script_sig, &pubkey_bytes)?;
                if let Some(input) = tx.vin.get_mut(input_index) {
                    input.script_sig = script_sig;
                }

                if let Err(err) = verify_script(
                    &tx.vin[input_index].script_sig,
                    &prevout.script_pubkey,
                    &tx,
                    input_index,
                    prevout.value,
                    STANDARD_SCRIPT_VERIFY_FLAGS,
                    branch_id,
                ) {
                    errors.push(json!({
                        "txid": hash256_to_hex(&outpoint.hash),
                        "vout": outpoint.index,
                        "scriptSig": hex_bytes(&tx.vin[input_index].script_sig),
                        "sequence": tx.vin[input_index].sequence,
                        "error": format!("script verification failed: {err}"),
                    }));
                }
            }
            ScriptType::P2Sh => {
                let redeem_script = prevout.redeem_script.clone().or_else(|| {
                    wallet_guard.redeem_script_for_p2sh_script_pubkey(&prevout.script_pubkey)
                });
                let Some(redeem_script) = redeem_script else {
                    errors.push(json!({
                        "txid": hash256_to_hex(&outpoint.hash),
                        "vout": outpoint.index,
                        "scriptSig": hex_bytes(&tx.vin[input_index].script_sig),
                        "sequence": tx.vin[input_index].sequence,
                        "error": "redeemScript not available for this input",
                    }));
                    continue;
                };

                if let Some((required, pubkeys)) =
                    parse_multisig_redeem_script_with_required(&redeem_script)
                {
                    let sighash = match signature_hash(
                        &tx,
                        Some(input_index),
                        &redeem_script,
                        prevout.value,
                        sighash_type,
                        branch_id,
                    ) {
                        Ok(hash) => hash,
                        Err(err) => {
                            errors.push(json!({
                                "txid": hash256_to_hex(&outpoint.hash),
                                "vout": outpoint.index,
                                "scriptSig": hex_bytes(&tx.vin[input_index].script_sig),
                                "sequence": tx.vin[input_index].sequence,
                                "error": format!("sighash failed: {err}"),
                            }));
                            continue;
                        }
                    };
                    let msg = Message::from_digest_slice(&sighash)
                        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "Invalid sighash digest"))?;

                    let mut signatures = Vec::new();
                    for pubkey in pubkeys {
                        let secret = match key_overrides_by_pubkey.get(&pubkey.serialize()) {
                            Some(secret) => Some(secret.clone()),
                            None => wallet_signing_key_for_pubkey(&pubkey)?,
                        };
                        let Some(secret) = secret else {
                            continue;
                        };
                        let mut sig = secp.sign_ecdsa(&msg, &secret);
                        sig.normalize_s();
                        let mut sig_bytes = sig.serialize_der().as_ref().to_vec();
                        sig_bytes.push(sighash_type.0 as u8);
                        signatures.push(sig_bytes);
                        if signatures.len() == required {
                            break;
                        }
                    }

                    let mut script_sig = Vec::new();
                    script_sig.push(0x00);
                    for sig in &signatures {
                        push_script_bytes(&mut script_sig, sig)?;
                    }
                    push_script_bytes(&mut script_sig, &redeem_script)?;
                    if let Some(input) = tx.vin.get_mut(input_index) {
                        input.script_sig = script_sig;
                    }

                    if signatures.len() != required {
                        errors.push(json!({
                            "txid": hash256_to_hex(&outpoint.hash),
                            "vout": outpoint.index,
                            "scriptSig": hex_bytes(&tx.vin[input_index].script_sig),
                            "sequence": tx.vin[input_index].sequence,
                            "error": format!("Not enough signatures (got {}, need {})", signatures.len(), required),
                        }));
                        continue;
                    }

                    if let Err(err) = verify_script(
                        &tx.vin[input_index].script_sig,
                        &prevout.script_pubkey,
                        &tx,
                        input_index,
                        prevout.value,
                        STANDARD_SCRIPT_VERIFY_FLAGS,
                        branch_id,
                    ) {
                        errors.push(json!({
                            "txid": hash256_to_hex(&outpoint.hash),
                            "vout": outpoint.index,
                            "scriptSig": hex_bytes(&tx.vin[input_index].script_sig),
                            "sequence": tx.vin[input_index].sequence,
                            "error": format!("script verification failed: {err}"),
                        }));
                    }
                    continue;
                }

                if classify_script_pubkey(&redeem_script) == ScriptType::P2Pkh {
                    let (secret, pubkey_bytes) = match key_overrides.get(redeem_script.as_slice()) {
                        Some((secret, pubkey)) => (secret.clone(), pubkey.clone()),
                        None => match wallet_signing_key_for_script_pubkey(&redeem_script)? {
                            Some((secret, pubkey)) => (secret, pubkey),
                            None => {
                                errors.push(json!({
                                    "txid": hash256_to_hex(&outpoint.hash),
                                    "vout": outpoint.index,
                                    "scriptSig": hex_bytes(&tx.vin[input_index].script_sig),
                                    "sequence": tx.vin[input_index].sequence,
                                    "error": "Private key not available for this input",
                                }));
                                continue;
                            }
                        },
                    };

                    let sighash = match signature_hash(
                        &tx,
                        Some(input_index),
                        &redeem_script,
                        prevout.value,
                        sighash_type,
                        branch_id,
                    ) {
                        Ok(hash) => hash,
                        Err(err) => {
                            errors.push(json!({
                                "txid": hash256_to_hex(&outpoint.hash),
                                "vout": outpoint.index,
                                "scriptSig": hex_bytes(&tx.vin[input_index].script_sig),
                                "sequence": tx.vin[input_index].sequence,
                                "error": format!("sighash failed: {err}"),
                            }));
                            continue;
                        }
                    };

                    let msg = Message::from_digest_slice(&sighash)
                        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "Invalid sighash digest"))?;
                    let mut sig = secp.sign_ecdsa(&msg, &secret);
                    sig.normalize_s();
                    let mut sig_bytes = sig.serialize_der().as_ref().to_vec();
                    sig_bytes.push(sighash_type.0 as u8);

                    let mut script_sig = Vec::new();
                    push_script_bytes(&mut script_sig, &sig_bytes)?;
                    push_script_bytes(&mut script_sig, &pubkey_bytes)?;
                    push_script_bytes(&mut script_sig, &redeem_script)?;
                    if let Some(input) = tx.vin.get_mut(input_index) {
                        input.script_sig = script_sig;
                    }

                    if let Err(err) = verify_script(
                        &tx.vin[input_index].script_sig,
                        &prevout.script_pubkey,
                        &tx,
                        input_index,
                        prevout.value,
                        STANDARD_SCRIPT_VERIFY_FLAGS,
                        branch_id,
                    ) {
                        errors.push(json!({
                            "txid": hash256_to_hex(&outpoint.hash),
                            "vout": outpoint.index,
                            "scriptSig": hex_bytes(&tx.vin[input_index].script_sig),
                            "sequence": tx.vin[input_index].sequence,
                            "error": format!("script verification failed: {err}"),
                        }));
                    }
                    continue;
                }

                errors.push(json!({
                    "txid": hash256_to_hex(&outpoint.hash),
                    "vout": outpoint.index,
                    "scriptSig": hex_bytes(&tx.vin[input_index].script_sig),
                    "sequence": tx.vin[input_index].sequence,
                    "error": "Unsupported redeemScript type",
                }));
            }
            _ => {
                errors.push(json!({
                    "txid": hash256_to_hex(&outpoint.hash),
                    "vout": outpoint.index,
                    "scriptSig": hex_bytes(&tx.vin[input_index].script_sig),
                    "sequence": tx.vin[input_index].sequence,
                    "error": "Unsupported scriptPubKey type",
                }));
            }
        }
    }

    let encoded = tx.consensus_encode().map_err(map_internal)?;
    let mut out = serde_json::Map::new();
    out.insert("hex".to_string(), Value::String(hex_bytes(&encoded)));
    out.insert("complete".to_string(), Value::Bool(errors.is_empty()));
    if !errors.is_empty() {
        out.insert("errors".to_string(), Value::Array(errors));
    }
    Ok(Value::Object(out))
}

fn compact_size_len(value: usize) -> usize {
    if value < 0xfd {
        1
    } else if value <= 0xffff {
        3
    } else if value <= 0xffff_ffff {
        5
    } else {
        9
    }
}

fn is_unspendable(script_pubkey: &[u8]) -> bool {
    const OP_RETURN: u8 = 0x6a;
    script_pubkey.first().copied() == Some(OP_RETURN)
}

fn is_dust(value: i64, script_pubkey: &[u8], min_fee_per_kb: i64) -> bool {
    if min_fee_per_kb <= 0 {
        return false;
    }
    if is_unspendable(script_pubkey) {
        return false;
    }
    if value < 0 {
        return true;
    }
    let out_size = 8usize
        .saturating_add(compact_size_len(script_pubkey.len()))
        .saturating_add(script_pubkey.len());
    let spend_size = out_size.saturating_add(148);
    let fee = MempoolPolicy::standard(min_fee_per_kb, false).min_relay_fee_for_size(spend_size);
    let dust_threshold = fee.saturating_mul(3);
    value < dust_threshold
}

fn estimate_signed_tx_size(tx: &Transaction, scriptsig_len: usize) -> Result<usize, RpcError> {
    let mut tmp = tx.clone();
    for input in &mut tmp.vin {
        let target_len = scriptsig_len.max(input.script_sig.len());
        input.script_sig = vec![0u8; target_len];
    }
    Ok(tmp.consensus_encode().map_err(map_internal)?.len())
}

fn pushdata_prefix_len(len: usize) -> usize {
    const OP_PUSHDATA1: usize = 0x4c;
    const OP_PUSHDATA2: usize = 0x4d;

    if len < OP_PUSHDATA1 {
        1
    } else if len <= u8::MAX as usize {
        2
    } else if len <= u16::MAX as usize {
        3
    } else {
        5
    }
}

fn estimate_signed_tx_size_with_prevouts(
    tx: &Transaction,
    prevouts: &HashMap<OutPoint, PrevoutInfo>,
) -> Result<usize, RpcError> {
    const P2PKH_SCRIPTSIG_ESTIMATE: usize = 141;
    const SIGNATURE_PLUS_SIGHASH_LEN: usize = 74;

    let mut tmp = tx.clone();
    for input in &mut tmp.vin {
        if !input.script_sig.is_empty() {
            input.script_sig = vec![0u8; input.script_sig.len()];
            continue;
        }

        let scriptsig_estimate = match prevouts.get(&input.prevout) {
            Some(prevout) => match classify_script_pubkey(&prevout.script_pubkey) {
                ScriptType::P2Pkh => P2PKH_SCRIPTSIG_ESTIMATE,
                ScriptType::P2Sh => match prevout.redeem_script.as_deref() {
                    None => P2PKH_SCRIPTSIG_ESTIMATE,
                    Some(redeem_script) => {
                        if let Some((required, _pubkeys)) =
                            parse_multisig_redeem_script_with_required(redeem_script)
                        {
                            1usize
                                .saturating_add(required.saturating_mul(
                                    1usize.saturating_add(SIGNATURE_PLUS_SIGHASH_LEN),
                                ))
                                .saturating_add(pushdata_prefix_len(redeem_script.len()))
                                .saturating_add(redeem_script.len())
                        } else {
                            P2PKH_SCRIPTSIG_ESTIMATE
                                .saturating_add(pushdata_prefix_len(redeem_script.len()))
                                .saturating_add(redeem_script.len())
                        }
                    }
                },
                _ => P2PKH_SCRIPTSIG_ESTIMATE,
            },
            None => P2PKH_SCRIPTSIG_ESTIMATE,
        };

        input.script_sig = vec![0u8; scriptsig_estimate];
    }
    Ok(tmp.consensus_encode().map_err(map_internal)?.len())
}

#[derive(Clone, Default)]
struct FundTransactionControl {
    only_spend_script_pubkey: Option<Vec<u8>>,
    change_script_pubkey: Option<Vec<u8>>,
}

#[derive(Clone)]
struct FundRawTransactionOptions {
    minconf: i32,
    subtract_fee_from_outputs: Vec<usize>,
    change_script_pubkey: Option<Vec<u8>>,
    change_position: Option<i32>,
    lock_unspents: bool,
    include_watching: bool,
}

impl Default for FundRawTransactionOptions {
    fn default() -> Self {
        Self {
            minconf: 1,
            subtract_fee_from_outputs: Vec::new(),
            change_script_pubkey: None,
            change_position: None,
            lock_unspents: false,
            include_watching: false,
        }
    }
}

fn parse_fundrawtransaction_options(
    value: &Value,
    chain_params: &ChainParams,
) -> Result<FundRawTransactionOptions, RpcError> {
    let obj = value.as_object().ok_or_else(|| {
        RpcError::new(
            RPC_INVALID_PARAMETER,
            "fundrawtransaction options must be an object",
        )
    })?;

    let mut options = FundRawTransactionOptions::default();

    if let Some(value) = obj.get("minconf") {
        if !value.is_null() {
            let minconf_u32 = parse_u32(value, "minconf")?;
            options.minconf = i32::try_from(minconf_u32)
                .map_err(|_| RpcError::new(RPC_INVALID_PARAMETER, "minconf out of range"))?;
        }
    }

    if let Some(value) = obj.get("subtractFeeFromOutputs") {
        if !value.is_null() {
            let arr = value.as_array().ok_or_else(|| {
                RpcError::new(
                    RPC_INVALID_PARAMETER,
                    "subtractFeeFromOutputs must be an array of numbers",
                )
            })?;
            let mut indexes = Vec::with_capacity(arr.len());
            for entry in arr {
                let raw = parse_u32(entry, "subtractFeeFromOutputs")?;
                indexes.push(usize::try_from(raw).map_err(|_| {
                    RpcError::new(RPC_INVALID_PARAMETER, "subtractFeeFromOutputs out of range")
                })?);
            }
            options.subtract_fee_from_outputs = indexes;
        }
    }

    if let Some(value) = obj.get("changeAddress") {
        if !value.is_null() {
            let address = value.as_str().ok_or_else(|| {
                RpcError::new(RPC_INVALID_PARAMETER, "changeAddress must be a string")
            })?;
            let script_pubkey =
                address_to_script_pubkey(address, chain_params.network).map_err(|_| {
                    RpcError::new(
                        RPC_INVALID_ADDRESS_OR_KEY,
                        "Invalid destination Flux address",
                    )
                })?;
            options.change_script_pubkey = Some(script_pubkey);
        }
    }

    if let Some(value) = obj.get("changePosition") {
        if !value.is_null() {
            let raw = parse_i64(value, "changePosition")?;
            if raw < -1 {
                return Err(RpcError::new(
                    RPC_INVALID_PARAMETER,
                    "changePosition out of range",
                ));
            }
            let pos = i32::try_from(raw)
                .map_err(|_| RpcError::new(RPC_INVALID_PARAMETER, "changePosition out of range"))?;
            options.change_position = Some(pos);
        }
    }

    if let Some(value) = obj.get("lockUnspents") {
        if !value.is_null() {
            options.lock_unspents = parse_bool(value)?;
        }
    }

    if let Some(value) = obj.get("includeWatching") {
        if !value.is_null() {
            options.include_watching = parse_bool(value)?;
        }
    }

    Ok(options)
}

fn rpc_fundrawtransaction<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    mempool: &Mutex<Mempool>,
    mempool_policy: &MempoolPolicy,
    fee_estimator: &Mutex<FeeEstimator>,
    tx_confirm_target: u32,
    wallet: &Mutex<Wallet>,
    params: Vec<Value>,
    chain_params: &ChainParams,
    fund_control: FundTransactionControl,
) -> Result<Value, RpcError> {
    if params.is_empty() || params.len() > 2 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "fundrawtransaction expects 1 or 2 parameters",
        ));
    }
    let hex = params[0]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "hexstring must be a string"))?;
    let options = match params.get(1) {
        None | Some(Value::Null) => FundRawTransactionOptions::default(),
        Some(value) => parse_fundrawtransaction_options(value, chain_params)?,
    };
    fundrawtransaction_with_options(
        chainstate,
        mempool,
        mempool_policy,
        fee_estimator,
        tx_confirm_target,
        wallet,
        hex,
        options,
        chain_params,
        fund_control,
    )
}

fn fundrawtransaction_with_options<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    mempool: &Mutex<Mempool>,
    mempool_policy: &MempoolPolicy,
    fee_estimator: &Mutex<FeeEstimator>,
    tx_confirm_target: u32,
    wallet: &Mutex<Wallet>,
    hex: &str,
    options: FundRawTransactionOptions,
    chain_params: &ChainParams,
    fund_control: FundTransactionControl,
) -> Result<Value, RpcError> {
    let raw = bytes_from_hex(hex)
        .ok_or_else(|| RpcError::new(RPC_DESERIALIZATION_ERROR, "TX decode failed"))?;
    let mut tx = Transaction::consensus_decode(&raw)
        .map_err(|_| RpcError::new(RPC_DESERIALIZATION_ERROR, "TX decode failed"))?;
    if tx.fluxnode.is_some()
        || tx.version == FLUXNODE_TX_VERSION
        || tx.version == FLUXNODE_TX_UPGRADEABLE_VERSION
    {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "fundrawtransaction does not support fluxnode transactions",
        ));
    }

    let FundRawTransactionOptions {
        minconf,
        subtract_fee_from_outputs,
        change_script_pubkey: requested_change_script_pubkey,
        change_position,
        lock_unspents,
        include_watching,
    } = options;
    if minconf < 0 {
        return Err(RpcError::new(RPC_INVALID_PARAMETER, "minconf out of range"));
    }

    let recipient_vout_len = tx.vout.len();
    let recipient_value = tx.vout.iter().try_fold(0i64, |total, output| {
        total
            .checked_add(output.value)
            .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "value out of range"))
    })?;

    let requested_change_position = change_position.filter(|pos| *pos >= 0);
    if let Some(pos) = requested_change_position {
        let pos_usize = usize::try_from(pos)
            .map_err(|_| RpcError::new(RPC_INVALID_PARAMETER, "changePosition out of range"))?;
        if pos_usize > recipient_vout_len {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                "changePosition out of range",
            ));
        }
        if !subtract_fee_from_outputs.is_empty() && pos_usize != recipient_vout_len {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                "changePosition cannot be used with subtractFeeFromOutputs",
            ));
        }
    }

    let subtract_fee_from_outputs = {
        let mut seen = HashSet::new();
        for &index in &subtract_fee_from_outputs {
            if index >= recipient_vout_len {
                return Err(RpcError::new(
                    RPC_INVALID_PARAMETER,
                    "subtractFeeFromOutputs out of range",
                ));
            }
            if !seen.insert(index) {
                return Err(RpcError::new(
                    RPC_INVALID_PARAMETER,
                    "subtractFeeFromOutputs contains duplicate indices",
                ));
            }
        }
        subtract_fee_from_outputs
    };

    let mut used_outpoints: HashSet<OutPoint> = HashSet::new();
    let mut base_inputs_value: i64 = 0;
    let mut prevouts: HashMap<OutPoint, PrevoutInfo> = HashMap::new();
    let base_prevtxs = HashMap::new();
    for input in &tx.vin {
        if !used_outpoints.insert(input.prevout.clone()) {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                "transaction has duplicate inputs",
            ));
        }
        let mut prevout = resolve_prevout_info(chainstate, mempool, &input.prevout, &base_prevtxs)?
            .ok_or_else(|| RpcError::new(RPC_TRANSACTION_ERROR, "Missing inputs"))?;

        if input.script_sig.is_empty() {
            match classify_script_pubkey(&prevout.script_pubkey) {
                ScriptType::P2Pkh => {}
                ScriptType::P2Sh => {
                    let redeem_script = wallet
                        .lock()
                        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?
                        .redeem_script_for_p2sh_script_pubkey(&prevout.script_pubkey);
                    if redeem_script.is_none() {
                        return Err(RpcError::new(
                            RPC_INVALID_PARAMETER,
                            "fundrawtransaction requires redeemScript for unsigned P2SH inputs",
                        ));
                    }
                    prevout.redeem_script = redeem_script;
                }
                _ => {
                    return Err(RpcError::new(
                        RPC_INVALID_PARAMETER,
                        "fundrawtransaction only supports unsigned P2PKH inputs",
                    ))
                }
            }
        }
        base_inputs_value = base_inputs_value
            .checked_add(prevout.value)
            .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "value out of range"))?;
        prevouts.insert(input.prevout.clone(), prevout);
    }

    let (wallet_scripts, pay_tx_fee_per_kb, locked_outpoints, change_ok) = {
        let guard = wallet
            .lock()
            .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;
        let pay_tx_fee_per_kb = guard.pay_tx_fee_per_kb();
        let scripts = if include_watching {
            guard
                .all_script_pubkeys_including_watchonly()
                .map_err(map_wallet_error)?
        } else {
            guard.all_script_pubkeys().map_err(map_wallet_error)?
        };
        let filter_ok = fund_control
            .only_spend_script_pubkey
            .as_ref()
            .map(|script| scripts.iter().any(|owned| owned == script))
            .unwrap_or(false);
        let change_ok = fund_control
            .change_script_pubkey
            .as_ref()
            .map(|script| scripts.iter().any(|owned| owned == script))
            .unwrap_or(false);

        let wallet_scripts = match fund_control.only_spend_script_pubkey.as_ref() {
            Some(script) if filter_ok => vec![script.clone()],
            Some(_) => Vec::new(),
            None => scripts,
        };
        let locked_outpoints = guard.locked_outpoints();
        (
            wallet_scripts,
            pay_tx_fee_per_kb,
            locked_outpoints,
            change_ok,
        )
    };
    let locked_set: HashSet<OutPoint> = locked_outpoints.into_iter().collect();
    let change_script_pubkey = if change_ok {
        fund_control
            .change_script_pubkey
            .clone()
            .or(requested_change_script_pubkey)
    } else {
        requested_change_script_pubkey
    };
    let placeholder_key_hash = [0u8; 20];
    let placeholder_change_script_pubkey = p2pkh_script_pubkey(&placeholder_key_hash);

    const DEFAULT_MIN_TX_FEE_PER_KB: i64 = 1000;
    const DEFAULT_MAX_TX_FEE: i64 = COIN / 10;

    let tx_confirm_target = tx_confirm_target.max(1);
    let estimated_fee_per_kb = fee_estimator
        .lock()
        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "fee estimator lock poisoned"))?
        .estimate_fee_per_kb(tx_confirm_target)
        .unwrap_or(0);

    let fee_for_size = |size: usize| -> Result<i64, RpcError> {
        let base_fee_rate_per_kb = if pay_tx_fee_per_kb > 0 {
            pay_tx_fee_per_kb
        } else if estimated_fee_per_kb > 0 {
            estimated_fee_per_kb
        } else {
            DEFAULT_MIN_TX_FEE_PER_KB
        };

        let size_i64 = i64::try_from(size).unwrap_or(i64::MAX);
        let mut fee = 0i64;
        if base_fee_rate_per_kb > 0 {
            fee = base_fee_rate_per_kb
                .saturating_mul(size_i64)
                .saturating_div(1000);
            if fee == 0 {
                fee = base_fee_rate_per_kb;
            }
        }

        let min_relay_fee = mempool_policy.min_relay_fee_for_size(size);
        fee = fee.max(min_relay_fee);
        if fee > DEFAULT_MAX_TX_FEE {
            fee = DEFAULT_MAX_TX_FEE;
        }
        if fee < min_relay_fee {
            return Err(RpcError::new(
                RPC_INTERNAL_ERROR,
                "Transaction too large for fee policy",
            ));
        }
        Ok(fee)
    };

    let mut candidates = collect_wallet_utxos(chainstate, mempool, &wallet_scripts, false)?;
    candidates.retain(|utxo| {
        if used_outpoints.contains(&utxo.outpoint) {
            return false;
        }
        if locked_set.contains(&utxo.outpoint) {
            return false;
        }
        if utxo.is_coinbase && utxo.confirmations < COINBASE_MATURITY {
            return false;
        }
        if utxo.confirmations < minconf {
            return false;
        }
        utxo.value > 0
    });
    candidates.sort_by(|a, b| {
        a.value
            .cmp(&b.value)
            .then_with(|| a.confirmations.cmp(&b.confirmations))
            .then_with(|| a.outpoint.hash.cmp(&b.outpoint.hash))
            .then_with(|| a.outpoint.index.cmp(&b.outpoint.index))
    });

    let mut selected_value: i64 = 0;
    let mut change_pos: i32 = -1;
    let mut locked_inputs: Vec<OutPoint> = Vec::new();

    let mut fee = 0i64;

    for _ in 0..512 {
        let estimated_size = estimate_signed_tx_size_with_prevouts(&tx, &prevouts)?;
        let target_fee = fee_for_size(estimated_size)?;
        if target_fee > fee {
            fee = target_fee;
        }

        let required = if subtract_fee_from_outputs.is_empty() {
            recipient_value
                .checked_add(fee)
                .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "value out of range"))?
        } else {
            recipient_value
        };
        let total_inputs = base_inputs_value
            .checked_add(selected_value)
            .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "value out of range"))?;

        if total_inputs < required {
            let next = candidates
                .pop()
                .ok_or_else(|| RpcError::new(RPC_WALLET_ERROR, "insufficient funds"))?;
            used_outpoints.insert(next.outpoint.clone());
            selected_value = selected_value
                .checked_add(next.value)
                .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "value out of range"))?;
            let redeem_script = if classify_script_pubkey(&next.script_pubkey) == ScriptType::P2Sh {
                wallet
                    .lock()
                    .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?
                    .redeem_script_for_p2sh_script_pubkey(&next.script_pubkey)
            } else {
                None
            };
            prevouts.insert(
                next.outpoint.clone(),
                PrevoutInfo {
                    value: next.value,
                    script_pubkey: next.script_pubkey.clone(),
                    redeem_script,
                },
            );
            locked_inputs.push(next.outpoint.clone());
            tx.vin.push(TxIn {
                prevout: next.outpoint,
                script_sig: Vec::new(),
                sequence: u32::MAX - 1,
            });
            fee = fee_for_size(estimate_signed_tx_size_with_prevouts(&tx, &prevouts)?)?;
            continue;
        }

        let mut change = total_inputs
            .checked_sub(required)
            .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "value out of range"))?;
        let change_script_for_change = change_script_pubkey
            .as_ref()
            .unwrap_or(&placeholder_change_script_pubkey);
        let include_change = change > 0
            && !is_dust(
                change,
                change_script_for_change,
                mempool_policy.min_relay_fee_per_kb,
            );
        if change > 0 && !include_change && tx.vout.len() == recipient_vout_len + 1 {
            tx.vout.pop();
        }
        if change > 0 && !include_change {
            fee = fee
                .checked_add(change)
                .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "value out of range"))?;
            change = 0;
        }

        if change == 0 {
            if tx.vout.len() == recipient_vout_len + 1 {
                tx.vout.pop();
            }
            change_pos = -1;
        } else if include_change {
            if tx.vout.len() == recipient_vout_len {
                tx.vout.push(TxOut {
                    value: change,
                    script_pubkey: change_script_for_change.clone(),
                });
                change_pos = recipient_vout_len as i32;
            } else if tx.vout.len() == recipient_vout_len + 1 {
                if let Some(out) = tx.vout.get_mut(recipient_vout_len) {
                    out.value = change;
                }
            }
        }

        let new_fee = fee_for_size(estimate_signed_tx_size_with_prevouts(&tx, &prevouts)?)?;
        if new_fee > fee {
            fee = new_fee;
            continue;
        }
        break;
    }

    if !subtract_fee_from_outputs.is_empty() && fee > 0 {
        let split = i64::try_from(subtract_fee_from_outputs.len()).map_err(|_| {
            RpcError::new(RPC_INVALID_PARAMETER, "subtractFeeFromOutputs out of range")
        })?;
        if split <= 0 {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                "subtractFeeFromOutputs is empty",
            ));
        }

        let per_output = fee / split;
        let remainder = fee % split;
        for (pos, output_index) in subtract_fee_from_outputs.iter().enumerate() {
            let extra = if (pos as i64) < remainder { 1 } else { 0 };
            let to_subtract = per_output
                .checked_add(extra)
                .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "value out of range"))?;
            let out = tx.vout.get_mut(*output_index).ok_or_else(|| {
                RpcError::new(RPC_INVALID_PARAMETER, "subtractFeeFromOutputs out of range")
            })?;
            out.value = out.value.checked_sub(to_subtract).ok_or_else(|| {
                RpcError::new(
                    RPC_INVALID_PARAMETER,
                    "Transaction amount too small to pay the fee",
                )
            })?;
            if out.value <= 0 {
                return Err(RpcError::new(
                    RPC_INVALID_PARAMETER,
                    "Transaction amount too small to pay the fee",
                ));
            }
            if mempool_policy.require_standard
                && is_dust(
                    out.value,
                    &out.script_pubkey,
                    mempool_policy.min_relay_fee_per_kb,
                )
            {
                return Err(RpcError::new(RPC_INVALID_PARAMETER, "dust"));
            }
        }
    }

    let final_outputs_value = tx.vout.iter().try_fold(0i64, |total, output| {
        total
            .checked_add(output.value)
            .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "value out of range"))
    })?;
    let total_inputs = base_inputs_value
        .checked_add(selected_value)
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "value out of range"))?;
    let final_fee = total_inputs
        .checked_sub(final_outputs_value)
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "value out of range"))?;
    if final_fee < 0 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "outputs exceed inputs",
        ));
    }

    if subtract_fee_from_outputs.is_empty()
        && change_pos >= 0
        && tx.vout.len() == recipient_vout_len + 1
    {
        let desired = requested_change_position.map(|pos| pos as usize);
        let new_pos = if let Some(pos) = desired {
            pos
        } else {
            let mut rng = rand::thread_rng();
            (rng.next_u32() as usize) % (recipient_vout_len + 1)
        };
        let old_pos = usize::try_from(change_pos)
            .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "change position out of range"))?;
        if new_pos != old_pos {
            let change_output = tx.vout.remove(old_pos);
            tx.vout.insert(new_pos, change_output);
            change_pos = i32::try_from(new_pos)
                .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "change position out of range"))?;
        }
    } else if change_pos >= 0
        && tx.vout.len() == recipient_vout_len + 1
        && requested_change_position.is_some()
    {
        let pos = requested_change_position
            .map(|pos| pos as usize)
            .unwrap_or(recipient_vout_len);
        let old_pos = usize::try_from(change_pos)
            .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "change position out of range"))?;
        if pos != old_pos {
            let change_output = tx.vout.remove(old_pos);
            tx.vout.insert(pos, change_output);
            change_pos = i32::try_from(pos)
                .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "change position out of range"))?;
        }
    }

    let needs_change_address = change_pos >= 0
        && tx.vout.len() == recipient_vout_len + 1
        && change_script_pubkey.is_none();
    if needs_change_address || (lock_unspents && !locked_inputs.is_empty()) {
        let mut guard = wallet
            .lock()
            .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;
        if needs_change_address {
            let change_address = guard
                .generate_new_change_address(true)
                .map_err(map_wallet_error)?;
            let change_script = address_to_script_pubkey(&change_address, chain_params.network)
                .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "invalid change address"))?;
            let change_index = usize::try_from(change_pos)
                .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "change position out of range"))?;
            let out = tx
                .vout
                .get_mut(change_index)
                .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "change output missing"))?;
            out.script_pubkey = change_script;
        }
        if lock_unspents {
            for outpoint in locked_inputs {
                guard.lock_outpoint(outpoint);
            }
        }
    }

    let encoded = tx.consensus_encode().map_err(map_internal)?;
    Ok(json!({
        "hex": hex_bytes(&encoded),
        "fee": amount_to_value(final_fee),
        "fee_zat": final_fee,
        "changepos": change_pos,
    }))
}

fn wallet_tx_lock_time(best_height: i32) -> u32 {
    let mut lock_time = best_height.saturating_sub(10).max(0) as u32;
    let mut rng = rand::thread_rng();
    if rng.next_u32() % 10 == 0 {
        let back = (rng.next_u32() % 100) as u32;
        lock_time = lock_time.saturating_sub(back);
    }
    lock_time
}

fn rpc_sendfrom<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    mempool: &Mutex<Mempool>,
    mempool_policy: &MempoolPolicy,
    mempool_metrics: &MempoolMetrics,
    fee_estimator: &Mutex<FeeEstimator>,
    tx_confirm_target: u32,
    mempool_flags: &ValidationFlags,
    wallet: &Mutex<Wallet>,
    params: Vec<Value>,
    chain_params: &ChainParams,
    tx_announce: &broadcast::Sender<Hash256>,
) -> Result<Value, RpcError> {
    const DEFAULT_TX_EXPIRY_DELTA: u32 = 20;

    if params.len() < 3 || params.len() > 6 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "sendfrom expects 3 to 6 parameters",
        ));
    }
    let from_account = params[0]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "fromaccount must be a string"))?;
    let address = params[1]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "address must be a string"))?;
    let amount = parse_amount(&params[2])?;
    if amount <= 0 {
        return Err(RpcError::new(RPC_TYPE_ERROR, "Invalid amount for send"));
    }

    let minconf = match params.get(3) {
        Some(value) if !value.is_null() => parse_u32(value, "minconf")?,
        _ => 1,
    };
    if let Some(value) = params.get(4) {
        if !value.is_null() && value.as_str().is_none() {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                "comment must be a string",
            ));
        }
    }
    if let Some(value) = params.get(5) {
        if !value.is_null() && value.as_str().is_none() {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                "comment_to must be a string",
            ));
        }
    }

    let comment = params
        .get(4)
        .and_then(|value| value.as_str())
        .map(|value| value.to_string())
        .filter(|value| !value.is_empty());
    let comment_to = params
        .get(5)
        .and_then(|value| value.as_str())
        .map(|value| value.to_string())
        .filter(|value| !value.is_empty());
    let mut tx_values = std::collections::BTreeMap::new();
    if let Some(comment) = comment {
        tx_values.insert("comment".to_string(), comment);
    }
    if let Some(comment_to) = comment_to {
        tx_values.insert("to".to_string(), comment_to);
    }

    let script_pubkey = address_to_script_pubkey(address, chain_params.network).map_err(|_| {
        RpcError::new(
            RPC_INVALID_ADDRESS_OR_KEY,
            "Invalid destination Flux address",
        )
    })?;
    if mempool_policy.require_standard
        && is_dust(amount, &script_pubkey, mempool_policy.min_relay_fee_per_kb)
    {
        return Err(RpcError::new(RPC_INVALID_PARAMETER, "dust"));
    }

    let fund_control = if from_account.is_empty() {
        FundTransactionControl::default()
    } else {
        let from_script =
            address_to_script_pubkey(from_account, chain_params.network).map_err(|_| {
                RpcError::new(
                    RPC_INVALID_ADDRESS_OR_KEY,
                    "Invalid fromaccount Flux address",
                )
            })?;
        FundTransactionControl {
            only_spend_script_pubkey: Some(from_script.clone()),
            change_script_pubkey: Some(from_script),
        }
    };

    let next_height = chainstate
        .best_block()
        .map_err(map_internal)?
        .map(|tip| tip.height.saturating_add(1))
        .unwrap_or(1);
    let sapling_active = network_upgrade_active(
        next_height,
        &chain_params.consensus.upgrades,
        UpgradeIndex::Acadia,
    );
    let lock_time = wallet_tx_lock_time(next_height.saturating_sub(1));

    let tx = Transaction {
        f_overwintered: sapling_active,
        version: if sapling_active { 4 } else { 1 },
        version_group_id: if sapling_active {
            SAPLING_VERSION_GROUP_ID
        } else {
            0
        },
        vin: Vec::new(),
        vout: vec![TxOut {
            value: amount,
            script_pubkey,
        }],
        lock_time,
        expiry_height: if sapling_active {
            (next_height as u32).saturating_add(DEFAULT_TX_EXPIRY_DELTA)
        } else {
            0
        },
        value_balance: 0,
        shielded_spends: Vec::new(),
        shielded_outputs: Vec::new(),
        join_splits: Vec::new(),
        join_split_pub_key: [0u8; 32],
        join_split_sig: [0u8; 64],
        binding_sig: [0u8; 64],
        fluxnode: None,
    };

    let unsigned_hex = hex_bytes(&tx.consensus_encode().map_err(map_internal)?);

    let minconf_i32 = i32::try_from(minconf)
        .map_err(|_| RpcError::new(RPC_INVALID_PARAMETER, "minconf out of range"))?;
    let funded = fundrawtransaction_with_options(
        chainstate,
        mempool,
        mempool_policy,
        fee_estimator,
        tx_confirm_target,
        wallet,
        &unsigned_hex,
        FundRawTransactionOptions {
            minconf: minconf_i32,
            ..FundRawTransactionOptions::default()
        },
        chain_params,
        fund_control,
    )?;
    let funded_hex = funded
        .get("hex")
        .and_then(Value::as_str)
        .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "fundrawtransaction returned no hex"))?
        .to_string();

    let signed = rpc_signrawtransaction(
        chainstate,
        mempool,
        wallet,
        vec![Value::String(funded_hex)],
        chain_params,
    )?;
    let signed_obj = signed.as_object().ok_or_else(|| {
        RpcError::new(RPC_INTERNAL_ERROR, "signrawtransaction returned no object")
    })?;
    let complete = signed_obj
        .get("complete")
        .and_then(Value::as_bool)
        .unwrap_or(false);
    if !complete {
        return Err(RpcError::new(
            RPC_WALLET_ERROR,
            "transaction could not be fully signed",
        ));
    }
    let signed_hex = signed_obj
        .get("hex")
        .and_then(Value::as_str)
        .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "signrawtransaction returned no hex"))?
        .to_string();
    let signed_bytes = bytes_from_hex(&signed_hex).ok_or_else(|| {
        RpcError::new(
            RPC_INTERNAL_ERROR,
            "signrawtransaction returned invalid hex",
        )
    })?;

    rpc_sendrawtransaction(
        chainstate,
        mempool,
        mempool_policy,
        mempool_metrics,
        fee_estimator,
        mempool_flags,
        vec![Value::String(signed_hex)],
        chain_params,
        tx_announce,
    )
    .and_then(move |txid_value| {
        let txid = parse_hash(&txid_value)?;
        wallet
            .lock()
            .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?
            .record_transaction_with_values(txid, signed_bytes, tx_values)
            .map_err(map_wallet_error)?;
        Ok(txid_value)
    })
}

pub(crate) fn rpc_sendtoaddress<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    mempool: &Mutex<Mempool>,
    mempool_policy: &MempoolPolicy,
    mempool_metrics: &MempoolMetrics,
    fee_estimator: &Mutex<FeeEstimator>,
    tx_confirm_target: u32,
    mempool_flags: &ValidationFlags,
    wallet: &Mutex<Wallet>,
    params: Vec<Value>,
    chain_params: &ChainParams,
    tx_announce: &broadcast::Sender<Hash256>,
) -> Result<Value, RpcError> {
    const DEFAULT_TX_EXPIRY_DELTA: u32 = 20;

    if params.len() < 2 || params.len() > 5 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "sendtoaddress expects 2 to 5 parameters",
        ));
    }
    let address = params[0]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "address must be a string"))?;
    let amount = parse_amount(&params[1])?;
    if amount <= 0 {
        return Err(RpcError::new(RPC_TYPE_ERROR, "Invalid amount for send"));
    }

    if let Some(value) = params.get(2) {
        if !value.is_null() && value.as_str().is_none() {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                "comment must be a string",
            ));
        }
    }
    if let Some(value) = params.get(3) {
        if !value.is_null() && value.as_str().is_none() {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                "comment_to must be a string",
            ));
        }
    }

    let comment = params
        .get(2)
        .and_then(|value| value.as_str())
        .map(|value| value.to_string())
        .filter(|value| !value.is_empty());
    let comment_to = params
        .get(3)
        .and_then(|value| value.as_str())
        .map(|value| value.to_string())
        .filter(|value| !value.is_empty());
    let mut tx_values = std::collections::BTreeMap::new();
    if let Some(comment) = comment {
        tx_values.insert("comment".to_string(), comment);
    }
    if let Some(comment_to) = comment_to {
        tx_values.insert("to".to_string(), comment_to);
    }

    let subtract_fee = match params.get(4) {
        Some(value) if !value.is_null() => parse_bool(value)?,
        _ => false,
    };

    let script_pubkey = address_to_script_pubkey(address, chain_params.network)
        .map_err(|_| RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "Invalid Flux address"))?;
    if mempool_policy.require_standard
        && is_dust(amount, &script_pubkey, mempool_policy.min_relay_fee_per_kb)
    {
        return Err(RpcError::new(RPC_INVALID_PARAMETER, "dust"));
    }

    let next_height = chainstate
        .best_block()
        .map_err(map_internal)?
        .map(|tip| tip.height.saturating_add(1))
        .unwrap_or(1);
    let sapling_active = network_upgrade_active(
        next_height,
        &chain_params.consensus.upgrades,
        UpgradeIndex::Acadia,
    );
    let lock_time = wallet_tx_lock_time(next_height.saturating_sub(1));

    let tx = Transaction {
        f_overwintered: sapling_active,
        version: if sapling_active { 4 } else { 1 },
        version_group_id: if sapling_active {
            SAPLING_VERSION_GROUP_ID
        } else {
            0
        },
        vin: Vec::new(),
        vout: vec![TxOut {
            value: amount,
            script_pubkey,
        }],
        lock_time,
        expiry_height: if sapling_active {
            (next_height as u32).saturating_add(DEFAULT_TX_EXPIRY_DELTA)
        } else {
            0
        },
        value_balance: 0,
        shielded_spends: Vec::new(),
        shielded_outputs: Vec::new(),
        join_splits: Vec::new(),
        join_split_pub_key: [0u8; 32],
        join_split_sig: [0u8; 64],
        binding_sig: [0u8; 64],
        fluxnode: None,
    };

    let unsigned_hex = hex_bytes(&tx.consensus_encode().map_err(map_internal)?);

    let fund_options = if subtract_fee {
        FundRawTransactionOptions {
            subtract_fee_from_outputs: vec![0],
            ..FundRawTransactionOptions::default()
        }
    } else {
        FundRawTransactionOptions::default()
    };
    let funded = fundrawtransaction_with_options(
        chainstate,
        mempool,
        mempool_policy,
        fee_estimator,
        tx_confirm_target,
        wallet,
        &unsigned_hex,
        fund_options,
        chain_params,
        FundTransactionControl::default(),
    )?;
    let funded_hex = funded
        .get("hex")
        .and_then(Value::as_str)
        .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "fundrawtransaction returned no hex"))?
        .to_string();

    let signed = rpc_signrawtransaction(
        chainstate,
        mempool,
        wallet,
        vec![Value::String(funded_hex)],
        chain_params,
    )?;
    let signed_obj = signed.as_object().ok_or_else(|| {
        RpcError::new(RPC_INTERNAL_ERROR, "signrawtransaction returned no object")
    })?;
    let complete = signed_obj
        .get("complete")
        .and_then(Value::as_bool)
        .unwrap_or(false);
    if !complete {
        return Err(RpcError::new(
            RPC_WALLET_ERROR,
            "transaction could not be fully signed",
        ));
    }
    let signed_hex = signed_obj
        .get("hex")
        .and_then(Value::as_str)
        .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "signrawtransaction returned no hex"))?
        .to_string();
    let signed_bytes = bytes_from_hex(&signed_hex).ok_or_else(|| {
        RpcError::new(
            RPC_INTERNAL_ERROR,
            "signrawtransaction returned invalid hex",
        )
    })?;

    rpc_sendrawtransaction(
        chainstate,
        mempool,
        mempool_policy,
        mempool_metrics,
        fee_estimator,
        mempool_flags,
        vec![Value::String(signed_hex)],
        chain_params,
        tx_announce,
    )
    .and_then(move |txid_value| {
        let txid = parse_hash(&txid_value)?;
        wallet
            .lock()
            .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?
            .record_transaction_with_values(txid, signed_bytes, tx_values)
            .map_err(map_wallet_error)?;
        Ok(txid_value)
    })
}

fn rpc_sendmany<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    mempool: &Mutex<Mempool>,
    mempool_policy: &MempoolPolicy,
    mempool_metrics: &MempoolMetrics,
    fee_estimator: &Mutex<FeeEstimator>,
    tx_confirm_target: u32,
    mempool_flags: &ValidationFlags,
    wallet: &Mutex<Wallet>,
    params: Vec<Value>,
    chain_params: &ChainParams,
    tx_announce: &broadcast::Sender<Hash256>,
) -> Result<Value, RpcError> {
    const DEFAULT_TX_EXPIRY_DELTA: u32 = 20;

    if params.len() < 2 || params.len() > 5 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "sendmany expects 2 to 5 parameters",
        ));
    }
    let from_account = params[0]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "fromaccount must be a string"))?;
    let outputs = params[1]
        .as_object()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "amounts must be a json object"))?;
    if outputs.is_empty() {
        return Err(RpcError::new(RPC_INVALID_PARAMETER, "amounts is empty"));
    }

    let minconf = match params.get(2) {
        Some(value) if !value.is_null() => parse_u32(value, "minconf")?,
        _ => 1,
    };
    if let Some(value) = params.get(3) {
        if !value.is_null() && value.as_str().is_none() {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                "comment must be a string",
            ));
        }
    }
    if let Some(value) = params.get(4) {
        if !value.is_null() {
            if value.as_array().is_none() {
                return Err(RpcError::new(
                    RPC_INVALID_PARAMETER,
                    "subtractfeefrom must be an array",
                ));
            }
        }
    }

    let comment = params
        .get(3)
        .and_then(|value| value.as_str())
        .map(|value| value.to_string())
        .filter(|value| !value.is_empty());
    let mut tx_values = std::collections::BTreeMap::new();
    if let Some(comment) = comment {
        tx_values.insert("comment".to_string(), comment);
    }

    let fund_control = if from_account.is_empty() {
        FundTransactionControl::default()
    } else {
        let from_script =
            address_to_script_pubkey(from_account, chain_params.network).map_err(|_| {
                RpcError::new(
                    RPC_INVALID_ADDRESS_OR_KEY,
                    "Invalid fromaccount Flux address",
                )
            })?;
        FundTransactionControl {
            only_spend_script_pubkey: Some(from_script.clone()),
            change_script_pubkey: Some(from_script),
        }
    };

    let mut subtract_fee_from_outputs: HashSet<String> = HashSet::new();
    if let Some(value) = params.get(4) {
        if let Some(subtract) = value.as_array() {
            for entry in subtract {
                let addr = entry.as_str().ok_or_else(|| {
                    RpcError::new(
                        RPC_INVALID_PARAMETER,
                        "subtractfeefrom entries must be strings",
                    )
                })?;
                if outputs.contains_key(addr) {
                    subtract_fee_from_outputs.insert(addr.to_string());
                }
            }
        }
    }

    let next_height = chainstate
        .best_block()
        .map_err(map_internal)?
        .map(|tip| tip.height.saturating_add(1))
        .unwrap_or(1);
    let sapling_active = network_upgrade_active(
        next_height,
        &chain_params.consensus.upgrades,
        UpgradeIndex::Acadia,
    );
    let lock_time = wallet_tx_lock_time(next_height.saturating_sub(1));

    let mut ordered: Vec<(&String, &Value)> = outputs.iter().collect();
    ordered.sort_by(|(a, _), (b, _)| a.cmp(b));

    let mut vout = Vec::with_capacity(ordered.len());
    let mut subtract_fee_from_vout: Vec<usize> = Vec::new();

    for (address, amount) in ordered {
        let value = parse_amount(amount)?;
        if value <= 0 {
            return Err(RpcError::new(RPC_TYPE_ERROR, "Invalid amount for send"));
        }
        let script_pubkey =
            address_to_script_pubkey(address, chain_params.network).map_err(|_| {
                RpcError::new(
                    RPC_INVALID_ADDRESS_OR_KEY,
                    format!("Invalid Flux address: {address}"),
                )
            })?;
        if mempool_policy.require_standard
            && is_dust(value, &script_pubkey, mempool_policy.min_relay_fee_per_kb)
        {
            return Err(RpcError::new(RPC_INVALID_PARAMETER, "dust"));
        }
        vout.push(TxOut {
            value,
            script_pubkey,
        });
        if subtract_fee_from_outputs.contains(address.as_str()) {
            subtract_fee_from_vout.push(vout.len().saturating_sub(1));
        }
    }

    let tx = Transaction {
        f_overwintered: sapling_active,
        version: if sapling_active { 4 } else { 1 },
        version_group_id: if sapling_active {
            SAPLING_VERSION_GROUP_ID
        } else {
            0
        },
        vin: Vec::new(),
        vout,
        lock_time,
        expiry_height: if sapling_active {
            (next_height as u32).saturating_add(DEFAULT_TX_EXPIRY_DELTA)
        } else {
            0
        },
        value_balance: 0,
        shielded_spends: Vec::new(),
        shielded_outputs: Vec::new(),
        join_splits: Vec::new(),
        join_split_pub_key: [0u8; 32],
        join_split_sig: [0u8; 64],
        binding_sig: [0u8; 64],
        fluxnode: None,
    };

    let unsigned_hex = hex_bytes(&tx.consensus_encode().map_err(map_internal)?);

    let minconf_i32 = i32::try_from(minconf)
        .map_err(|_| RpcError::new(RPC_INVALID_PARAMETER, "minconf out of range"))?;
    let fund_options = FundRawTransactionOptions {
        minconf: minconf_i32,
        subtract_fee_from_outputs: subtract_fee_from_vout,
        ..FundRawTransactionOptions::default()
    };
    let funded = fundrawtransaction_with_options(
        chainstate,
        mempool,
        mempool_policy,
        fee_estimator,
        tx_confirm_target,
        wallet,
        &unsigned_hex,
        fund_options,
        chain_params,
        fund_control,
    )?;
    let funded_hex = funded
        .get("hex")
        .and_then(Value::as_str)
        .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "fundrawtransaction returned no hex"))?
        .to_string();

    let signed = rpc_signrawtransaction(
        chainstate,
        mempool,
        wallet,
        vec![Value::String(funded_hex)],
        chain_params,
    )?;
    let signed_obj = signed.as_object().ok_or_else(|| {
        RpcError::new(RPC_INTERNAL_ERROR, "signrawtransaction returned no object")
    })?;
    let complete = signed_obj
        .get("complete")
        .and_then(Value::as_bool)
        .unwrap_or(false);
    if !complete {
        return Err(RpcError::new(
            RPC_WALLET_ERROR,
            "transaction could not be fully signed",
        ));
    }
    let signed_hex = signed_obj
        .get("hex")
        .and_then(Value::as_str)
        .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "signrawtransaction returned no hex"))?
        .to_string();
    let signed_bytes = bytes_from_hex(&signed_hex).ok_or_else(|| {
        RpcError::new(
            RPC_INTERNAL_ERROR,
            "signrawtransaction returned invalid hex",
        )
    })?;

    rpc_sendrawtransaction(
        chainstate,
        mempool,
        mempool_policy,
        mempool_metrics,
        fee_estimator,
        mempool_flags,
        vec![Value::String(signed_hex)],
        chain_params,
        tx_announce,
    )
    .and_then(move |txid_value| {
        let txid = parse_hash(&txid_value)?;
        wallet
            .lock()
            .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?
            .record_transaction_with_values(txid, signed_bytes, tx_values)
            .map_err(map_wallet_error)?;
        Ok(txid_value)
    })
}

fn submit_raw_transaction<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    mempool: &Mutex<Mempool>,
    mempool_policy: &MempoolPolicy,
    mempool_metrics: &MempoolMetrics,
    fee_estimator: &Mutex<FeeEstimator>,
    mempool_flags: &ValidationFlags,
    chain_params: &ChainParams,
    tx_announce: &broadcast::Sender<Hash256>,
    reject_absurd_fee: bool,
    raw: Vec<u8>,
) -> Result<Hash256, RpcError> {
    const REJECT_INVALID: u8 = 0x10;
    const REJECT_DUPLICATE: u8 = 0x12;
    const REJECT_NONSTANDARD: u8 = 0x40;
    const REJECT_INSUFFICIENTFEE: u8 = 0x42;

    let tx = Transaction::consensus_decode(&raw)
        .map_err(|_| RpcError::new(RPC_DESERIALIZATION_ERROR, "TX decode failed"))?;
    let txid = tx
        .txid()
        .map_err(|_| RpcError::new(RPC_DESERIALIZATION_ERROR, "TX decode failed"))?;

    if chainstate
        .tx_location(&txid)
        .map_err(map_internal)?
        .is_some()
    {
        return Err(RpcError::new(
            RPC_TRANSACTION_ALREADY_IN_CHAIN,
            "transaction already in block chain",
        ));
    }

    let mempool_prevouts = {
        let guard = mempool
            .lock()
            .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "mempool lock poisoned"))?;
        if guard.contains(&txid) {
            let _ = tx_announce.send(txid);
            return Ok(txid);
        }
        for input in &tx.vin {
            if guard.spender(&input.prevout).is_some() {
                return Err(RpcError::new(
                    RPC_TRANSACTION_REJECTED,
                    format!("{REJECT_DUPLICATE}: bad-txns-inputs-spent"),
                ));
            }
        }
        for joinsplit in &tx.join_splits {
            for nullifier in &joinsplit.nullifiers {
                if guard.sprout_nullifier_spender(nullifier).is_some() {
                    return Err(RpcError::new(
                        RPC_TRANSACTION_REJECTED,
                        format!("{REJECT_DUPLICATE}: bad-txns-shielded-requirements-not-met"),
                    ));
                }
            }
        }
        for spend in &tx.shielded_spends {
            if guard.sapling_nullifier_spender(&spend.nullifier).is_some() {
                return Err(RpcError::new(
                    RPC_TRANSACTION_REJECTED,
                    format!("{REJECT_DUPLICATE}: bad-txns-shielded-requirements-not-met"),
                ));
            }
        }
        guard.prevouts_for_tx(&tx)
    };

    let entry = build_mempool_entry(
        chainstate,
        &mempool_prevouts,
        chain_params,
        mempool_flags,
        mempool_policy,
        tx,
        raw,
        false,
    )
    .map_err(|err| match err.kind {
        MempoolErrorKind::MissingInput => RpcError::new(RPC_TRANSACTION_ERROR, "Missing inputs"),
        MempoolErrorKind::ConflictingInput => RpcError::new(
            RPC_TRANSACTION_REJECTED,
            format!("{REJECT_DUPLICATE}: bad-txns-inputs-spent"),
        ),
        MempoolErrorKind::InsufficientFee | MempoolErrorKind::MempoolFull => RpcError::new(
            RPC_TRANSACTION_REJECTED,
            format!("{REJECT_INSUFFICIENTFEE}: {}", err.message),
        ),
        MempoolErrorKind::NonStandard => RpcError::new(
            RPC_TRANSACTION_REJECTED,
            format!("{REJECT_NONSTANDARD}: {}", err.message),
        ),
        MempoolErrorKind::InvalidTransaction
        | MempoolErrorKind::InvalidScript
        | MempoolErrorKind::InvalidShielded => {
            if err.message.starts_with("tx-expiring-soon:") {
                RpcError::new(RPC_TRANSACTION_REJECTED, err.message)
            } else {
                RpcError::new(
                    RPC_TRANSACTION_REJECTED,
                    format!("{REJECT_INVALID}: {}", err.message),
                )
            }
        }
        MempoolErrorKind::AlreadyInMempool => {
            RpcError::new(RPC_INTERNAL_ERROR, "unexpected mempool duplicate")
        }
        MempoolErrorKind::Internal => RpcError::new(RPC_INTERNAL_ERROR, err.message),
    })?;

    if reject_absurd_fee {
        let min_fee = mempool_policy.min_relay_fee_for_size(entry.size());
        let absurd_threshold = min_fee.saturating_mul(10_000);
        if min_fee > 0 && entry.fee > absurd_threshold {
            let message = format!(
                "AcceptToMemoryPool: absurdly high fees {}, {} > {}",
                hash256_to_hex(&entry.txid),
                entry.fee,
                absurd_threshold
            );
            return Err(RpcError::new(RPC_TRANSACTION_ERROR, message));
        }
    }

    let txid = entry.txid;
    let current_estimate = crate::current_fee_estimate(chainstate);
    let tx_info = crate::fee_estimator::MempoolTxInfo {
        txid,
        height: u32::try_from(entry.height.max(0)).unwrap_or(0),
        fee: entry.fee,
        size: entry.size(),
        starting_priority: entry.starting_priority(),
        was_clear_at_entry: entry.was_clear_at_entry,
    };

    let insert_outcome = {
        let mut guard = mempool
            .lock()
            .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "mempool lock poisoned"))?;
        guard.insert(entry)
    };
    match insert_outcome {
        Ok(outcome) => {
            if outcome.evicted > 0 {
                mempool_metrics.note_evicted(outcome.evicted, outcome.evicted_bytes);
            }
            if let Ok(mut estimator) = fee_estimator.lock() {
                estimator.process_transaction(tx_info, current_estimate);
                for txid in outcome.evicted_txids {
                    estimator.remove_transaction(&txid);
                }
            }
        }
        Err(err) => {
            if err.kind != MempoolErrorKind::AlreadyInMempool {
                let message = match err.kind {
                    MempoolErrorKind::ConflictingInput => {
                        if err.message.contains("nullifier") {
                            format!("{REJECT_DUPLICATE}: bad-txns-shielded-requirements-not-met")
                        } else {
                            format!("{REJECT_DUPLICATE}: bad-txns-inputs-spent")
                        }
                    }
                    MempoolErrorKind::InsufficientFee | MempoolErrorKind::MempoolFull => {
                        format!("{REJECT_INSUFFICIENTFEE}: {}", err.message)
                    }
                    MempoolErrorKind::NonStandard => {
                        format!("{REJECT_NONSTANDARD}: {}", err.message)
                    }
                    _ => format!("{REJECT_INVALID}: {}", err.message),
                };
                return Err(RpcError::new(RPC_TRANSACTION_REJECTED, message));
            }
        }
    }

    let _ = tx_announce.send(txid);
    Ok(txid)
}

fn rpc_sendrawtransaction<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    mempool: &Mutex<Mempool>,
    mempool_policy: &MempoolPolicy,
    mempool_metrics: &MempoolMetrics,
    fee_estimator: &Mutex<FeeEstimator>,
    mempool_flags: &ValidationFlags,
    params: Vec<Value>,
    chain_params: &ChainParams,
    tx_announce: &broadcast::Sender<Hash256>,
) -> Result<Value, RpcError> {
    let result = (|| {
        if params.is_empty() || params.len() > 2 {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                "sendrawtransaction expects 1 or 2 parameters",
            ));
        }
        let hex = params[0]
            .as_str()
            .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "hexstring must be a string"))?;
        let allow_high_fees = if params.len() > 1 {
            parse_bool(&params[1])?
        } else {
            false
        };
        let reject_absurd_fee = !allow_high_fees;
        let raw = bytes_from_hex(hex)
            .ok_or_else(|| RpcError::new(RPC_DESERIALIZATION_ERROR, "TX decode failed"))?;
        let txid = submit_raw_transaction(
            chainstate,
            mempool,
            mempool_policy,
            mempool_metrics,
            fee_estimator,
            mempool_flags,
            chain_params,
            tx_announce,
            reject_absurd_fee,
            raw,
        )?;
        Ok(Value::String(hash256_to_hex(&txid)))
    })();

    match result {
        Ok(value) => {
            mempool_metrics.note_rpc_accept();
            Ok(value)
        }
        Err(err) => {
            mempool_metrics.note_rpc_reject();
            Err(err)
        }
    }
}

fn rpc_getmempoolinfo(params: Vec<Value>, mempool: &Mutex<Mempool>) -> Result<Value, RpcError> {
    ensure_no_params(&params)?;
    let guard = mempool
        .lock()
        .map_err(|_| map_internal("mempool lock poisoned"))?;
    Ok(json!({
        "size": guard.size(),
        "bytes": guard.bytes(),
        "usage": guard.usage(),
    }))
}

fn rpc_getrawmempool<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    params: Vec<Value>,
    mempool: &Mutex<Mempool>,
) -> Result<Value, RpcError> {
    if params.len() > 1 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "getrawmempool expects 0 or 1 parameter",
        ));
    }
    let verbose = if params.is_empty() {
        false
    } else {
        parse_verbose_flag(&params[0])?
    };
    let guard = mempool
        .lock()
        .map_err(|_| map_internal("mempool lock poisoned"))?;
    if !verbose {
        return Ok(Value::Array(
            guard
                .txids()
                .into_iter()
                .map(|txid| Value::String(hash256_to_hex(&txid)))
                .collect(),
        ));
    }
    let best_height = chainstate
        .best_block()
        .map_err(map_internal)?
        .map(|tip| tip.height)
        .unwrap_or(0);
    let mut out = serde_json::Map::new();
    for entry in guard.entries() {
        let depends: Vec<Value> = entry
            .parents
            .iter()
            .map(|txid| Value::String(hash256_to_hex(txid)))
            .collect();
        let starting_priority = entry.starting_priority();
        let current_priority = entry.current_priority(best_height);
        out.insert(
            hash256_to_hex(&entry.txid),
            json!({
                "size": entry.size(),
                "fee": amount_to_value(entry.fee),
                "time": entry.time,
                "height": entry.height.max(0),
                "startingpriority": Number::from_f64(starting_priority).unwrap_or(0.into()),
                "currentpriority": Number::from_f64(current_priority).unwrap_or(0.into()),
                "depends": depends,
            }),
        );
    }
    Ok(Value::Object(out))
}

fn rpc_gettxout<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    mempool: &Mutex<Mempool>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    if params.len() < 2 || params.len() > 3 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "gettxout expects 2 or 3 parameters",
        ));
    }
    let txid = parse_hash(&params[0])?;
    let index = params[1]
        .as_u64()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "vout must be numeric"))?;
    let outpoint = fluxd_primitives::outpoint::OutPoint {
        hash: txid,
        index: index as u32,
    };
    let include_mempool = if params.len() > 2 {
        parse_verbose_flag(&params[2])?
    } else {
        true
    };
    if include_mempool {
        let guard = mempool
            .lock()
            .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "mempool lock poisoned"))?;
        if guard.is_spent(&outpoint) {
            return Ok(Value::Null);
        }
        if let Some(entry) = guard.get(&txid) {
            let out_index = outpoint.index as usize;
            let Some(output) = entry.tx.vout.get(out_index) else {
                return Ok(Value::Null);
            };
            let best = chainstate
                .best_block()
                .map_err(map_internal)?
                .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "best block not found"))?;
            let script = script_pubkey_json(&output.script_pubkey, chain_params.network);
            return Ok(json!({
                "bestblock": hash256_to_hex(&best.hash),
                "confirmations": 0,
                "value": amount_to_value(output.value),
                "scriptPubKey": script,
                "version": entry.tx.version,
                "coinbase": false,
            }));
        }
    }
    let entry = match chainstate.utxo_entry(&outpoint).map_err(map_internal)? {
        Some(entry) => entry,
        None => return Ok(Value::Null),
    };
    let tx_version = {
        let location = chainstate
            .tx_location(&txid)
            .map_err(map_internal)?
            .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "transaction not found"))?;
        let bytes = chainstate
            .read_block(location.block)
            .map_err(map_internal)?;
        let block = Block::consensus_decode(&bytes).map_err(map_internal)?;
        block
            .transactions
            .get(location.index as usize)
            .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "transaction index out of range"))?
            .version
    };
    let best = chainstate
        .best_block()
        .map_err(map_internal)?
        .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "best block not found"))?;
    let confirmations = if best.height >= entry.height as i32 {
        (best.height - entry.height as i32 + 1).max(0)
    } else {
        0
    };
    let script = script_pubkey_json(&entry.script_pubkey, chain_params.network);
    Ok(json!({
        "bestblock": hash256_to_hex(&best.hash),
        "confirmations": confirmations,
        "value": amount_to_value(entry.value),
        "scriptPubKey": script,
        "version": tx_version,
        "coinbase": entry.is_coinbase,
    }))
}

fn rpc_gettxoutproof<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    params: Vec<Value>,
) -> Result<Value, RpcError> {
    if params.is_empty() || params.len() > 2 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "gettxoutproof expects 1 or 2 parameters",
        ));
    }

    let txids_value = params[0]
        .as_array()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "txids must be an array"))?;
    if txids_value.is_empty() {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "txids must be a non-empty array",
        ));
    }

    let mut set_txids = HashSet::with_capacity(txids_value.len());
    let mut one_txid = None;
    for value in txids_value {
        let text = value
            .as_str()
            .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "txid must be a string"))?;
        if text.len() != 64 {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                format!("Invalid txid {text}"),
            ));
        }
        let txid = hash256_from_hex(text)
            .map_err(|_| RpcError::new(RPC_INVALID_PARAMETER, format!("Invalid txid {text}")))?;
        if !set_txids.insert(txid) {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                format!("Invalid parameter, duplicated txid: {text}"),
            ));
        }
        one_txid = Some(txid);
    }
    let one_txid = one_txid.expect("non-empty txids array");

    let location = if params.len() > 1 {
        let block_hash = parse_hash(&params[1])?;
        chainstate
            .block_location(&block_hash)
            .map_err(map_internal)?
            .ok_or_else(|| RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "Block not found"))?
    } else {
        let tx_location = chainstate
            .tx_location(&one_txid)
            .map_err(map_internal)?
            .ok_or_else(|| {
                RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "Transaction not yet in block")
            })?;
        tx_location.block
    };

    let bytes = chainstate.read_block(location).map_err(map_internal)?;
    let block = Block::consensus_decode(&bytes).map_err(map_internal)?;

    let mut txids = Vec::with_capacity(block.transactions.len());
    let mut matches = Vec::with_capacity(block.transactions.len());
    let mut found = 0usize;
    for tx in &block.transactions {
        let txid = tx.txid().map_err(map_internal)?;
        let matched = set_txids.contains(&txid);
        if matched {
            found = found.saturating_add(1);
        }
        txids.push(txid);
        matches.push(matched);
    }

    if found != set_txids.len() {
        return Err(RpcError::new(
            RPC_INVALID_ADDRESS_OR_KEY,
            "(Not all) transactions not found in specified block",
        ));
    }

    let tree = PartialMerkleTree::from_txids(&txids, &matches).map_err(map_internal)?;
    let proof = MerkleBlock {
        header: block.header,
        txn: tree,
    };
    Ok(Value::String(hex_bytes(&proof.consensus_encode())))
}

fn rpc_verifytxoutproof<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    params: Vec<Value>,
) -> Result<Value, RpcError> {
    if params.len() != 1 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "verifytxoutproof expects 1 parameter",
        ));
    }

    let hex = params[0]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "proof must be a string"))?;
    let bytes = bytes_from_hex(hex)
        .ok_or_else(|| RpcError::new(RPC_DESERIALIZATION_ERROR, "Merkle block decode failed"))?;
    let merkle_block = MerkleBlock::consensus_decode(&bytes)
        .map_err(|_| RpcError::new(RPC_DESERIALIZATION_ERROR, "Merkle block decode failed"))?;

    let (root, matches) = match merkle_block.txn.extract_matches() {
        Some(value) => value,
        None => return Ok(Value::Array(Vec::new())),
    };
    if root != merkle_block.header.merkle_root {
        return Ok(Value::Array(Vec::new()));
    }

    let block_hash = merkle_block.header.hash();
    let entry = chainstate
        .header_entry(&block_hash)
        .map_err(map_internal)?
        .ok_or_else(|| RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "Block not found in chain"))?;
    let best_at_height = chainstate
        .height_hash(entry.height)
        .map_err(map_internal)?
        .ok_or_else(|| RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "Block not found in chain"))?;
    if best_at_height != block_hash {
        return Err(RpcError::new(
            RPC_INVALID_ADDRESS_OR_KEY,
            "Block not found in chain",
        ));
    }

    let mut out = Vec::with_capacity(matches.len());
    for txid in matches {
        out.push(Value::String(hash256_to_hex(&txid)));
    }
    Ok(Value::Array(out))
}

fn rpc_createfluxnodekey(
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    ensure_no_params(&params)?;

    let mut rng = rand::rngs::OsRng;
    let mut seed = [0u8; 32];
    for _ in 0..100 {
        rng.fill_bytes(&mut seed);
        if let Ok(secret) = SecretKey::from_slice(&seed) {
            let wif = secret_key_to_wif(&secret.secret_bytes(), chain_params.network, false);
            return Ok(Value::String(wif));
        }
    }

    Err(RpcError::new(
        RPC_INTERNAL_ERROR,
        "failed to generate secret key",
    ))
}

fn rpc_createdelegatekeypair(
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    ensure_no_params(&params)?;

    let secp = Secp256k1::new();
    let mut rng = rand::rngs::OsRng;
    let mut seed = [0u8; 32];
    for _ in 0..100 {
        rng.fill_bytes(&mut seed);
        let Ok(secret) = SecretKey::from_slice(&seed) else {
            continue;
        };
        let pubkey = PublicKey::from_secret_key(&secp, &secret);
        return Ok(json!({
            "private_key": secret_key_to_wif(&secret.secret_bytes(), chain_params.network, true),
            "public_key_compressed": hex_bytes(&pubkey.serialize()),
            "public_key_uncompressed": hex_bytes(&pubkey.serialize_uncompressed()),
        }));
    }

    Err(RpcError::new(
        RPC_INTERNAL_ERROR,
        "failed to generate secret key",
    ))
}

fn rpc_getindexstats<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    params: Vec<Value>,
) -> Result<Value, RpcError> {
    ensure_no_params(&params)?;
    let stats = chainstate.index_stats_snapshot().map_err(map_internal)?;
    Ok(json!({
        "spent_index_entries": stats.spent_index_entries,
        "address_outpoint_entries": stats.address_outpoint_entries,
    }))
}

fn rpc_gettxoutsetinfo<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    params: Vec<Value>,
    data_dir: &Path,
) -> Result<Value, RpcError> {
    ensure_no_params(&params)?;
    let best = chainstate.best_block().map_err(map_internal)?;
    let (height, best_hash) = match best {
        Some(tip) => (tip.height, tip.hash),
        None => (0, [0u8; 32]),
    };
    let utxo_info = chainstate.utxo_set_info().map_err(map_internal)?;
    let value_pools = chainstate.value_pools_or_compute().map_err(map_internal)?;
    let shielded_total = value_pools
        .sprout
        .checked_add(value_pools.sapling)
        .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "shielded value pool overflow"))?;
    let total_supply = utxo_info
        .total_amount
        .checked_add(shielded_total)
        .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "total supply overflow"))?;
    let disk_size =
        db_info::dir_size_cached(&data_dir.join("db"), Duration::from_secs(30)).unwrap_or(0);
    Ok(json!({
        "height": height.max(0),
        "bestblock": hash256_to_hex(&best_hash),
        "transactions": utxo_info.transactions,
        "txouts": utxo_info.txouts,
        "bytes_serialized": utxo_info.bytes_serialized,
        "hash_serialized": hash256_to_hex(&utxo_info.hash_serialized),
        "disk_size": disk_size,
        "total_amount": amount_to_value(utxo_info.total_amount),
        "total_amount_zat": utxo_info.total_amount,
        "sprout_pool": amount_to_value(value_pools.sprout),
        "sprout_pool_zat": value_pools.sprout,
        "sapling_pool": amount_to_value(value_pools.sapling),
        "sapling_pool_zat": value_pools.sapling,
        "shielded_amount": amount_to_value(shielded_total),
        "shielded_amount_zat": shielded_total,
        "total_supply": amount_to_value(total_supply),
        "total_supply_zat": total_supply,
    }))
}

fn rpc_getrichlist<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    let (page, page_size, min_balance) = parse_richlist_params(&params)?;

    {
        let guard = richlist_cache()
            .lock()
            .map_err(|_| map_internal("richlist cache lock poisoned"))?;
        if let Some(existing) = guard.as_ref() {
            if existing.computed_at.elapsed() < RICHLIST_CACHE_TTL {
                return Ok(existing.to_response(chainstate, page, page_size, min_balance));
            }
        }
    }

    if RICHLIST_REFRESH_IN_FLIGHT
        .compare_exchange(
            false,
            true,
            std::sync::atomic::Ordering::SeqCst,
            std::sync::atomic::Ordering::SeqCst,
        )
        .is_ok()
    {
        if let Err(err) = refresh_richlist_cache(chainstate, chain_params) {
            log_warn!("richlist refresh failed: {err}");
        }
        RICHLIST_REFRESH_IN_FLIGHT.store(false, std::sync::atomic::Ordering::SeqCst);
    }

    let guard = richlist_cache()
        .lock()
        .map_err(|_| map_internal("richlist cache lock poisoned"))?;
    if let Some(existing) = guard.as_ref() {
        return Ok(existing.to_response(chainstate, page, page_size, min_balance));
    }

    Err(RpcError::new(RPC_INTERNAL_ERROR, "rich list warming up"))
}

fn rpc_verifychain<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    params: Vec<Value>,
) -> Result<Value, RpcError> {
    if params.len() > 2 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "verifychain expects 0 to 2 parameters",
        ));
    }

    let checklevel = if let Some(value) = params.get(0) {
        parse_u32(value, "checklevel")?
    } else {
        3
    };
    if checklevel > 5 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "checklevel must be 0-5",
        ));
    }

    let numblocks = if let Some(value) = params.get(1) {
        parse_u32(value, "numblocks")?
    } else {
        288
    };

    let result = crate::verify_chain::verify_chain(chainstate, checklevel, numblocks);
    if let Err(reason) = result.as_ref() {
        log_warn!("verifychain failed: {reason}");
    }
    Ok(Value::Bool(result.is_ok()))
}

fn rpc_getblockdeltas<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    if params.len() != 1 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "getblockdeltas expects 1 parameter",
        ));
    }
    let (hash, entry) = resolve_block_hash(chainstate, &params[0])?;

    let best_height = best_block_height(chainstate)?;
    let main_hash = chainstate.height_hash(entry.height).map_err(map_internal)?;
    if main_hash.as_ref() != Some(&hash) {
        return Err(RpcError::new(
            RPC_INVALID_ADDRESS_OR_KEY,
            "Block is an orphan",
        ));
    }

    let location = chainstate
        .block_location(&hash)
        .map_err(map_internal)?
        .ok_or_else(|| RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "Block not found"))?;
    let bytes = chainstate.read_block(location).map_err(map_internal)?;
    let block = fluxd_primitives::block::Block::consensus_decode(&bytes).map_err(map_internal)?;

    let mut deltas = Vec::with_capacity(block.transactions.len());
    let mut tx_cache: HashMap<Hash256, Transaction> = HashMap::new();

    for (tx_index, tx) in block.transactions.iter().enumerate() {
        let txid = tx.txid().map_err(map_internal)?;
        let mut entry_obj = serde_json::Map::new();
        entry_obj.insert("txid".to_string(), Value::String(hash256_to_hex(&txid)));
        entry_obj.insert("index".to_string(), Value::Number((tx_index as i64).into()));

        if let Some(fluxnode) = tx.fluxnode.as_ref() {
            match fluxnode {
                FluxnodeTx::V5(FluxnodeTxV5::Start(start)) => {
                    entry_obj.insert("nType".to_string(), Value::Number(2.into()));
                    entry_obj.insert(
                        "collateralOutputHash".to_string(),
                        Value::String(hash256_to_hex(&start.collateral.hash)),
                    );
                    entry_obj.insert(
                        "collateralOutputIndex".to_string(),
                        Value::Number((start.collateral.index as i64).into()),
                    );
                }
                FluxnodeTx::V6(FluxnodeTxV6::Start(start)) => {
                    entry_obj.insert("nType".to_string(), Value::Number(2.into()));
                    let collateral = match &start.variant {
                        FluxnodeStartVariantV6::Normal { collateral, .. } => collateral,
                        FluxnodeStartVariantV6::P2sh { collateral, .. } => collateral,
                    };
                    entry_obj.insert(
                        "collateralOutputHash".to_string(),
                        Value::String(hash256_to_hex(&collateral.hash)),
                    );
                    entry_obj.insert(
                        "collateralOutputIndex".to_string(),
                        Value::Number((collateral.index as i64).into()),
                    );
                }
                FluxnodeTx::V5(FluxnodeTxV5::Confirm(confirm))
                | FluxnodeTx::V6(FluxnodeTxV6::Confirm(confirm)) => {
                    entry_obj.insert("nType".to_string(), Value::Number(4.into()));
                    entry_obj.insert("ip".to_string(), Value::String(confirm.ip.clone()));
                    entry_obj.insert(
                        "benchmarkTier".to_string(),
                        Value::String(fluxnode_tier_name(confirm.benchmark_tier).to_string()),
                    );
                    entry_obj.insert(
                        "collateralOutputHash".to_string(),
                        Value::String(hash256_to_hex(&confirm.collateral.hash)),
                    );
                    entry_obj.insert(
                        "collateralOutputIndex".to_string(),
                        Value::Number((confirm.collateral.index as i64).into()),
                    );
                }
            }
        }

        let mut inputs = Vec::new();
        let is_coinbase =
            tx.vin.len() == 1 && tx.vin[0].prevout == fluxd_primitives::outpoint::OutPoint::null();
        if !is_coinbase {
            for (vin_index, input) in tx.vin.iter().enumerate() {
                let mut delta = serde_json::Map::new();

                let (satoshis, address) = match chainstate
                    .spent_info(&input.prevout)
                    .map_err(map_internal)?
                {
                    Some(spent) => {
                        if let Some(details) = spent.details {
                            (
                                details.satoshis,
                                spent_details_address(
                                    details.address_type,
                                    &details.address_hash,
                                    chain_params.network,
                                ),
                            )
                        } else {
                            resolve_prevout_via_txindex(
                                chainstate,
                                &mut tx_cache,
                                &input.prevout,
                                chain_params.network,
                            )?
                        }
                    }
                    None => resolve_prevout_via_txindex(
                        chainstate,
                        &mut tx_cache,
                        &input.prevout,
                        chain_params.network,
                    )?,
                };

                if let Some(address) = address {
                    delta.insert("address".to_string(), Value::String(address));
                }

                delta.insert("satoshis".to_string(), Value::from(-satoshis));
                delta.insert(
                    "index".to_string(),
                    Value::Number((vin_index as i64).into()),
                );
                delta.insert(
                    "prevtxid".to_string(),
                    Value::String(hash256_to_hex(&input.prevout.hash)),
                );
                delta.insert(
                    "prevout".to_string(),
                    Value::Number((input.prevout.index as i64).into()),
                );
                inputs.push(Value::Object(delta));
            }
        }
        entry_obj.insert("inputs".to_string(), Value::Array(inputs));

        let mut outputs = Vec::with_capacity(tx.vout.len());
        for (vout_index, output) in tx.vout.iter().enumerate() {
            let address = script_pubkey_to_address(&output.script_pubkey, chain_params.network)
                .unwrap_or_default();
            outputs.push(json!({
                "address": address,
                "satoshis": output.value,
                "index": vout_index,
            }));
        }
        entry_obj.insert("outputs".to_string(), Value::Array(outputs));
        deltas.push(Value::Object(entry_obj));
    }

    let confirmations = best_height - entry.height + 1;
    let next_hash = next_hash_for_height(chainstate, entry.height, best_height, &hash)?;
    let mediantime = median_time_past(chainstate, entry.height)?;

    let mut result = json!({
        "hash": hash256_to_hex(&hash),
        "confirmations": confirmations,
        "size": bytes.len(),
        "height": entry.height,
        "version": block.header.version,
        "merkleroot": hash256_to_hex(&block.header.merkle_root),
        "deltas": Value::Array(deltas),
        "time": block.header.time,
        "mediantime": mediantime,
        "nonce": hash256_to_hex(&block.header.nonce),
        "bits": format!("{:08x}", block.header.bits),
        "difficulty": difficulty_from_bits(block.header.bits, chain_params).unwrap_or(0.0),
        "chainwork": hex_bytes(&entry.chainwork),
    });

    if entry.height > 0 {
        result["previousblockhash"] = Value::String(hash256_to_hex(&entry.prev_hash));
    }
    if let Some(next_hash) = next_hash {
        result["nextblockhash"] = Value::String(hash256_to_hex(&next_hash));
    }

    Ok(result)
}

fn rpc_getspentinfo<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    params: Vec<Value>,
) -> Result<Value, RpcError> {
    let (txid, index) = match params.as_slice() {
        [Value::Object(map)] => {
            let txid_value = map
                .get("txid")
                .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "getspentinfo missing txid"))?;
            let index_value = map.get("index").ok_or_else(|| {
                RpcError::new(RPC_INVALID_PARAMETER, "getspentinfo missing index")
            })?;
            (parse_hash(txid_value)?, parse_u32(index_value, "index")?)
        }
        [txid_value, index_value] => (parse_hash(txid_value)?, parse_u32(index_value, "index")?),
        _ => {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                "getspentinfo expects {\"txid\": \"...\", \"index\": n}",
            ))
        }
    };

    let outpoint = fluxd_primitives::outpoint::OutPoint { hash: txid, index };
    let spent = chainstate
        .spent_info(&outpoint)
        .map_err(map_internal)?
        .ok_or_else(|| RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "Unable to get spent info"))?;

    Ok(json!({
        "txid": hash256_to_hex(&spent.txid),
        "index": spent.input_index,
        "height": spent.block_height,
    }))
}

fn rpc_getaddressutxos<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    if params.len() != 1 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "getaddressutxos expects 1 parameter",
        ));
    }
    let (addresses, opts) = parse_addresses_param(&params[0])?;
    let include_chain_info = parse_chain_info_flag(opts)?;
    let address_scripts = decode_address_scripts(addresses, chain_params.network)?;

    #[derive(Clone)]
    struct UtxoRow {
        address: String,
        txid: Hash256,
        output_index: u32,
        script: Vec<u8>,
        satoshis: i64,
        height: u32,
    }

    let mut rows = Vec::new();
    for (address, script_pubkey) in address_scripts {
        let outpoints = chainstate
            .address_outpoints(&script_pubkey)
            .map_err(map_internal)?;
        for outpoint in outpoints {
            let entry = chainstate
                .utxo_entry(&outpoint)
                .map_err(map_internal)?
                .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "missing utxo entry"))?;
            rows.push(UtxoRow {
                address: address.clone(),
                txid: outpoint.hash,
                output_index: outpoint.index,
                script: entry.script_pubkey,
                satoshis: entry.value,
                height: entry.height,
            });
        }
    }

    rows.sort_by(|a, b| {
        a.height
            .cmp(&b.height)
            .then_with(|| a.txid.cmp(&b.txid))
            .then_with(|| a.output_index.cmp(&b.output_index))
    });

    let utxos = rows
        .into_iter()
        .map(|row| {
            json!({
                "address": row.address,
                "txid": hash256_to_hex(&row.txid),
                "outputIndex": row.output_index,
                "script": hex_bytes(&row.script),
                "satoshis": row.satoshis,
                "height": row.height,
            })
        })
        .collect::<Vec<_>>();

    if !include_chain_info {
        return Ok(Value::Array(utxos));
    }

    let best = chainstate.best_block().map_err(map_internal)?;
    let (height, hash) = match best {
        Some(tip) => (tip.height, tip.hash),
        None => (0, [0u8; 32]),
    };

    Ok(json!({
        "utxos": utxos,
        "hash": hash256_to_hex(&hash),
        "height": height.max(0),
    }))
}

fn rpc_getaddressbalance<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    if params.len() != 1 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "getaddressbalance expects 1 parameter",
        ));
    }
    let (addresses, _opts) = parse_addresses_param(&params[0])?;
    let address_scripts = decode_address_scripts(addresses, chain_params.network)?;

    let best_height = best_block_height(chainstate)?;

    let mut balance = 0i64;
    let mut received = 0i64;
    let mut cumulus_count = 0u32;
    let mut nimbus_count = 0u32;
    let mut stratus_count = 0u32;

    for (_address, script_pubkey) in address_scripts.iter() {
        let mut visitor = |delta: fluxd_chainstate::address_deltas::AddressDeltaEntry| {
            if delta.satoshis > 0 {
                received = received.checked_add(delta.satoshis).ok_or_else(|| {
                    fluxd_storage::StoreError::Backend("address balance overflow".to_string())
                })?;
            }
            balance = balance.checked_add(delta.satoshis).ok_or_else(|| {
                fluxd_storage::StoreError::Backend("address balance overflow".to_string())
            })?;
            Ok(())
        };
        chainstate
            .for_each_address_delta(script_pubkey, &mut visitor)
            .map_err(map_internal)?;

        let outpoints = chainstate
            .address_outpoints(script_pubkey)
            .map_err(map_internal)?;
        for outpoint in outpoints {
            let entry = chainstate
                .utxo_entry(&outpoint)
                .map_err(map_internal)?
                .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "missing utxo entry"))?;

            if let Some(tier) = fluxd_consensus::fluxnode_tier_from_collateral(
                best_height,
                entry.value,
                &chain_params.fluxnode,
            ) {
                match tier {
                    1 => cumulus_count = cumulus_count.saturating_add(1),
                    2 => nimbus_count = nimbus_count.saturating_add(1),
                    3 => stratus_count = stratus_count.saturating_add(1),
                    _ => {}
                }
            }
        }
    }

    Ok(json!({
        "balance": balance,
        "received": received,
        "cumulusCount": cumulus_count,
        "nimbusCount": nimbus_count,
        "stratusCount": stratus_count,
    }))
}

fn rpc_getaddressdeltas<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    if params.len() != 1 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "getaddressdeltas expects 1 parameter",
        ));
    }
    let (addresses, opts) = parse_addresses_param(&params[0])?;
    let include_chain_info = parse_chain_info_flag(opts)?;
    let range = parse_height_range(chainstate, opts)?;
    let address_scripts = decode_address_scripts(addresses, chain_params.network)?;

    #[derive(Clone)]
    struct DeltaRow {
        address: String,
        height: u32,
        tx_index: u32,
        txid: Hash256,
        index: u32,
        satoshis: i64,
    }

    let mut rows = Vec::new();
    for (address, script_pubkey) in address_scripts {
        let Some(script_hash) = fluxd_chainstate::address_index::script_hash(&script_pubkey) else {
            continue;
        };

        let mut visitor = |delta: fluxd_chainstate::address_deltas::AddressDeltaEntry| {
            rows.push(DeltaRow {
                address: address.clone(),
                height: delta.height,
                tx_index: delta.tx_index,
                txid: delta.txid,
                index: delta.index,
                satoshis: delta.satoshis,
            });
            Ok(())
        };

        if let Some((start, end)) = range {
            chainstate
                .for_each_address_delta_range(&script_hash, start, end, &mut visitor)
                .map_err(map_internal)?;
        } else {
            chainstate
                .for_each_address_delta(&script_pubkey, &mut visitor)
                .map_err(map_internal)?;
        }
    }

    rows.sort_by(|a, b| {
        a.height
            .cmp(&b.height)
            .then_with(|| a.tx_index.cmp(&b.tx_index))
            .then_with(|| a.txid.cmp(&b.txid))
            .then_with(|| a.index.cmp(&b.index))
            .then_with(|| a.address.cmp(&b.address))
    });

    let deltas = rows
        .into_iter()
        .map(|row| {
            json!({
                "address": row.address,
                "blockindex": row.tx_index,
                "height": row.height,
                "index": row.index,
                "satoshis": row.satoshis,
                "txid": hash256_to_hex(&row.txid),
            })
        })
        .collect::<Vec<_>>();

    let Some((start, end)) = range else {
        return Ok(Value::Array(deltas));
    };
    if !include_chain_info {
        return Ok(Value::Array(deltas));
    }

    let start_height = i32::try_from(start).map_err(|_| {
        RpcError::new(
            RPC_INVALID_ADDRESS_OR_KEY,
            "Start or end is outside chain range",
        )
    })?;
    let end_height = i32::try_from(end).map_err(|_| {
        RpcError::new(
            RPC_INVALID_ADDRESS_OR_KEY,
            "Start or end is outside chain range",
        )
    })?;
    let start_hash = chainstate
        .height_hash(start_height)
        .map_err(map_internal)?
        .ok_or_else(|| RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "block not found"))?;
    let end_hash = chainstate
        .height_hash(end_height)
        .map_err(map_internal)?
        .ok_or_else(|| RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "block not found"))?;

    Ok(json!({
        "deltas": deltas,
        "start": {
            "hash": hash256_to_hex(&start_hash),
            "height": start,
        },
        "end": {
            "hash": hash256_to_hex(&end_hash),
            "height": end,
        },
    }))
}

fn rpc_getaddresstxids<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    if params.len() != 1 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "getaddresstxids expects 1 parameter",
        ));
    }
    let (addresses, opts) = parse_addresses_param(&params[0])?;
    let range = parse_height_range(chainstate, opts)?;
    let address_scripts = decode_address_scripts(addresses, chain_params.network)?;

    let mut txids = std::collections::BTreeSet::<(u32, Hash256)>::new();
    for (_address, script_pubkey) in address_scripts {
        let Some(script_hash) = fluxd_chainstate::address_index::script_hash(&script_pubkey) else {
            continue;
        };

        let mut visitor = |delta: fluxd_chainstate::address_deltas::AddressDeltaEntry| {
            txids.insert((delta.height, delta.txid));
            Ok(())
        };

        if let Some((start, end)) = range {
            chainstate
                .for_each_address_delta_range(&script_hash, start, end, &mut visitor)
                .map_err(map_internal)?;
        } else {
            chainstate
                .for_each_address_delta(&script_pubkey, &mut visitor)
                .map_err(map_internal)?;
        }
    }

    Ok(Value::Array(
        txids
            .into_iter()
            .map(|(_height, txid)| Value::String(hash256_to_hex(&txid)))
            .collect(),
    ))
}

fn rpc_getaddresstxidscount<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    if params.len() != 1 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "getaddresstxidscount expects 1 parameter",
        ));
    }

    let (addresses, opts) = parse_addresses_param(&params[0])?;
    let range = parse_height_range(chainstate, opts)?;
    let address_scripts = decode_address_scripts(addresses, chain_params.network)?;

    let mut txids = std::collections::BTreeSet::<(u32, Hash256)>::new();
    for (_address, script_pubkey) in address_scripts {
        let Some(script_hash) = fluxd_chainstate::address_index::script_hash(&script_pubkey) else {
            continue;
        };

        let mut visitor = |delta: fluxd_chainstate::address_deltas::AddressDeltaEntry| {
            txids.insert((delta.height, delta.txid));
            Ok(())
        };

        if let Some((start, end)) = range {
            chainstate
                .for_each_address_delta_range(&script_hash, start, end, &mut visitor)
                .map_err(map_internal)?;
        } else {
            chainstate
                .for_each_address_delta(&script_pubkey, &mut visitor)
                .map_err(map_internal)?;
        }
    }

    Ok(Value::Number((txids.len() as u64).into()))
}

fn rpc_getaddresspagecursor<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    if params.len() != 1 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "getaddresspagecursor expects 1 parameter",
        ));
    }

    let (addresses, opts) = parse_addresses_param(&params[0])?;
    let address_scripts = decode_address_scripts(addresses, chain_params.network)?;

    if address_scripts.len() != 1 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "getaddresspagecursor expects exactly one address",
        ));
    }

    let map = opts.ok_or_else(|| {
        RpcError::new(
            RPC_INVALID_PARAMETER,
            "getaddresspagecursor expects an object parameter",
        )
    })?;

    let offset = map
        .get("offset")
        .map(|value| parse_u32(value, "offset"))
        .transpose()?
        .unwrap_or(0) as u64;
    let limit = map
        .get("limit")
        .map(|value| parse_u32(value, "limit"))
        .transpose()?
        .unwrap_or(25) as u64;
    let limit = limit.max(1);

    let (address, script_pubkey) = address_scripts
        .into_iter()
        .next()
        .expect("single address");

    let Some(script_hash) = fluxd_chainstate::address_index::script_hash(&script_pubkey) else {
        return Ok(json!({
            "total": 0,
            "cursorHeight": null,
            "cursorTxIndex": null,
            "cursorTxid": null,
        }));
    };

    let total = chainstate
        .address_tx_total(&script_hash)
        .map_err(map_internal)?
        .unwrap_or(0);

    if total == 0 {
        return Ok(json!({
            "address": address,
            "total": 0,
            "cursorHeight": null,
            "cursorTxIndex": null,
            "cursorTxid": null,
        }));
    }

    let page_size = limit;
    let offset_from_newest = offset;

    let start_rank_from_oldest = total
        .saturating_sub(offset_from_newest)
        .saturating_sub(page_size);

    let checkpoint_interval = fluxd_chainstate::address_tx_index::DEFAULT_CHECKPOINT_INTERVAL;
    let checkpoint_index = start_rank_from_oldest / checkpoint_interval;

    let cursor = chainstate
        .address_tx_checkpoint(&script_hash, checkpoint_index as u32)
        .map_err(map_internal)?;

    Ok(match cursor {
        Some(cursor) => json!({
            "address": address,
            "total": total,
            "cursorHeight": cursor.height,
            "cursorTxIndex": cursor.tx_index,
            "cursorTxid": hash256_to_hex(&cursor.txid),
        }),
        None => json!({
            "address": address,
            "total": total,
            "cursorHeight": null,
            "cursorTxIndex": null,
            "cursorTxid": null,
        }),
    })
}

fn rpc_getaddressmempool<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    mempool: &Mutex<Mempool>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    if params.len() != 1 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "getaddressmempool expects 1 parameter",
        ));
    }
    let (addresses, _opts) = parse_addresses_param(&params[0])?;
    let address_scripts = decode_address_scripts(addresses, chain_params.network)?;

    let mut script_to_address = HashMap::new();
    for (address, script_pubkey) in address_scripts {
        script_to_address.insert(script_pubkey, address);
    }

    #[derive(Clone)]
    struct DeltaRow {
        address: String,
        txid: Hash256,
        index: u32,
        satoshis: i64,
        timestamp: u64,
        prevtxid: Option<Hash256>,
        prevout: Option<u32>,
    }

    let guard = mempool
        .lock()
        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "mempool lock poisoned"))?;
    let mut rows = Vec::new();
    for entry in guard.entries() {
        for (index, output) in entry.tx.vout.iter().enumerate() {
            if let Some(address) = script_to_address.get(&output.script_pubkey) {
                rows.push(DeltaRow {
                    address: address.clone(),
                    txid: entry.txid,
                    index: index as u32,
                    satoshis: output.value,
                    timestamp: entry.time,
                    prevtxid: None,
                    prevout: None,
                });
            }
        }
        for (index, input) in entry.tx.vin.iter().enumerate() {
            let prevout_entry = match chainstate
                .utxo_entry(&input.prevout)
                .map_err(map_internal)?
            {
                Some(entry) => entry,
                None => continue,
            };
            if let Some(address) = script_to_address.get(&prevout_entry.script_pubkey) {
                rows.push(DeltaRow {
                    address: address.clone(),
                    txid: entry.txid,
                    index: index as u32,
                    satoshis: -prevout_entry.value,
                    timestamp: entry.time,
                    prevtxid: Some(input.prevout.hash),
                    prevout: Some(input.prevout.index),
                });
            }
        }
    }

    rows.sort_by(|a, b| {
        a.timestamp
            .cmp(&b.timestamp)
            .then_with(|| a.txid.cmp(&b.txid))
            .then_with(|| a.index.cmp(&b.index))
            .then_with(|| a.address.cmp(&b.address))
    });

    Ok(Value::Array(
        rows.into_iter()
            .map(|row| {
                let mut obj = serde_json::Map::new();
                obj.insert("address".to_string(), Value::String(row.address));
                obj.insert("txid".to_string(), Value::String(hash256_to_hex(&row.txid)));
                obj.insert("index".to_string(), Value::Number(row.index.into()));
                obj.insert("satoshis".to_string(), Value::Number(row.satoshis.into()));
                obj.insert("timestamp".to_string(), Value::Number(row.timestamp.into()));
                if row.satoshis < 0 {
                    if let Some(prevtxid) = row.prevtxid {
                        obj.insert(
                            "prevtxid".to_string(),
                            Value::String(hash256_to_hex(&prevtxid)),
                        );
                    }
                    if let Some(prevout) = row.prevout {
                        obj.insert("prevout".to_string(), Value::Number(prevout.into()));
                    }
                }
                Value::Object(obj)
            })
            .collect(),
    ))
}

fn rpc_getblocktemplate<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    mempool: &Mutex<Mempool>,
    mempool_policy: &MempoolPolicy,
    params: Vec<Value>,
    chain_params: &ChainParams,
    flags: &ValidationFlags,
    default_miner_address: Option<&str>,
) -> Result<Value, RpcError> {
    if params.len() > 1 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "getblocktemplate expects 0 or 1 parameter",
        ));
    }

    let request = match params.get(0) {
        None => None,
        Some(value) => Some(value.as_object().ok_or_else(|| {
            RpcError::new(
                RPC_INVALID_PARAMETER,
                "getblocktemplate param must be an object",
            )
        })?),
    };
    let mode = request
        .and_then(|obj| obj.get("mode"))
        .and_then(|value| value.as_str())
        .unwrap_or("template");

    if mode == "proposal" {
        let Some(obj) = request else {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                "getblocktemplate param must be an object",
            ));
        };
        let hex = obj
            .get("data")
            .and_then(|val| val.as_str())
            .ok_or_else(|| RpcError::new(RPC_TYPE_ERROR, "Missing data String key for proposal"))?;
        let bytes = bytes_from_hex(hex)
            .ok_or_else(|| RpcError::new(RPC_DESERIALIZATION_ERROR, "Block decode failed"))?;
        let block = Block::consensus_decode(&bytes)
            .map_err(|_| RpcError::new(RPC_DESERIALIZATION_ERROR, "Block decode failed"))?;
        let hash = block.header.hash();

        if let Some(entry) = chainstate.header_entry(&hash).map_err(map_internal)? {
            if entry.has_block() {
                return Ok(Value::String("duplicate".to_string()));
            }
            return Ok(Value::String("duplicate-inconclusive".to_string()));
        }

        let best = chainstate.best_block().map_err(map_internal)?;
        if let Some(tip) = best {
            if block.header.prev_block != tip.hash {
                return Ok(Value::String("inconclusive-not-best-prevblk".to_string()));
            }

            let height = tip.height + 1;
            return match chainstate.connect_block(
                &block,
                height,
                chain_params,
                flags,
                false,
                None,
                None,
                Some(bytes.as_slice()),
                None,
            ) {
                Ok(_) => Ok(Value::Null),
                Err(fluxd_chainstate::state::ChainStateError::Validation(err)) => {
                    Ok(Value::String(err.to_string()))
                }
                Err(fluxd_chainstate::state::ChainStateError::InvalidHeader(msg)) => {
                    Ok(Value::String(msg.to_string()))
                }
                Err(err) => Err(map_internal(err.to_string())),
            };
        } else {
            if block.header.prev_block != [0u8; 32] {
                return Ok(Value::String("inconclusive-not-best-prevblk".to_string()));
            }

            return match chainstate.connect_block(
                &block,
                0,
                chain_params,
                flags,
                false,
                None,
                None,
                Some(bytes.as_slice()),
                None,
            ) {
                Ok(_) => Ok(Value::Null),
                Err(fluxd_chainstate::state::ChainStateError::Validation(err)) => {
                    Ok(Value::String(err.to_string()))
                }
                Err(fluxd_chainstate::state::ChainStateError::InvalidHeader(msg)) => {
                    Ok(Value::String(msg.to_string()))
                }
                Err(err) => Err(map_internal(err.to_string())),
            };
        }
    }

    if mode != "template" {
        return Err(RpcError::new(RPC_INVALID_PARAMETER, "Invalid mode"));
    }

    let miner_address = request
        .and_then(|obj| {
            obj.get("mineraddress")
                .or_else(|| obj.get("address"))
                .and_then(|val| val.as_str())
        })
        .or(default_miner_address)
        .ok_or_else(|| {
            RpcError::new(
                RPC_INVALID_PARAMETER,
                "missing miner address for block template",
            )
        })?;

    let miner_script_pubkey = address_to_script_pubkey(miner_address, chain_params.network)
        .map_err(|err| match err {
            AddressError::UnknownPrefix => RpcError::new(
                RPC_INVALID_ADDRESS_OR_KEY,
                "miner address has invalid prefix",
            ),
            _ => RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "invalid miner address"),
        })?;

    let best = chainstate.best_block().map_err(map_internal)?;
    let (prev_hash, height) = match best {
        Some(tip) => (tip.hash, tip.height + 1),
        None => ([0u8; 32], 0),
    };

    let mintime = median_time_past(chainstate, height - 1)?
        .saturating_add(1)
        .max(0);
    let mintime_u32 = u32::try_from(mintime).unwrap_or(0);

    let mut curtime = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_secs()
        .min(u32::MAX as u64) as u32;
    curtime = curtime.max(mintime_u32);

    let bits = chainstate
        .next_work_required_bits(&prev_hash, height, curtime as i64, &chain_params.consensus)
        .map_err(map_internal)?;

    let pon_active =
        network_upgrade_active(height, &chain_params.consensus.upgrades, UpgradeIndex::Pon);
    let sapling_active = network_upgrade_active(
        height,
        &chain_params.consensus.upgrades,
        UpgradeIndex::Acadia,
    );

    let payouts = chainstate
        .deterministic_fluxnode_payouts(height, chain_params)
        .map_err(map_internal)?;

    let subsidy = block_subsidy(height, &chain_params.consensus);
    let payout_sum = payouts
        .iter()
        .try_fold(0i64, |acc, (_, _, _, amount)| acc.checked_add(*amount))
        .ok_or_else(|| map_internal("fluxnode payout sum out of range"))?;
    let remainder = subsidy
        .checked_sub(payout_sum)
        .ok_or_else(|| map_internal("fluxnode payout remainder out of range"))?;

    let exchange_fund = exchange_fund_amount(height, &chain_params.funding);
    let foundation_fund = foundation_fund_amount(height, &chain_params.funding);
    let swap_pool = swap_pool_amount(height as i64, &chain_params.swap_pool);

    let make_coinbase = |miner_value: i64| -> Result<Transaction, RpcError> {
        let mut outputs = Vec::new();
        outputs.push(TxOut {
            value: miner_value,
            script_pubkey: miner_script_pubkey.clone(),
        });
        for (_, _, script_pubkey, amount) in &payouts {
            outputs.push(TxOut {
                value: *amount,
                script_pubkey: script_pubkey.clone(),
            });
        }

        if pon_active {
            let dev_script = address_to_script_pubkey(
                chain_params.funding.dev_fund_address,
                chain_params.network,
            )
            .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "invalid dev fund address"))?;
            outputs.push(TxOut {
                value: remainder,
                script_pubkey: dev_script,
            });
        }

        if exchange_fund > 0 {
            let exchange_script = address_to_script_pubkey(
                chain_params.funding.exchange_address,
                chain_params.network,
            )
            .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "invalid exchange fund address"))?;
            outputs.push(TxOut {
                value: exchange_fund,
                script_pubkey: exchange_script,
            });
        }
        if foundation_fund > 0 {
            let foundation_script = address_to_script_pubkey(
                chain_params.funding.foundation_address,
                chain_params.network,
            )
            .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "invalid foundation fund address"))?;
            outputs.push(TxOut {
                value: foundation_fund,
                script_pubkey: foundation_script,
            });
        }
        if swap_pool > 0 {
            let swap_script =
                address_to_script_pubkey(chain_params.swap_pool.address, chain_params.network)
                    .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "invalid swap pool address"))?;
            outputs.push(TxOut {
                value: swap_pool,
                script_pubkey: swap_script,
            });
        }

        let mut script_sig = script_push_int(height as i64);
        crate::push_data(&mut script_sig, b"fluxd-rust");

        Ok(Transaction {
            f_overwintered: sapling_active,
            version: if sapling_active { 4 } else { 1 },
            version_group_id: if sapling_active {
                SAPLING_VERSION_GROUP_ID
            } else {
                0
            },
            vin: vec![TxIn {
                prevout: OutPoint::null(),
                script_sig,
                sequence: u32::MAX,
            }],
            vout: outputs,
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        })
    };

    fn legacy_sigops(script: &[u8]) -> u32 {
        const OP_0: u8 = 0x00;
        const OP_1: u8 = 0x51;
        const OP_16: u8 = 0x60;
        const OP_CHECKSIG: u8 = 0xac;
        const OP_CHECKSIGVERIFY: u8 = 0xad;
        const OP_CHECKMULTISIG: u8 = 0xae;
        const OP_CHECKMULTISIGVERIFY: u8 = 0xaf;
        const OP_PUSHDATA1: u8 = 0x4c;
        const OP_PUSHDATA2: u8 = 0x4d;
        const OP_PUSHDATA4: u8 = 0x4e;

        let mut count = 0u32;
        let mut cursor = 0usize;
        let mut prev_opcode: Option<u8> = None;
        while cursor < script.len() {
            let opcode = script[cursor];
            cursor = cursor.saturating_add(1);
            match opcode {
                OP_CHECKSIG | OP_CHECKSIGVERIFY => count = count.saturating_add(1),
                OP_CHECKMULTISIG | OP_CHECKMULTISIGVERIFY => {
                    let sigops = match prev_opcode {
                        Some(OP_0) => 0,
                        Some(opcode) if (OP_1..=OP_16).contains(&opcode) => {
                            u32::from(opcode.saturating_sub(OP_1).saturating_add(1))
                        }
                        _ => 20,
                    };
                    count = count.saturating_add(sigops);
                }
                0x01..=0x4b => cursor = cursor.saturating_add(opcode as usize),
                OP_PUSHDATA1 => {
                    if let Some(len) = script.get(cursor).copied() {
                        cursor = cursor.saturating_add(1 + len as usize);
                    } else {
                        break;
                    }
                }
                OP_PUSHDATA2 => {
                    if cursor + 1 >= script.len() {
                        break;
                    }
                    let len = u16::from_le_bytes([script[cursor], script[cursor + 1]]) as usize;
                    cursor = cursor.saturating_add(2 + len);
                }
                OP_PUSHDATA4 => {
                    if cursor + 3 >= script.len() {
                        break;
                    }
                    let len = u32::from_le_bytes([
                        script[cursor],
                        script[cursor + 1],
                        script[cursor + 2],
                        script[cursor + 3],
                    ]) as usize;
                    cursor = cursor.saturating_add(4 + len);
                }
                _ => {}
            }
            prev_opcode = Some(opcode);
            if cursor > script.len() {
                break;
            }
        }
        count
    }

    fn tx_sigops(tx: &Transaction) -> u32 {
        let input_ops: u32 = tx
            .vin
            .iter()
            .map(|input| legacy_sigops(&input.script_sig))
            .sum();
        let output_ops: u32 = tx
            .vout
            .iter()
            .map(|output| legacy_sigops(&output.script_pubkey))
            .sum();
        input_ops.saturating_add(output_ops)
    }

    #[derive(Clone)]
    struct TemplateTx {
        fee: i64,
        modified_fee: i64,
        size: usize,
        priority: f64,
        fee_delta: i64,
        priority_delta: f64,
        parents: Vec<Hash256>,
    }

    #[derive(Clone, Copy, Debug)]
    struct PriorityTx {
        txid: Hash256,
        priority: f64,
        fee: i64,
        size: usize,
    }

    impl PartialEq for PriorityTx {
        fn eq(&self, other: &Self) -> bool {
            self.txid == other.txid
                && self.priority.to_bits() == other.priority.to_bits()
                && self.fee == other.fee
                && self.size == other.size
        }
    }

    impl Eq for PriorityTx {}

    impl Ord for PriorityTx {
        fn cmp(&self, other: &Self) -> std::cmp::Ordering {
            match self.priority.total_cmp(&other.priority) {
                std::cmp::Ordering::Equal => {
                    let fee_a = i128::from(self.fee);
                    let fee_b = i128::from(other.fee);
                    let size_a = i128::try_from(self.size.max(1)).unwrap_or(i128::MAX);
                    let size_b = i128::try_from(other.size.max(1)).unwrap_or(i128::MAX);
                    let left = fee_a.saturating_mul(size_b);
                    let right = fee_b.saturating_mul(size_a);
                    match left.cmp(&right) {
                        std::cmp::Ordering::Equal => self.txid.cmp(&other.txid),
                        other => other,
                    }
                }
                other => other,
            }
        }
    }

    impl PartialOrd for PriorityTx {
        fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
            Some(self.cmp(other))
        }
    }

    #[derive(Clone, Copy, Debug, Eq, PartialEq)]
    struct FeeRateTx {
        txid: Hash256,
        fee: i64,
        size: usize,
    }

    impl Ord for FeeRateTx {
        fn cmp(&self, other: &Self) -> std::cmp::Ordering {
            let fee_a = i128::from(self.fee);
            let fee_b = i128::from(other.fee);
            let size_a = i128::try_from(self.size.max(1)).unwrap_or(i128::MAX);
            let size_b = i128::try_from(other.size.max(1)).unwrap_or(i128::MAX);
            let left = fee_a.saturating_mul(size_b);
            let right = fee_b.saturating_mul(size_a);
            match left.cmp(&right) {
                std::cmp::Ordering::Equal => self.txid.cmp(&other.txid),
                other => other,
            }
        }
    }

    impl PartialOrd for FeeRateTx {
        fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
            Some(self.cmp(other))
        }
    }

    let coinbase_size = make_coinbase(0)
        .and_then(|tx| tx.consensus_encode().map_err(map_internal))
        .map(|bytes| bytes.len())?;
    let coinbase_overhead_bytes = 1024usize;
    let mut block_bytes_limit = usize::try_from(MAX_BLOCK_SIZE).unwrap_or(0);
    block_bytes_limit = block_bytes_limit
        .saturating_sub(coinbase_size)
        .saturating_sub(coinbase_overhead_bytes);
    let block_priority_bytes_limit = (usize::try_from(MAX_BLOCK_SIZE).unwrap_or(0) / 2)
        .min(block_bytes_limit)
        .max(1);

    const ALLOW_FREE_THRESHOLD: f64 = (COIN * 144 / 250) as f64;
    let allow_free = |priority: f64| priority > ALLOW_FREE_THRESHOLD;

    let (mempool_revision, selected_fees, transactions_json, sapling_commitments) = {
        let mempool_snapshot = mempool
            .lock()
            .map_err(|_| map_internal("mempool lock poisoned"))?;
        let mempool_revision = mempool_snapshot.revision();

        let mut templates: HashMap<Hash256, TemplateTx> = HashMap::new();
        for entry in mempool_snapshot.entries() {
            let mut modified_fee = entry.modified_fee();
            if entry.tx.fluxnode.is_some() {
                modified_fee = modified_fee.max(CENT);
            }
            templates.insert(
                entry.txid,
                TemplateTx {
                    fee: entry.fee,
                    modified_fee,
                    size: entry.size(),
                    priority: entry.modified_current_priority(height),
                    fee_delta: entry.fee_delta,
                    priority_delta: entry.priority_delta,
                    parents: entry.parents.clone(),
                },
            );
        }

        let mut children: HashMap<Hash256, Vec<Hash256>> = HashMap::new();
        let mut remaining_parents: HashMap<Hash256, usize> = HashMap::new();
        for (txid, tx) in &templates {
            let in_mempool_parents = tx
                .parents
                .iter()
                .filter(|parent| templates.contains_key(*parent))
                .count();
            remaining_parents.insert(*txid, in_mempool_parents);
            for parent in &tx.parents {
                if templates.contains_key(parent) {
                    children.entry(*parent).or_default().push(*txid);
                }
            }
        }

        let mut heap: BinaryHeap<FeeRateTx> = BinaryHeap::new();
        let mut priority_heap: BinaryHeap<PriorityTx> = BinaryHeap::new();
        for (txid, tx) in &templates {
            let parent_count = remaining_parents
                .get(txid)
                .copied()
                .unwrap_or(tx.parents.len());
            if parent_count == 0 {
                heap.push(FeeRateTx {
                    txid: *txid,
                    fee: tx.modified_fee,
                    size: tx.size,
                });
                priority_heap.push(PriorityTx {
                    txid: *txid,
                    priority: tx.priority,
                    fee: tx.modified_fee,
                    size: tx.size,
                });
            }
        }

        let mut selected: Vec<Hash256> = Vec::new();
        let mut selected_set: HashSet<Hash256> = HashSet::new();
        let mut selected_fees: i64 = 0;
        let mut selected_bytes: usize = 0;
        let mut sorted_by_fee = block_priority_bytes_limit == 0;

        while !heap.is_empty() || !priority_heap.is_empty() {
            let candidate_txid = if sorted_by_fee {
                heap.pop().map(|candidate| candidate.txid)
            } else {
                priority_heap
                    .pop()
                    .map(|candidate| candidate.txid)
                    .or_else(|| {
                        sorted_by_fee = true;
                        heap.pop().map(|candidate| candidate.txid)
                    })
            };
            let Some(candidate_txid) = candidate_txid else {
                break;
            };
            if selected_set.contains(&candidate_txid) {
                continue;
            }
            let Some(entry) = templates.get(&candidate_txid) else {
                continue;
            };

            if selected_bytes.saturating_add(entry.size) > block_bytes_limit {
                continue;
            }

            if sorted_by_fee
                && entry.priority_delta <= 0.0
                && entry.fee_delta <= 0
                && entry.modified_fee < mempool_policy.min_relay_fee_for_size(entry.size)
            {
                continue;
            }

            if !sorted_by_fee
                && (selected_bytes.saturating_add(entry.size) >= block_priority_bytes_limit
                    || !allow_free(entry.priority))
            {
                sorted_by_fee = true;
            }

            selected_fees = selected_fees
                .checked_add(entry.fee)
                .ok_or_else(|| map_internal("mempool fee overflow"))?;
            selected_bytes = selected_bytes.saturating_add(entry.size);
            selected_set.insert(candidate_txid);
            selected.push(candidate_txid);

            if let Some(outgoing) = children.get(&candidate_txid) {
                for child in outgoing {
                    let Some(count) = remaining_parents.get_mut(child) else {
                        continue;
                    };
                    *count = count.saturating_sub(1);
                    if *count == 0 {
                        if let Some(child_tx) = templates.get(child) {
                            heap.push(FeeRateTx {
                                txid: *child,
                                fee: child_tx.modified_fee,
                                size: child_tx.size,
                            });
                            priority_heap.push(PriorityTx {
                                txid: *child,
                                priority: child_tx.priority,
                                fee: child_tx.modified_fee,
                                size: child_tx.size,
                            });
                        }
                    }
                }
            }
        }

        let mut tx_index_by_id: HashMap<Hash256, usize> = HashMap::new();
        for (idx, txid) in selected.iter().copied().enumerate() {
            tx_index_by_id.insert(txid, idx + 1);
        }

        let mut transactions_json = Vec::with_capacity(selected.len());
        let mut sapling_commitments = Vec::new();
        for txid in &selected {
            let Some(entry) = mempool_snapshot.get(txid) else {
                continue;
            };
            let depends = entry
                .parents
                .iter()
                .filter_map(|parent| tx_index_by_id.get(parent).copied())
                .collect::<Vec<_>>();
            for output in &entry.tx.shielded_outputs {
                sapling_commitments.push(output.cm);
            }
            transactions_json.push(json!({
                "data": hex_bytes(&entry.raw),
                "hash": hash256_to_hex(txid),
                "fee": entry.fee,
                "depends": depends,
                "sigops": tx_sigops(&entry.tx),
            }));
        }

        Ok::<_, RpcError>((
            mempool_revision,
            selected_fees,
            transactions_json,
            sapling_commitments,
        ))
    }?;

    let miner_value = if pon_active {
        selected_fees
    } else {
        remainder
            .checked_add(selected_fees)
            .ok_or_else(|| map_internal("coinbase value out of range"))?
    };

    let coinbase = make_coinbase(miner_value)?;

    let coinbase_bytes = coinbase.consensus_encode().map_err(map_internal)?;
    let coinbase_txid = coinbase.txid().map_err(map_internal)?;
    let miner_reward = coinbase.vout.first().map(|out| out.value).unwrap_or(0);
    let coinbase_sigops = tx_sigops(&coinbase);

    let target = compact_to_u256(bits).map_err(|err| map_internal(err.to_string()))?;
    let target_hex = hex_bytes(&target.to_big_endian());

    let final_sapling_root = chainstate
        .sapling_root_after_commitments(&sapling_commitments)
        .map_err(map_internal)?;

    let longpollid = format!("{}{}", hash256_to_hex(&prev_hash), mempool_revision);

    let mut result = serde_json::Map::new();
    result.insert("capabilities".to_string(), json!(["proposal"]));
    result.insert(
        "version".to_string(),
        Value::Number(Number::from(if pon_active {
            PON_VERSION
        } else {
            CURRENT_VERSION
        })),
    );
    result.insert(
        "previousblockhash".to_string(),
        Value::String(hash256_to_hex(&prev_hash)),
    );
    result.insert(
        "finalsaplingroothash".to_string(),
        Value::String(hash256_to_hex(&final_sapling_root)),
    );
    result.insert("transactions".to_string(), Value::Array(transactions_json));
    result.insert(
        "coinbasetxn".to_string(),
        json!({
            "data": hex_bytes(&coinbase_bytes),
            "hash": hash256_to_hex(&coinbase_txid),
            "depends": [],
            "fee": -selected_fees,
            "sigops": coinbase_sigops,
            "required": true,
        }),
    );
    result.insert("longpollid".to_string(), Value::String(longpollid));
    result.insert("target".to_string(), Value::String(target_hex));
    result.insert("mintime".to_string(), Value::Number(Number::from(mintime)));
    result.insert(
        "mutable".to_string(),
        json!(["time", "transactions", "prevblock"]),
    );
    result.insert(
        "noncerange".to_string(),
        Value::String("00000000ffffffff".to_string()),
    );
    result.insert(
        "sigoplimit".to_string(),
        Value::Number(Number::from(MAX_BLOCK_SIGOPS)),
    );
    result.insert(
        "sizelimit".to_string(),
        Value::Number(Number::from(MAX_BLOCK_SIZE)),
    );
    result.insert("curtime".to_string(), Value::Number(Number::from(curtime)));
    result.insert("bits".to_string(), Value::String(format!("{:08x}", bits)));
    result.insert("height".to_string(), Value::Number(Number::from(height)));
    result.insert(
        "miner_reward".to_string(),
        Value::Number(Number::from(miner_reward)),
    );

    for (tier, _outpoint, script_pubkey, amount) in &payouts {
        let (legacy_name, renamed) = match *tier {
            2 => ("super", "nimbus"),
            3 => ("bamf", "stratus"),
            _ => ("basic", "cumulus"),
        };
        let address =
            script_pubkey_to_address(script_pubkey, chain_params.network).unwrap_or_default();
        result.insert(
            format!("{renamed}_fluxnode_address"),
            Value::String(address.clone()),
        );
        result.insert(
            format!("{renamed}_fluxnode_payout"),
            Value::Number(Number::from(*amount)),
        );

        result.insert(
            format!("{legacy_name}_zelnode_address"),
            Value::String(address.clone()),
        );
        result.insert(
            format!("{legacy_name}_zelnode_payout"),
            Value::Number(Number::from(*amount)),
        );
        result.insert(
            format!("{renamed}_zelnode_address"),
            Value::String(address.clone()),
        );
        result.insert(
            format!("{renamed}_zelnode_payout"),
            Value::Number(Number::from(*amount)),
        );
    }

    if exchange_fund > 0 {
        result.insert(
            "flux_creation_address".to_string(),
            Value::String(chain_params.funding.exchange_address.to_string()),
        );
        result.insert(
            "flux_creation_amount".to_string(),
            Value::Number(Number::from(exchange_fund)),
        );
    } else if foundation_fund > 0 {
        result.insert(
            "flux_creation_address".to_string(),
            Value::String(chain_params.funding.foundation_address.to_string()),
        );
        result.insert(
            "flux_creation_amount".to_string(),
            Value::Number(Number::from(foundation_fund)),
        );
    } else if swap_pool > 0 {
        result.insert(
            "flux_creation_address".to_string(),
            Value::String(chain_params.swap_pool.address.to_string()),
        );
        result.insert(
            "flux_creation_amount".to_string(),
            Value::Number(Number::from(swap_pool)),
        );
    }

    Ok(Value::Object(result))
}

fn script_push_int(value: i64) -> Vec<u8> {
    const OP_0: u8 = 0x00;
    const OP_1NEGATE: u8 = 0x4f;
    const OP_1: u8 = 0x51;

    if value == 0 {
        return vec![OP_0];
    }
    if value == -1 {
        return vec![OP_1NEGATE];
    }
    if (1..=16).contains(&value) {
        return vec![OP_1 + (value as u8 - 1)];
    }

    let data = crate::script_num_to_vec(value);
    let mut script = Vec::new();
    crate::push_data(&mut script, &data);
    script
}

fn rpc_getmininginfo<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    mempool: &Mutex<Mempool>,
    params: Vec<Value>,
    chain_params: &ChainParams,
    header_metrics: &HeaderMetrics,
) -> Result<Value, RpcError> {
    ensure_no_params(&params)?;

    let best_tip = chainstate.best_block().map_err(map_internal)?;
    let best_block = best_tip.as_ref().map(|tip| tip.height).unwrap_or(0);
    let (currentblocksize, currentblocktx) = match best_tip.as_ref() {
        Some(tip) => match chainstate
            .block_index_entry(&tip.hash)
            .map_err(map_internal)?
        {
            Some(entry) => (
                i64::try_from(entry.block.len).unwrap_or(0),
                i64::from(entry.tx_count),
            ),
            None => (0, 0),
        },
        None => (0, 0),
    };

    let best_header = chainstate
        .best_header()
        .map_err(map_internal)?
        .map(|tip| tip.hash);
    let difficulty = match best_header {
        Some(hash) => {
            let entry = chainstate
                .header_entry(&hash)
                .map_err(map_internal)?
                .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "missing header entry"))?;
            difficulty_from_bits(entry.bits, chain_params).unwrap_or(0.0)
        }
        None => 0.0,
    };

    let pooledtx = mempool
        .lock()
        .map_err(|_| map_internal("mempool lock poisoned"))?
        .size();

    let localsolps = local_solps(header_metrics)?;
    let network_solps = network_hashps(chainstate, chain_params, 120, -1).unwrap_or(0);

    Ok(json!({
        "blocks": best_block,
        "currentblocksize": currentblocksize,
        "currentblocktx": currentblocktx,
        "difficulty": difficulty,
        "errors": "",
        "generate": false,
        "genproclimit": -1,
        "localsolps": localsolps,
        "networksolps": network_solps,
        "networkhashps": network_solps,
        "pooledtx": pooledtx,
        "testnet": chain_params.network != Network::Mainnet,
        "chain": network_name(chain_params.network),
        "ponminter": false,
    }))
}

fn try_activate_best_header_from_unconnected<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    write_lock: &Mutex<()>,
    mempool: &Mutex<Mempool>,
    fee_estimator: &Mutex<FeeEstimator>,
    chain_params: &ChainParams,
    flags: &ValidationFlags,
) -> Result<Option<String>, RpcError> {
    crate::reorg_to_best_header(chainstate, write_lock).map_err(map_internal)?;

    const MAX_CONNECT_PER_CALL: usize = 512;
    loop {
        let missing = crate::collect_missing_blocks(chainstate, MAX_CONNECT_PER_CALL)
            .map_err(map_internal)?;
        if missing.is_empty() {
            return Ok(None);
        }

        let mut progressed = false;
        for hash in missing {
            let bytes = match chainstate
                .unconnected_block_bytes(&hash)
                .map_err(map_internal)?
            {
                Some(bytes) => bytes,
                None => return Ok(None),
            };
            let block = Block::consensus_decode(&bytes)
                .map_err(|_| RpcError::new(RPC_DESERIALIZATION_ERROR, "Block decode failed"))?;
            let header_entry = chainstate
                .header_entry(&hash)
                .map_err(map_internal)?
                .ok_or_else(|| map_internal("missing header entry for unconnected block"))?;

            let txids = match fluxd_chainstate::validation::validate_block_with_txids(
                &block,
                header_entry.height,
                &chain_params.consensus,
                flags,
            ) {
                Ok(txids) => txids,
                Err(err) => {
                    let reason = err.to_string();
                    return Ok(Some(if reason.is_empty() {
                        "rejected".to_string()
                    } else {
                        reason
                    }));
                }
            };

            let mut batch = match chainstate.connect_block(
                &block,
                header_entry.height,
                chain_params,
                flags,
                true,
                Some(txids.as_slice()),
                None,
                Some(bytes.as_slice()),
                None,
            ) {
                Ok(batch) => batch,
                Err(ChainStateError::InvalidHeader("block does not extend best block tip"))
                | Err(ChainStateError::InvalidHeader("block height does not match header index")) =>
                {
                    crate::reorg_to_best_header(chainstate, write_lock).map_err(map_internal)?;
                    return Ok(None);
                }
                Err(ChainStateError::InvalidHeader(message)) => {
                    return Ok(Some(message.to_string()));
                }
                Err(ChainStateError::Validation(err)) => {
                    let reason = err.to_string();
                    return Ok(Some(if reason.is_empty() {
                        "rejected".to_string()
                    } else {
                        reason
                    }));
                }
                Err(ChainStateError::MissingInput) => {
                    return Ok(Some("missing input".to_string()));
                }
                Err(ChainStateError::MissingHeader) => {
                    return Ok(Some("missing header".to_string()));
                }
                Err(ChainStateError::ValueOutOfRange) => {
                    return Ok(Some("value out of range".to_string()));
                }
                Err(err) => return Err(map_internal(err.to_string())),
            };
            chainstate.delete_unconnected_block(&mut batch, &hash);

            let should_reorg = {
                let _guard = write_lock
                    .lock()
                    .map_err(|_| map_internal("write lock poisoned"))?;
                let tip = chainstate.best_block().map_err(map_internal)?;
                if let Some(tip) = tip {
                    if tip.hash == hash {
                        false
                    } else if tip.hash != block.header.prev_block {
                        true
                    } else {
                        chainstate.commit_batch(batch).map_err(map_internal)?;
                        false
                    }
                } else {
                    true
                }
            };
            if should_reorg {
                crate::reorg_to_best_header(chainstate, write_lock).map_err(map_internal)?;
                return Ok(None);
            }

            let purge = crate::purge_mempool_for_connected_block(
                mempool,
                header_entry.height,
                &block,
                txids.as_slice(),
            )
            .map_err(map_internal)?;
            if !purge.removed_txids.is_empty() || !purge.mined_entries.is_empty() {
                let current_estimate = crate::current_fee_estimate(chainstate);
                if let Ok(mut estimator) = fee_estimator.lock() {
                    for txid in &purge.removed_txids {
                        estimator.remove_transaction(txid);
                    }
                    estimator.process_block(
                        u32::try_from(header_entry.height.max(0)).unwrap_or(0),
                        purge.mined_entries.as_slice(),
                        current_estimate,
                    );
                }
            }

            progressed = true;
        }

        if !progressed {
            return Ok(None);
        }
    }
}

fn rpc_submitblock<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    write_lock: &Mutex<()>,
    mempool: &Mutex<Mempool>,
    fee_estimator: &Mutex<FeeEstimator>,
    params: Vec<Value>,
    chain_params: &ChainParams,
    flags: &ValidationFlags,
) -> Result<Value, RpcError> {
    if params.is_empty() || params.len() > 2 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "submitblock expects 1 or 2 parameters",
        ));
    }
    let hex = params[0]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "block hex must be a string"))?;
    let bytes = bytes_from_hex(hex)
        .ok_or_else(|| RpcError::new(RPC_DESERIALIZATION_ERROR, "Block decode failed"))?;
    let block = Block::consensus_decode(&bytes)
        .map_err(|_| RpcError::new(RPC_DESERIALIZATION_ERROR, "Block decode failed"))?;
    let hash = block.header.hash();

    let mut block_present = false;
    if let Some(entry) = chainstate.header_entry(&hash).map_err(map_internal)? {
        block_present = true;
        if entry.has_block() {
            return Ok(Value::String("duplicate".to_string()));
        }
        if entry.is_failed() {
            return Ok(Value::String("duplicate-invalid".to_string()));
        }
        if chainstate
            .unconnected_block_bytes(&hash)
            .map_err(map_internal)?
            .is_some()
        {
            return Ok(Value::String("duplicate-inconclusive".to_string()));
        }
    }
    let duplicate_value = Value::String("duplicate".to_string());
    let map_result = |value: Value| {
        if block_present {
            duplicate_value.clone()
        } else {
            value
        }
    };

    let mark_block_failed = || -> Result<(), RpcError> {
        let mut batch = fluxd_storage::WriteBatch::new();
        chainstate
            .mark_header_failed(&mut batch, &hash)
            .map_err(map_internal)?;
        let _guard = write_lock
            .lock()
            .map_err(|_| map_internal("write lock poisoned"))?;
        chainstate.commit_batch(batch).map_err(map_internal)?;
        Ok(())
    };

    let prev_hash = block.header.prev_block;
    let best = chainstate.best_block().map_err(map_internal)?;
    let is_genesis = prev_hash == [0u8; 32] && hash == chain_params.consensus.hash_genesis_block;
    let extends_tip = match best.as_ref() {
        Some(tip) => tip.hash == prev_hash,
        None => is_genesis,
    };

    let height = if is_genesis {
        0
    } else {
        match best.as_ref() {
            Some(tip) if tip.hash == prev_hash => tip.height + 1,
            _ => -1,
        }
    };

    if extends_tip {
        if height < 0 {
            return Ok(map_result(Value::String("inconclusive".to_string())));
        }

        let txids = match fluxd_chainstate::validation::validate_block_with_txids(
            &block,
            height,
            &chain_params.consensus,
            flags,
        ) {
            Ok(txids) => txids,
            Err(err) => {
                let reason = err.to_string();
                if block_present {
                    mark_block_failed()?;
                }
                return Ok(map_result(Value::String(if reason.is_empty() {
                    "rejected".to_string()
                } else {
                    reason
                })));
            }
        };

        let mut batch = match chainstate.connect_block(
            &block,
            height,
            chain_params,
            flags,
            true,
            Some(txids.as_slice()),
            None,
            Some(bytes.as_slice()),
            None,
        ) {
            Ok(batch) => batch,
            Err(ChainStateError::InvalidHeader("block does not extend best block tip"))
            | Err(ChainStateError::InvalidHeader("block height does not match header index")) => {
                return Ok(map_result(Value::String("inconclusive".to_string())))
            }
            Err(ChainStateError::InvalidHeader(message)) => {
                if block_present {
                    mark_block_failed()?;
                }
                return Ok(map_result(Value::String(message.to_string())));
            }
            Err(ChainStateError::Validation(err)) => {
                let reason = err.to_string();
                if block_present {
                    mark_block_failed()?;
                }
                return Ok(map_result(Value::String(if reason.is_empty() {
                    "rejected".to_string()
                } else {
                    reason
                })));
            }
            Err(ChainStateError::MissingInput) => {
                return Ok(map_result(Value::String("missing input".to_string())))
            }
            Err(ChainStateError::MissingHeader) => {
                return Ok(map_result(Value::String("missing header".to_string())))
            }
            Err(ChainStateError::ValueOutOfRange) => {
                if block_present {
                    mark_block_failed()?;
                }
                return Ok(map_result(Value::String("value out of range".to_string())));
            }
            Err(err) => return Err(map_internal(err.to_string())),
        };
        chainstate.delete_unconnected_block(&mut batch, &hash);

        {
            let _guard = write_lock
                .lock()
                .map_err(|_| map_internal("write lock poisoned"))?;
            let current_tip = chainstate.best_block().map_err(map_internal)?;
            if let Some(tip) = current_tip {
                if tip.hash == hash {
                    return Ok(Value::String("duplicate".to_string()));
                }
                if tip.hash != prev_hash {
                    return Ok(map_result(Value::String("inconclusive".to_string())));
                }
            }
            chainstate.commit_batch(batch).map_err(map_internal)?;
        }

        let purge =
            crate::purge_mempool_for_connected_block(mempool, height, &block, txids.as_slice())
                .map_err(map_internal)?;
        if !purge.removed_txids.is_empty() || !purge.mined_entries.is_empty() {
            let current_estimate = crate::current_fee_estimate(chainstate);
            if let Ok(mut estimator) = fee_estimator.lock() {
                for txid in &purge.removed_txids {
                    estimator.remove_transaction(txid);
                }
                estimator.process_block(
                    u32::try_from(height.max(0)).unwrap_or(0),
                    purge.mined_entries.as_slice(),
                    current_estimate,
                );
            }
        }
        return Ok(map_result(Value::Null));
    }

    if !is_genesis && best.is_none() {
        return Ok(map_result(Value::String("inconclusive".to_string())));
    }

    let mut batch = fluxd_storage::WriteBatch::new();
    let header_entry =
        match chainstate.insert_header(&block.header, &chain_params.consensus, &mut batch) {
            Ok(entry) => entry,
            Err(ChainStateError::MissingHeader) => {
                return Ok(map_result(Value::String("inconclusive".to_string())))
            }
            Err(ChainStateError::InvalidHeader(message)) => {
                if block_present {
                    mark_block_failed()?;
                }
                return Ok(map_result(Value::String(message.to_string())));
            }
            Err(ChainStateError::Validation(err)) => {
                let reason = err.to_string();
                if block_present {
                    mark_block_failed()?;
                }
                return Ok(map_result(Value::String(if reason.is_empty() {
                    "rejected".to_string()
                } else {
                    reason
                })));
            }
            Err(err) => return Err(map_internal(err.to_string())),
        };

    if let Err(err) = fluxd_chainstate::validation::validate_block_with_txids(
        &block,
        header_entry.height,
        &chain_params.consensus,
        flags,
    ) {
        let reason = err.to_string();
        if block_present {
            mark_block_failed()?;
        }
        return Ok(map_result(Value::String(if reason.is_empty() {
            "rejected".to_string()
        } else {
            reason
        })));
    }

    chainstate.store_unconnected_block_bytes(&mut batch, &hash, bytes.as_slice());

    {
        let _guard = write_lock
            .lock()
            .map_err(|_| map_internal("write lock poisoned"))?;
        if chainstate
            .header_entry(&hash)
            .map_err(map_internal)?
            .is_some_and(|entry| entry.has_block())
        {
            return Ok(Value::String("duplicate".to_string()));
        }
        chainstate.commit_batch(batch).map_err(map_internal)?;
    }

    if let Some(reason) = try_activate_best_header_from_unconnected(
        chainstate,
        write_lock,
        mempool,
        fee_estimator,
        chain_params,
        flags,
    )? {
        return Ok(map_result(Value::String(reason)));
    }
    Ok(map_result(Value::Null))
}

fn rpc_getfluxnodecount<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    params: Vec<Value>,
) -> Result<Value, RpcError> {
    ensure_no_params(&params)?;
    let records = chainstate.fluxnode_records().map_err(map_internal)?;
    let mut cumulus_enabled = 0i64;
    let mut nimbus_enabled = 0i64;
    let mut stratus_enabled = 0i64;
    let mut ipv4 = 0i64;
    let mut ipv6 = 0i64;
    let mut onion = 0i64;

    for record in records {
        if record.confirmed_height == 0 {
            continue;
        }
        match record.tier {
            1 => cumulus_enabled += 1,
            2 => nimbus_enabled += 1,
            3 => stratus_enabled += 1,
            _ => {}
        }

        let (_host, network) = fluxnode_network_info(&record.ip);
        match network.as_str() {
            "ipv4" => ipv4 += 1,
            "ipv6" => ipv6 += 1,
            "onion" => onion += 1,
            _ => {}
        }
    }

    let total = cumulus_enabled + nimbus_enabled + stratus_enabled;

    Ok(json!({
        "total": total,
        "stable": total,
        "basic-enabled": cumulus_enabled,
        "super-enabled": nimbus_enabled,
        "bamf-enabled": stratus_enabled,
        "cumulus-enabled": cumulus_enabled,
        "nimbus-enabled": nimbus_enabled,
        "stratus-enabled": stratus_enabled,
        "ipv4": ipv4,
        "ipv6": ipv6,
        "onion": onion,
    }))
}

fn rpc_viewdeterministicfluxnodelist<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    if params.len() > 1 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "viewdeterministicfluxnodelist expects 0 or 1 parameter",
        ));
    }
    let filter = if params.is_empty() {
        String::new()
    } else {
        params[0].as_str().unwrap_or_default().to_string()
    };
    let records = chainstate.fluxnode_records().map_err(map_internal)?;
    let best_height = best_block_height(chainstate)?;
    let mut out = Vec::new();

    for tier_id in [1u8, 2u8, 3u8] {
        let mut tier_records: Vec<&FluxnodeRecord> = records
            .iter()
            .filter(|record| record.confirmed_height != 0 && record.tier == tier_id)
            .collect();
        tier_records.sort_by(|a, b| {
            let a_cmp = if a.last_paid_height > 0 {
                a.last_paid_height
            } else {
                a.confirmed_height
            };
            let b_cmp = if b.last_paid_height > 0 {
                b.last_paid_height
            } else {
                b.confirmed_height
            };
            a_cmp
                .cmp(&b_cmp)
                .then_with(|| (a.last_paid_height > 0).cmp(&(b.last_paid_height > 0)))
                .then_with(|| a.collateral.hash.cmp(&b.collateral.hash))
                .then_with(|| a.collateral.index.cmp(&b.collateral.index))
        });

        for (rank, record) in tier_records.into_iter().enumerate() {
            let txhash = hash256_to_hex(&record.collateral.hash);
            let pubkey = chainstate
                .fluxnode_key(record.operator_pubkey)
                .map_err(map_internal)?
                .unwrap_or_default();
            let pubkey_hex = hex_bytes(&pubkey);
            let payment_address =
                fluxnode_payment_address(chainstate, record, chain_params)?.unwrap_or_default();

            if !filter.is_empty()
                && txhash.find(&filter) == None
                && pubkey_hex.find(&filter) == None
                && record.ip.find(&filter) == None
                && payment_address.find(&filter) == None
            {
                continue;
            }

            let (_host, network) = fluxnode_network_info(&record.ip);
            let activesince = if best_height >= record.start_height as i32 {
                header_time_at_height(chainstate, record.start_height as i32)
                    .map(|time| Value::String(time.to_string()))
                    .unwrap_or_else(|| Value::Number(0.into()))
            } else {
                Value::Number(0.into())
            };
            let lastpaid = if best_height >= record.last_paid_height as i32 {
                header_time_at_height(chainstate, record.last_paid_height as i32)
                    .map(|time| Value::String(time.to_string()))
                    .unwrap_or_else(|| Value::Number(0.into()))
            } else {
                Value::Number(0.into())
            };

            let mut obj = serde_json::Map::new();
            obj.insert(
                "collateral".to_string(),
                Value::String(format_outpoint(&record.collateral)),
            );
            obj.insert("txhash".to_string(), Value::String(txhash));
            obj.insert(
                "outidx".to_string(),
                Value::Number((record.collateral.index as i64).into()),
            );
            obj.insert("ip".to_string(), Value::String(record.ip.clone()));
            obj.insert("network".to_string(), Value::String(network));
            obj.insert(
                "added_height".to_string(),
                Value::Number((record.start_height as i64).into()),
            );
            obj.insert(
                "confirmed_height".to_string(),
                Value::Number((record.confirmed_height as i64).into()),
            );
            obj.insert(
                "last_confirmed_height".to_string(),
                Value::Number((record.last_confirmed_height as i64).into()),
            );
            obj.insert(
                "last_paid_height".to_string(),
                Value::Number((record.last_paid_height as i64).into()),
            );
            obj.insert(
                "tier".to_string(),
                Value::String(fluxnode_tier_name(record.tier).to_string()),
            );
            obj.insert(
                "payment_address".to_string(),
                Value::String(payment_address),
            );
            obj.insert("pubkey".to_string(), Value::String(pubkey_hex));
            obj.insert("activesince".to_string(), activesince);
            obj.insert("lastpaid".to_string(), lastpaid);
            if record.collateral_value > 0 {
                obj.insert(
                    "amount".to_string(),
                    Value::String(format_money(record.collateral_value)),
                );
            }
            obj.insert("rank".to_string(), Value::Number((rank as i64).into()));

            out.push(Value::Object(obj));
        }
    }

    Ok(Value::Array(out))
}

fn rpc_fluxnodecurrentwinner<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    ensure_no_params(&params)?;
    let best_height = best_block_height(chainstate)?;
    let next_height = best_height.saturating_add(1);
    let payouts = chainstate
        .deterministic_fluxnode_payouts(next_height, chain_params)
        .map_err(map_internal)?;
    let mut records_by_outpoint: HashMap<OutPoint, FluxnodeRecord> = HashMap::new();
    for record in chainstate.fluxnode_records().map_err(map_internal)? {
        records_by_outpoint.insert(record.collateral.clone(), record);
    }

    let mut result = serde_json::Map::new();
    for (tier, outpoint, script_pubkey, _amount) in payouts {
        let Some(record) = records_by_outpoint.get(&outpoint) else {
            continue;
        };
        let payment_address =
            script_pubkey_to_address(&script_pubkey, chain_params.network).unwrap_or_default();
        let key = format!("{} Winner", fluxnode_tier_name(tier));
        result.insert(
            key,
            json!({
                "collateral": format_outpoint(&record.collateral),
                "ip": record.ip.clone(),
                "added_height": record.start_height,
                "confirmed_height": record.confirmed_height,
                "last_confirmed_height": record.last_confirmed_height,
                "last_paid_height": record.last_paid_height,
                "tier": fluxnode_tier_name(record.tier),
                "payment_address": payment_address,
            }),
        );
    }
    Ok(Value::Object(result))
}

fn rpc_listfluxnodeconf<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    params: Vec<Value>,
    chain_params: &ChainParams,
    data_dir: &Path,
) -> Result<Value, RpcError> {
    if params.len() > 1 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "listfluxnodeconf expects 0 or 1 parameter",
        ));
    }
    let filter = params
        .get(0)
        .and_then(|value| value.as_str())
        .unwrap_or_default()
        .to_ascii_lowercase();

    let conf_entries = read_fluxnode_conf(data_dir)?;
    if conf_entries.is_empty() {
        return Ok(Value::Array(Vec::new()));
    }

    let best_height = best_block_height(chainstate)?;
    let pon_active = network_upgrade_active(
        best_height,
        &chain_params.consensus.upgrades,
        UpgradeIndex::Pon,
    );
    let expiration = if pon_active {
        FLUXNODE_START_TX_EXPIRATION_HEIGHT_V2
    } else {
        FLUXNODE_START_TX_EXPIRATION_HEIGHT
    };
    let dos_remove = if pon_active {
        FLUXNODE_DOS_REMOVE_AMOUNT_V2
    } else {
        FLUXNODE_DOS_REMOVE_AMOUNT
    };

    let mut records_by_outpoint: HashMap<OutPoint, FluxnodeRecord> = HashMap::new();
    for record in chainstate.fluxnode_records().map_err(map_internal)? {
        records_by_outpoint.insert(record.collateral.clone(), record);
    }

    let mut out = Vec::with_capacity(conf_entries.len());
    for entry in conf_entries {
        let record = records_by_outpoint.get(&entry.collateral);
        let status = match record {
            Some(record) if record.confirmed_height != 0 => "CONFIRMED",
            Some(record) if best_height >= record.start_height as i32 => {
                let age = best_height.saturating_sub(record.start_height as i32);
                if age <= expiration {
                    "STARTED"
                } else if age <= dos_remove {
                    "DOS"
                } else {
                    "OFFLINE"
                }
            }
            Some(_) => "STARTED",
            None => "OFFLINE",
        };

        let (ip, network) = fluxnode_network_info(&entry.address);
        let collateral_str = format_outpoint(&entry.collateral);
        let txhash_hex = hash256_to_hex(&entry.collateral.hash);

        let mut obj = serde_json::Map::new();
        obj.insert("alias".to_string(), Value::String(entry.alias));
        obj.insert("status".to_string(), Value::String(status.to_string()));
        obj.insert(
            "collateral".to_string(),
            Value::String(collateral_str.clone()),
        );
        obj.insert("txHash".to_string(), Value::String(txhash_hex.clone()));
        obj.insert(
            "outputIndex".to_string(),
            Value::Number((entry.collateral.index as i64).into()),
        );
        obj.insert("privateKey".to_string(), Value::String(entry.privkey));
        obj.insert("address".to_string(), Value::String(entry.address));

        obj.insert("ip".to_string(), Value::String(ip));
        obj.insert("network".to_string(), Value::String(network));

        if let Some(record) = record {
            let payment_address = fluxnode_payment_address(chainstate, record, chain_params)?
                .unwrap_or_else(|| "UNKNOWN".to_string());
            obj.insert(
                "added_height".to_string(),
                Value::Number((record.start_height as i64).into()),
            );
            obj.insert(
                "confirmed_height".to_string(),
                Value::Number((record.confirmed_height as i64).into()),
            );
            obj.insert(
                "last_confirmed_height".to_string(),
                Value::Number((record.last_confirmed_height as i64).into()),
            );
            obj.insert(
                "last_paid_height".to_string(),
                Value::Number((record.last_paid_height as i64).into()),
            );
            obj.insert(
                "tier".to_string(),
                Value::String(fluxnode_tier_name(record.tier).to_string()),
            );
            obj.insert(
                "payment_address".to_string(),
                Value::String(payment_address),
            );
            let activesince = header_time_at_height(chainstate, record.start_height as i32)
                .unwrap_or_default() as i64;
            let lastpaid =
                if record.last_paid_height == 0 || best_height < record.last_paid_height as i32 {
                    0
                } else {
                    header_time_at_height(chainstate, record.last_paid_height as i32)
                        .unwrap_or_default() as i64
                };
            obj.insert("activesince".to_string(), Value::Number(activesince.into()));
            obj.insert("lastpaid".to_string(), Value::Number(lastpaid.into()));
        } else {
            obj.insert("added_height".to_string(), Value::Number(0.into()));
            obj.insert("confirmed_height".to_string(), Value::Number(0.into()));
            obj.insert("last_confirmed_height".to_string(), Value::Number(0.into()));
            obj.insert("last_paid_height".to_string(), Value::Number(0.into()));
            obj.insert("tier".to_string(), Value::String("UNKNOWN".to_string()));
            obj.insert(
                "payment_address".to_string(),
                Value::String("UNKNOWN".to_string()),
            );
            obj.insert("activesince".to_string(), Value::Number(0.into()));
            obj.insert("lastpaid".to_string(), Value::Number(0.into()));
        }

        if !filter.is_empty() {
            let haystack = format!(
                "{} {} {} {} {}",
                obj.get("alias")
                    .and_then(|value| value.as_str())
                    .unwrap_or_default(),
                obj.get("address")
                    .and_then(|value| value.as_str())
                    .unwrap_or_default(),
                txhash_hex,
                status,
                collateral_str
            )
            .to_ascii_lowercase();
            if !haystack.contains(&filter) {
                continue;
            }
        }

        out.push(Value::Object(obj));
    }

    Ok(Value::Array(out))
}

fn rpc_getfluxnodeoutputs<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    params: Vec<Value>,
    chain_params: &ChainParams,
    data_dir: &Path,
) -> Result<Value, RpcError> {
    ensure_no_params(&params)?;

    let conf_entries = read_fluxnode_conf(data_dir)?;
    if conf_entries.is_empty() {
        return Err(RpcError::new(
            RPC_INTERNAL_ERROR,
            "This is not a Flux Node (no fluxnode.conf entry found)",
        ));
    }

    let best_height = best_block_height(chainstate)?;
    let best_u32 = u32::try_from(best_height).unwrap_or(0);

    let mut out = Vec::new();
    for entry in conf_entries {
        let utxo = chainstate
            .utxo_entry(&entry.collateral)
            .map_err(map_internal)?;
        let Some(utxo) = utxo else {
            continue;
        };
        if utxo.is_coinbase {
            continue;
        }
        if fluxd_consensus::fluxnode_tier_from_collateral(
            best_height,
            utxo.value,
            &chain_params.fluxnode,
        )
        .is_none()
        {
            continue;
        }

        let confirmations = best_u32.saturating_sub(utxo.height).saturating_add(1);
        out.push(json!({
            "txhash": hash256_to_hex(&entry.collateral.hash),
            "outputidx": entry.collateral.index,
            "Flux Amount": amount_to_value(utxo.value),
            "Confirmations": confirmations,
        }));
    }

    Ok(Value::Array(out))
}

fn mempool_contains_fluxnode_outpoint(mempool: &Mempool, outpoint: &OutPoint) -> bool {
    mempool.entries().any(|entry| {
        let Some(fluxnode) = entry.tx.fluxnode.as_ref() else {
            return false;
        };
        match fluxnode {
            FluxnodeTx::V5(FluxnodeTxV5::Start(start)) => &start.collateral == outpoint,
            FluxnodeTx::V6(FluxnodeTxV6::Start(start)) => match &start.variant {
                FluxnodeStartVariantV6::Normal { collateral, .. } => collateral == outpoint,
                FluxnodeStartVariantV6::P2sh { collateral, .. } => collateral == outpoint,
            },
            FluxnodeTx::V5(FluxnodeTxV5::Confirm(confirm))
            | FluxnodeTx::V6(FluxnodeTxV6::Confirm(confirm)) => &confirm.collateral == outpoint,
        }
    })
}

fn fluxnode_start_blocked_reason(
    best_height: i32,
    record: &FluxnodeRecord,
    expiration: i32,
    dos_remove: i32,
) -> Option<&'static str> {
    if record.confirmed_height != 0 {
        return Some("Fluxnode already confirmed and in fluxnode list");
    }
    if best_height < record.start_height as i32 {
        return Some("Fluxnode already started, waiting to be confirmed");
    }
    let age = best_height.saturating_sub(record.start_height as i32);
    if age <= expiration {
        return Some("Fluxnode already started, waiting to be confirmed");
    }
    if age <= dos_remove {
        return Some("Fluxnode already started then not confirmed, in DoS tracker. Must wait until out of DoS tracker to start");
    }
    None
}

fn extract_p2pkh_hash(script_pubkey: &[u8]) -> Option<[u8; 20]> {
    if script_pubkey.len() != 25 {
        return None;
    }
    if script_pubkey[0] != 0x76
        || script_pubkey[1] != 0xa9
        || script_pubkey[2] != 0x14
        || script_pubkey[23] != 0x88
        || script_pubkey[24] != 0xac
    {
        return None;
    }
    let mut out = [0u8; 20];
    out.copy_from_slice(&script_pubkey[3..23]);
    Some(out)
}

fn extract_p2sh_hash(script_pubkey: &[u8]) -> Option<[u8; 20]> {
    if script_pubkey.len() != 23 {
        return None;
    }
    if script_pubkey[0] != 0xa9 || script_pubkey[1] != 0x14 || script_pubkey[22] != 0x87 {
        return None;
    }
    let mut out = [0u8; 20];
    out.copy_from_slice(&script_pubkey[2..22]);
    Some(out)
}

fn parse_multisig_redeem_script(script: &[u8]) -> Option<Vec<Vec<u8>>> {
    const OP_1: u8 = 0x51;
    const OP_16: u8 = 0x60;
    const OP_CHECKMULTISIG: u8 = 0xae;
    const OP_PUSHDATA1: u8 = 0x4c;
    const OP_PUSHDATA2: u8 = 0x4d;

    if script.len() < 3 {
        return None;
    }
    let mut cursor = 0usize;
    let required_opcode = *script.get(cursor)?;
    cursor += 1;
    if !(OP_1..=OP_16).contains(&required_opcode) {
        return None;
    }
    let required = required_opcode - OP_1 + 1;

    let mut pubkeys: Vec<Vec<u8>> = Vec::new();
    while cursor < script.len() {
        let op = *script.get(cursor)?;
        if (OP_1..=OP_16).contains(&op) {
            break;
        }
        cursor += 1;
        let len = if op <= 75 {
            op as usize
        } else if op == OP_PUSHDATA1 {
            let len = *script.get(cursor)? as usize;
            cursor += 1;
            len
        } else if op == OP_PUSHDATA2 {
            let lo = *script.get(cursor)? as u16;
            let hi = *script.get(cursor + 1)? as u16;
            cursor += 2;
            u16::from_le_bytes([lo as u8, hi as u8]) as usize
        } else {
            return None;
        };
        if cursor + len > script.len() {
            return None;
        }
        let data = &script[cursor..cursor + len];
        cursor += len;
        if matches!(data.len(), 33 | 65) {
            pubkeys.push(data.to_vec());
        }
    }

    let total_opcode = *script.get(cursor)?;
    cursor += 1;
    if !(OP_1..=OP_16).contains(&total_opcode) {
        return None;
    }
    let total = total_opcode - OP_1 + 1;

    if cursor >= script.len() || script[cursor] != OP_CHECKMULTISIG {
        return None;
    }
    cursor += 1;
    if cursor != script.len() {
        return None;
    }
    if total as usize != pubkeys.len() || required > total {
        return None;
    }
    Some(pubkeys)
}

fn lock_wallet_if_requested(wallet: &Mutex<Wallet>, lockwallet: bool) -> Result<(), RpcError> {
    if !lockwallet {
        return Ok(());
    }
    let mut guard = wallet
        .lock()
        .map_err(|_| map_internal("wallet lock poisoned"))?;
    match guard.walletlock() {
        Ok(()) => Ok(()),
        Err(WalletError::WalletNotEncrypted) => Ok(()),
        Err(err) => Err(map_wallet_error(err)),
    }
}

fn decode_redeem_script_hex(hex: &str) -> Result<Vec<u8>, RpcError> {
    bytes_from_hex(hex)
        .ok_or_else(|| RpcError::new(RPC_DESERIALIZATION_ERROR, "redeem script decode failed"))
}

fn resolve_fluxnode_collateral_secret_and_redeem_script<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    wallet: &Mutex<Wallet>,
    entry: &FluxnodeConfEntry,
    chain_params: &ChainParams,
    collateral_wif: Option<&str>,
    redeem_script_hex: Option<&str>,
) -> Result<(SecretKey, Option<Vec<u8>>), RpcError> {
    let redeem_script_override = match redeem_script_hex {
        Some(hex) => Some(decode_redeem_script_hex(hex)?),
        None => None,
    };

    let utxo = chainstate
        .utxo_entry(&entry.collateral)
        .map_err(map_internal)?
        .ok_or_else(|| RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "collateral output not found"))?;

    let script_type = classify_script_pubkey(&utxo.script_pubkey);

    if let Some(wif) = collateral_wif {
        let (secret, _compressed) = parse_wif_secret_key(wif, chain_params.network)?;
        let redeem_script = if script_type == ScriptType::P2Sh {
            if redeem_script_override.is_some() {
                redeem_script_override
            } else {
                let guard = wallet
                    .lock()
                    .map_err(|_| map_internal("wallet lock poisoned"))?;
                guard.redeem_script_for_p2sh_script_pubkey(&utxo.script_pubkey)
            }
        } else {
            redeem_script_override
        };
        return Ok((secret, redeem_script));
    }

    let guard = wallet
        .lock()
        .map_err(|_| map_internal("wallet lock poisoned"))?;

    match script_type {
        ScriptType::P2Pkh => {
            let Some((secret, _pubkey)) = guard
                .signing_key_for_script_pubkey(&utxo.script_pubkey)
                .map_err(map_wallet_error)?
            else {
                return Err(RpcError::new(
                    RPC_WALLET_ERROR,
                    "collateral private key not found in wallet",
                ));
            };
            Ok((secret, redeem_script_override))
        }
        ScriptType::P2Sh => {
            let redeem_script = if let Some(script) = redeem_script_override {
                script
            } else {
                guard
                    .redeem_script_for_p2sh_script_pubkey(&utxo.script_pubkey)
                    .ok_or_else(|| {
                        RpcError::new(
                            RPC_INVALID_PARAMETER,
                            "missing redeem script for p2sh collateral",
                        )
                    })?
            };

            let pubkeys = parse_multisig_redeem_script(&redeem_script).ok_or_else(|| {
                RpcError::new(RPC_INVALID_PARAMETER, "redeem script not multisig")
            })?;

            for pubkey_bytes in pubkeys {
                let pubkey = PublicKey::from_slice(&pubkey_bytes).map_err(|_| {
                    RpcError::new(
                        RPC_INVALID_PARAMETER,
                        "redeem script contains invalid pubkey",
                    )
                })?;
                if let Some(secret) = guard
                    .signing_key_for_pubkey(&pubkey)
                    .map_err(map_wallet_error)?
                {
                    return Ok((secret, Some(redeem_script)));
                }
            }

            Err(RpcError::new(
                RPC_WALLET_ERROR,
                "collateral private key not found in wallet",
            ))
        }
        _ => Err(RpcError::new(
            RPC_INVALID_ADDRESS_OR_KEY,
            "collateral output script unsupported",
        )),
    }
}

fn build_fluxnode_start_tx<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    entry: &FluxnodeConfEntry,
    chain_params: &ChainParams,
    collateral_secret: &SecretKey,
    redeem_script: Option<Vec<u8>>,
    delegates_update: Option<Vec<Vec<u8>>>,
) -> Result<Transaction, RpcError> {
    let best_height = best_block_height(chainstate)?;
    let next_height = best_height.saturating_add(1);

    if !network_upgrade_active(
        next_height,
        &chain_params.consensus.upgrades,
        UpgradeIndex::Kamata,
    ) {
        return Err(RpcError::new(
            RPC_INTERNAL_ERROR,
            "deterministic fluxnodes transactions is not active yet",
        ));
    }

    let p2sh_active = network_upgrade_active(
        next_height,
        &chain_params.consensus.upgrades,
        UpgradeIndex::P2ShNodes,
    );

    let pon_active = network_upgrade_active(
        next_height,
        &chain_params.consensus.upgrades,
        UpgradeIndex::Pon,
    );
    if delegates_update.is_some() && !pon_active {
        return Err(RpcError::new(
            RPC_INTERNAL_ERROR,
            "fluxnode delegates feature not active yet",
        ));
    }
    if delegates_update.is_some() && !p2sh_active {
        return Err(RpcError::new(
            RPC_INTERNAL_ERROR,
            "fluxnode delegates requires P2SH nodes activation",
        ));
    }
    let using_delegates = delegates_update.is_some();
    let delegates_payload = delegates_update.map(|delegate_starting_keys| FluxnodeDelegates {
        version: FluxnodeDelegates::INITIAL_VERSION,
        kind: FluxnodeDelegates::UPDATE,
        delegate_starting_keys,
    });

    let (operator_secret, operator_compressed) =
        parse_wif_secret_key(&entry.privkey, chain_params.network)?;
    let operator_pubkey = secret_key_pubkey_bytes(&operator_secret, operator_compressed);

    let utxo = chainstate
        .utxo_entry(&entry.collateral)
        .map_err(map_internal)?
        .ok_or_else(|| RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "collateral output not found"))?;

    let sig_time = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_secs()
        .try_into()
        .unwrap_or(u32::MAX);

    match classify_script_pubkey(&utxo.script_pubkey) {
        ScriptType::P2Pkh => {
            let pubkey_hash = extract_p2pkh_hash(&utxo.script_pubkey)
                .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "invalid p2pkh script"))?;

            let compressed_pubkey = secret_key_pubkey_bytes(collateral_secret, true);
            let uncompressed_pubkey = secret_key_pubkey_bytes(collateral_secret, false);

            let (collateral_pubkey, collateral_compressed) =
                if hash160(&compressed_pubkey) == pubkey_hash {
                    (compressed_pubkey, true)
                } else if hash160(&uncompressed_pubkey) == pubkey_hash {
                    (uncompressed_pubkey, false)
                } else {
                    return Err(RpcError::new(
                        RPC_INVALID_ADDRESS_OR_KEY,
                        "collateral private key does not match collateral output",
                    ));
                };

            let mut tx = if p2sh_active {
                Transaction {
                    f_overwintered: false,
                    version: FLUXNODE_TX_UPGRADEABLE_VERSION,
                    version_group_id: 0,
                    vin: Vec::new(),
                    vout: Vec::new(),
                    lock_time: 0,
                    expiry_height: 0,
                    value_balance: 0,
                    shielded_spends: Vec::new(),
                    shielded_outputs: Vec::new(),
                    join_splits: Vec::new(),
                    join_split_pub_key: [0u8; 32],
                    join_split_sig: [0u8; 64],
                    binding_sig: [0u8; 64],
                    fluxnode: Some(FluxnodeTx::V6(FluxnodeTxV6::Start(FluxnodeStartV6 {
                        flux_tx_version: if using_delegates {
                            FLUXNODE_TX_TYPE_NORMAL_BIT | FLUXNODE_TX_FEATURE_DELEGATES_BIT
                        } else {
                            FLUXNODE_INTERNAL_NORMAL_TX_VERSION
                        },
                        variant: FluxnodeStartVariantV6::Normal {
                            collateral: entry.collateral.clone(),
                            collateral_pubkey: collateral_pubkey.clone(),
                            pubkey: operator_pubkey,
                            sig_time,
                            sig: Vec::new(),
                        },
                        using_delegates,
                        delegates: delegates_payload.clone(),
                    }))),
                }
            } else {
                Transaction {
                    f_overwintered: false,
                    version: FLUXNODE_TX_VERSION,
                    version_group_id: 0,
                    vin: Vec::new(),
                    vout: Vec::new(),
                    lock_time: 0,
                    expiry_height: 0,
                    value_balance: 0,
                    shielded_spends: Vec::new(),
                    shielded_outputs: Vec::new(),
                    join_splits: Vec::new(),
                    join_split_pub_key: [0u8; 32],
                    join_split_sig: [0u8; 64],
                    binding_sig: [0u8; 64],
                    fluxnode: Some(FluxnodeTx::V5(FluxnodeTxV5::Start(FluxnodeStartV5 {
                        collateral: entry.collateral.clone(),
                        collateral_pubkey: collateral_pubkey.clone(),
                        pubkey: operator_pubkey,
                        sig_time,
                        sig: Vec::new(),
                    }))),
                }
            };

            let txid = tx.txid().map_err(map_internal)?;
            let message = hash256_to_hex(&txid).into_bytes();
            let sig_bytes =
                sign_compact_message(collateral_secret, collateral_compressed, &message)?;

            match tx.fluxnode.as_mut() {
                Some(FluxnodeTx::V5(FluxnodeTxV5::Start(start))) => {
                    start.sig = sig_bytes.to_vec();
                }
                Some(FluxnodeTx::V6(FluxnodeTxV6::Start(start))) => {
                    if let FluxnodeStartVariantV6::Normal { sig: sig_field, .. } =
                        &mut start.variant
                    {
                        *sig_field = sig_bytes.to_vec();
                    }
                }
                _ => {}
            }

            Ok(tx)
        }
        ScriptType::P2Sh => {
            if !p2sh_active {
                return Err(RpcError::new(
                    RPC_INTERNAL_ERROR,
                    "p2sh collateral requires P2SH nodes activation",
                ));
            }

            let redeem_script = redeem_script.ok_or_else(|| {
                RpcError::new(
                    RPC_INVALID_PARAMETER,
                    "missing redeem script for p2sh collateral",
                )
            })?;

            let script_hash = extract_p2sh_hash(&utxo.script_pubkey)
                .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "invalid p2sh script"))?;
            if hash160(&redeem_script) != script_hash {
                return Err(RpcError::new(
                    RPC_INVALID_PARAMETER,
                    "redeem script hash mismatch",
                ));
            }

            let pubkeys = parse_multisig_redeem_script(&redeem_script).ok_or_else(|| {
                RpcError::new(RPC_INVALID_PARAMETER, "redeem script not multisig")
            })?;

            let compressed_pubkey = secret_key_pubkey_bytes(collateral_secret, true);
            let uncompressed_pubkey = secret_key_pubkey_bytes(collateral_secret, false);

            let collateral_compressed = if pubkeys.iter().any(|pk| pk == &compressed_pubkey) {
                true
            } else if pubkeys.iter().any(|pk| pk == &uncompressed_pubkey) {
                false
            } else {
                return Err(RpcError::new(
                    RPC_INVALID_ADDRESS_OR_KEY,
                    "collateral private key not present in redeem script",
                ));
            };

            let mut tx = Transaction {
                f_overwintered: false,
                version: FLUXNODE_TX_UPGRADEABLE_VERSION,
                version_group_id: 0,
                vin: Vec::new(),
                vout: Vec::new(),
                lock_time: 0,
                expiry_height: 0,
                value_balance: 0,
                shielded_spends: Vec::new(),
                shielded_outputs: Vec::new(),
                join_splits: Vec::new(),
                join_split_pub_key: [0u8; 32],
                join_split_sig: [0u8; 64],
                binding_sig: [0u8; 64],
                fluxnode: Some(FluxnodeTx::V6(FluxnodeTxV6::Start(FluxnodeStartV6 {
                    flux_tx_version: if using_delegates {
                        FLUXNODE_TX_TYPE_P2SH_BIT | FLUXNODE_TX_FEATURE_DELEGATES_BIT
                    } else {
                        FLUXNODE_INTERNAL_P2SH_TX_VERSION
                    },
                    variant: FluxnodeStartVariantV6::P2sh {
                        collateral: entry.collateral.clone(),
                        pubkey: operator_pubkey,
                        redeem_script,
                        sig_time,
                        sig: Vec::new(),
                    },
                    using_delegates,
                    delegates: delegates_payload.clone(),
                }))),
            };

            let txid = tx.txid().map_err(map_internal)?;
            let message = hash256_to_hex(&txid).into_bytes();
            let sig = sign_compact_message(collateral_secret, collateral_compressed, &message)?;

            if let Some(FluxnodeTx::V6(FluxnodeTxV6::Start(start))) = tx.fluxnode.as_mut() {
                if let FluxnodeStartVariantV6::P2sh { sig: sig_field, .. } = &mut start.variant {
                    *sig_field = sig.to_vec();
                }
            }

            Ok(tx)
        }
        _ => Err(RpcError::new(
            RPC_INVALID_ADDRESS_OR_KEY,
            "collateral output script unsupported",
        )),
    }
}

fn rpc_startdeterministicfluxnode<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    wallet: &Mutex<Wallet>,
    mempool: &Mutex<Mempool>,
    mempool_policy: &MempoolPolicy,
    mempool_metrics: &MempoolMetrics,
    fee_estimator: &Mutex<FeeEstimator>,
    mempool_flags: &ValidationFlags,
    params: Vec<Value>,
    chain_params: &ChainParams,
    tx_announce: &broadcast::Sender<Hash256>,
    data_dir: &Path,
) -> Result<Value, RpcError> {
    if params.len() < 2 || params.len() > 4 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "startdeterministicfluxnode expects 2 to 4 parameters",
        ));
    }

    let alias = params[0]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "alias must be a string"))?
        .to_string();
    let lockwallet = parse_bool(&params[1])?;
    let collateral_wif_override = params.get(2).and_then(|value| value.as_str());
    let redeem_script_override = params.get(3).and_then(|value| value.as_str());

    let conf_entries = read_fluxnode_conf(data_dir)?;
    let selected = conf_entries.iter().find(|entry| entry.alias == alias);

    let mut detail = serde_json::Map::new();
    detail.insert("alias".to_string(), Value::String(alias.clone()));
    detail.insert("outpoint".to_string(), Value::String(String::new()));
    detail.insert(
        "transaction_built".to_string(),
        Value::String("failed".to_string()),
    );
    detail.insert(
        "transaction_signed".to_string(),
        Value::String("failed".to_string()),
    );
    detail.insert(
        "transaction_commited".to_string(),
        Value::String("failed".to_string()),
    );
    detail.insert("result".to_string(), Value::String("failed".to_string()));
    detail.insert("errorMessage".to_string(), Value::String(String::new()));

    let mut successful = 0;
    let mut failed = 0;

    let Some(entry) = selected else {
        failed = 1;
        detail.insert(
            "error".to_string(),
            Value::String(
                "could not find alias in config. Verify with listfluxnodeconf.".to_string(),
            ),
        );
        lock_wallet_if_requested(wallet, lockwallet)?;
        return Ok(json!({
            "overall": format!("Successfully started {successful} fluxnodes, failed to start {failed}, total {}", successful + failed),
            "detail": [Value::Object(detail)],
        }));
    };

    detail.insert(
        "outpoint".to_string(),
        Value::String(format_outpoint(&entry.collateral)),
    );

    let best_height = best_block_height(chainstate)?;
    let pon_active = network_upgrade_active(
        best_height,
        &chain_params.consensus.upgrades,
        UpgradeIndex::Pon,
    );
    let expiration = if pon_active {
        FLUXNODE_START_TX_EXPIRATION_HEIGHT_V2
    } else {
        FLUXNODE_START_TX_EXPIRATION_HEIGHT
    };
    let dos_remove = if pon_active {
        FLUXNODE_DOS_REMOVE_AMOUNT_V2
    } else {
        FLUXNODE_DOS_REMOVE_AMOUNT
    };

    let record = chainstate
        .fluxnode_records()
        .map_err(map_internal)?
        .into_iter()
        .find(|record| record.collateral == entry.collateral);
    if let Some(record) = record {
        if let Some(reason) =
            fluxnode_start_blocked_reason(best_height, &record, expiration, dos_remove)
        {
            failed = 1;
            detail.insert("result".to_string(), Value::String("failed".to_string()));
            detail.insert("reason".to_string(), Value::String(reason.to_string()));
            return Ok(json!({
                "overall": format!("Successfully started {successful} fluxnodes, failed to start {failed}, total {}", successful + failed),
                "detail": [Value::Object(detail)],
            }));
        }
    }

    {
        let guard = mempool
            .lock()
            .map_err(|_| map_internal("mempool lock poisoned"))?;
        if mempool_contains_fluxnode_outpoint(&guard, &entry.collateral) {
            failed = 1;
            detail.insert("result".to_string(), Value::String("failed".to_string()));
            detail.insert(
                "reason".to_string(),
                Value::String(
                    "Mempool already has a fluxnode transaction using this outpoint".to_string(),
                ),
            );
            return Ok(json!({
                "overall": format!("Successfully started {successful} fluxnodes, failed to start {failed}, total {}", successful + failed),
                "detail": [Value::Object(detail)],
            }));
        }
    }

    let collateral_wif = collateral_wif_override.or(entry.collateral_privkey.as_deref());
    let redeem_script_hex = redeem_script_override.or(entry.redeem_script.as_deref());

    let (collateral_secret, redeem_script) =
        match resolve_fluxnode_collateral_secret_and_redeem_script(
            chainstate,
            wallet,
            entry,
            chain_params,
            collateral_wif,
            redeem_script_hex,
        ) {
            Ok(resolved) => resolved,
            Err(err) => {
                if collateral_wif.is_none() && err.code == RPC_WALLET_UNLOCK_NEEDED {
                    return Err(err);
                }
                failed = 1;
                detail.insert("result".to_string(), Value::String("failed".to_string()));
                detail.insert("errorMessage".to_string(), Value::String(err.message));
                lock_wallet_if_requested(wallet, lockwallet)?;
                return Ok(json!({
                    "overall": format!("Successfully started {successful} fluxnodes, failed to start {failed}, total {}", successful + failed),
                    "detail": [Value::Object(detail)],
                }));
            }
        };

    let tx = match build_fluxnode_start_tx(
        chainstate,
        entry,
        chain_params,
        &collateral_secret,
        redeem_script,
        None,
    ) {
        Ok(tx) => tx,
        Err(err) => {
            failed = 1;
            detail.insert("errorMessage".to_string(), Value::String(err.message));
            lock_wallet_if_requested(wallet, lockwallet)?;
            return Ok(json!({
                "overall": format!("Successfully started {successful} fluxnodes, failed to start {failed}, total {}", successful + failed),
                "detail": [Value::Object(detail)],
            }));
        }
    };

    detail.insert(
        "transaction_built".to_string(),
        Value::String("successful".to_string()),
    );
    detail.insert(
        "transaction_signed".to_string(),
        Value::String("successful".to_string()),
    );

    let raw = tx.consensus_encode().map_err(map_internal)?;
    let raw_hex = hex_bytes(&raw);

    match rpc_sendrawtransaction(
        chainstate,
        mempool,
        mempool_policy,
        mempool_metrics,
        fee_estimator,
        mempool_flags,
        vec![Value::String(raw_hex)],
        chain_params,
        tx_announce,
    ) {
        Ok(txid) => {
            successful = 1;
            detail.insert(
                "transaction_commited".to_string(),
                Value::String("successful".to_string()),
            );
            detail.insert(
                "result".to_string(),
                Value::String("successful".to_string()),
            );
            detail.insert("txid".to_string(), txid);
        }
        Err(err) => {
            failed = 1;
            detail.insert("errorMessage".to_string(), Value::String(err.message));
        }
    }

    lock_wallet_if_requested(wallet, lockwallet)?;
    Ok(json!({
        "overall": format!("Successfully started {successful} fluxnodes, failed to start {failed}, total {}", successful + failed),
        "detail": [Value::Object(detail)],
    }))
}

fn rpc_startfluxnode<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    wallet: &Mutex<Wallet>,
    mempool: &Mutex<Mempool>,
    mempool_policy: &MempoolPolicy,
    mempool_metrics: &MempoolMetrics,
    fee_estimator: &Mutex<FeeEstimator>,
    mempool_flags: &ValidationFlags,
    params: Vec<Value>,
    chain_params: &ChainParams,
    tx_announce: &broadcast::Sender<Hash256>,
    data_dir: &Path,
) -> Result<Value, RpcError> {
    if params.len() < 2 || params.len() > 3 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "startfluxnode expects 2 or 3 parameters",
        ));
    }
    let set = params[0]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "set must be a string"))?;
    let lockwallet = parse_bool(&params[1])?;

    let conf_entries = read_fluxnode_conf(data_dir)?;
    if conf_entries.is_empty() {
        return Err(RpcError::new(
            RPC_INTERNAL_ERROR,
            "This is not a Flux Node (no fluxnode.conf entry found)",
        ));
    }

    let targets: Vec<&FluxnodeConfEntry> = match set {
        "all" => conf_entries.iter().collect(),
        "alias" => {
            let alias = params
                .get(2)
                .and_then(|value| value.as_str())
                .ok_or_else(|| {
                    RpcError::new(RPC_INVALID_PARAMETER, "alias required for set=alias")
                })?;
            let filtered: Vec<_> = conf_entries.iter().filter(|e| e.alias == alias).collect();
            if filtered.is_empty() {
                lock_wallet_if_requested(wallet, lockwallet)?;
                return Ok(json!({
                    "overall": "Successfully started 0 fluxnodes, failed to start 1, total 1",
                    "detail": [{
                        "alias": alias,
                        "result": "failed",
                        "error": "could not find alias in config. Verify with listfluxnodeconf.",
                    }],
                }));
            }
            filtered
        }
        _ => {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                "set must be \"all\" or \"alias\"",
            ))
        }
    };

    let mut successful = 0;
    let mut failed = 0;
    let mut detail = Vec::new();

    let best_height = best_block_height(chainstate)?;
    let pon_active = network_upgrade_active(
        best_height,
        &chain_params.consensus.upgrades,
        UpgradeIndex::Pon,
    );
    let expiration = if pon_active {
        FLUXNODE_START_TX_EXPIRATION_HEIGHT_V2
    } else {
        FLUXNODE_START_TX_EXPIRATION_HEIGHT
    };
    let dos_remove = if pon_active {
        FLUXNODE_DOS_REMOVE_AMOUNT_V2
    } else {
        FLUXNODE_DOS_REMOVE_AMOUNT
    };

    for entry in targets {
        let mut obj = serde_json::Map::new();
        obj.insert("alias".to_string(), Value::String(entry.alias.clone()));
        obj.insert(
            "outpoint".to_string(),
            Value::String(format_outpoint(&entry.collateral)),
        );
        obj.insert(
            "transaction_built".to_string(),
            Value::String("failed".to_string()),
        );
        obj.insert(
            "transaction_signed".to_string(),
            Value::String("failed".to_string()),
        );
        obj.insert(
            "transaction_commited".to_string(),
            Value::String("failed".to_string()),
        );
        obj.insert("result".to_string(), Value::String("failed".to_string()));
        obj.insert("errorMessage".to_string(), Value::String(String::new()));

        if let Some(record) = chainstate
            .fluxnode_record(&entry.collateral)
            .map_err(map_internal)?
        {
            if let Some(reason) =
                fluxnode_start_blocked_reason(best_height, &record, expiration, dos_remove)
            {
                failed += 1;
                obj.insert("reason".to_string(), Value::String(reason.to_string()));
                detail.push(Value::Object(obj));
                continue;
            }
        }

        {
            let guard = mempool
                .lock()
                .map_err(|_| map_internal("mempool lock poisoned"))?;
            if mempool_contains_fluxnode_outpoint(&guard, &entry.collateral) {
                failed += 1;
                obj.insert(
                    "reason".to_string(),
                    Value::String(
                        "Mempool already has a fluxnode transaction using this outpoint"
                            .to_string(),
                    ),
                );
                detail.push(Value::Object(obj));
                continue;
            }
        }

        let collateral_wif = entry.collateral_privkey.as_deref();
        let redeem_script_hex = entry.redeem_script.as_deref();

        let (collateral_secret, redeem_script) =
            match resolve_fluxnode_collateral_secret_and_redeem_script(
                chainstate,
                wallet,
                entry,
                chain_params,
                collateral_wif,
                redeem_script_hex,
            ) {
                Ok(resolved) => resolved,
                Err(err) => {
                    if collateral_wif.is_none() && err.code == RPC_WALLET_UNLOCK_NEEDED {
                        return Err(err);
                    }
                    failed += 1;
                    obj.insert("result".to_string(), Value::String("failed".to_string()));
                    obj.insert("errorMessage".to_string(), Value::String(err.message));
                    detail.push(Value::Object(obj));
                    continue;
                }
            };

        let tx = match build_fluxnode_start_tx(
            chainstate,
            entry,
            chain_params,
            &collateral_secret,
            redeem_script,
            None,
        ) {
            Ok(tx) => tx,
            Err(err) => {
                failed += 1;
                obj.insert("result".to_string(), Value::String("failed".to_string()));
                obj.insert("errorMessage".to_string(), Value::String(err.message));
                detail.push(Value::Object(obj));
                continue;
            }
        };
        obj.insert(
            "transaction_built".to_string(),
            Value::String("successful".to_string()),
        );
        obj.insert(
            "transaction_signed".to_string(),
            Value::String("successful".to_string()),
        );

        let raw = match tx.consensus_encode() {
            Ok(bytes) => bytes,
            Err(err) => {
                failed += 1;
                obj.insert("result".to_string(), Value::String("failed".to_string()));
                obj.insert("errorMessage".to_string(), Value::String(err.to_string()));
                detail.push(Value::Object(obj));
                continue;
            }
        };

        let raw_hex = hex_bytes(&raw);
        match rpc_sendrawtransaction(
            chainstate,
            mempool,
            mempool_policy,
            mempool_metrics,
            fee_estimator,
            mempool_flags,
            vec![Value::String(raw_hex)],
            chain_params,
            tx_announce,
        ) {
            Ok(txid) => {
                successful += 1;
                obj.insert(
                    "result".to_string(),
                    Value::String("successful".to_string()),
                );
                obj.insert(
                    "transaction_commited".to_string(),
                    Value::String("successful".to_string()),
                );
                obj.insert("txid".to_string(), txid);
            }
            Err(err) => {
                failed += 1;
                obj.insert("result".to_string(), Value::String("failed".to_string()));
                obj.insert(
                    "transaction_commited".to_string(),
                    Value::String("failed".to_string()),
                );
                obj.insert("errorMessage".to_string(), Value::String(err.message));
            }
        }

        detail.push(Value::Object(obj));
    }

    lock_wallet_if_requested(wallet, lockwallet)?;
    Ok(json!({
        "overall": format!("Successfully started {successful} fluxnodes, failed to start {failed}, total {}", successful + failed),
        "detail": detail,
    }))
}

fn rpc_getfluxnodestatus<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    params: Vec<Value>,
    chain_params: &ChainParams,
    data_dir: &Path,
) -> Result<Value, RpcError> {
    if params.len() > 1 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "getfluxnodestatus expects 0 or 1 parameter",
        ));
    }

    let conf_entries = read_fluxnode_conf(data_dir)?;
    let (collateral, selected_conf): (OutPoint, Option<&FluxnodeConfEntry>) = match params.first() {
        Some(value) => {
            let arg = value
                .as_str()
                .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "argument must be a string"))?;
            if arg.contains(':') {
                let outpoint = parse_outpoint(arg)?;
                let selected = conf_entries
                    .iter()
                    .find(|entry| entry.collateral == outpoint);
                (outpoint, selected)
            } else {
                let entry = conf_entries
                    .iter()
                    .find(|entry| entry.alias == arg)
                    .ok_or_else(|| {
                        RpcError::new(RPC_INVALID_PARAMETER, "unknown fluxnode alias")
                    })?;
                (entry.collateral.clone(), Some(entry))
            }
        }
        None => {
            if conf_entries.is_empty() {
                return Err(RpcError::new(
                    RPC_INTERNAL_ERROR,
                    "This is not a Flux Node (no fluxnode.conf entry found)",
                ));
            }
            if conf_entries.len() > 1 {
                return Err(RpcError::new(
                    RPC_INVALID_PARAMETER,
                    "Multiple entries in fluxnode.conf; pass an alias or collateral outpoint",
                ));
            }
            (conf_entries[0].collateral.clone(), Some(&conf_entries[0]))
        }
    };

    let record = chainstate
        .fluxnode_records()
        .map_err(map_internal)?
        .into_iter()
        .find(|record| record.collateral == collateral);

    let outpoint_str = format_outpoint(&collateral);
    if record.is_none() {
        return Ok(json!({
            "status": "expired",
            "collateral": outpoint_str,
        }));
    }
    let record = record.expect("checked");

    let best_height = best_block_height(chainstate)?;
    let pon_active = network_upgrade_active(
        best_height,
        &chain_params.consensus.upgrades,
        UpgradeIndex::Pon,
    );
    let expiration = if pon_active {
        FLUXNODE_START_TX_EXPIRATION_HEIGHT_V2
    } else {
        FLUXNODE_START_TX_EXPIRATION_HEIGHT
    };
    let dos_remove = if pon_active {
        FLUXNODE_DOS_REMOVE_AMOUNT_V2
    } else {
        FLUXNODE_DOS_REMOVE_AMOUNT
    };

    let status = if record.confirmed_height != 0 {
        "CONFIRMED"
    } else if best_height >= record.start_height as i32 {
        let age = best_height.saturating_sub(record.start_height as i32);
        if age <= expiration {
            "STARTED"
        } else if age <= dos_remove {
            "DOS"
        } else {
            "OFFLINE"
        }
    } else {
        "STARTED"
    };

    let payment_address =
        fluxnode_status_payment_address(chainstate, &record, chain_params.network)?
            .unwrap_or_default();
    let pubkey = chainstate
        .fluxnode_key(record.operator_pubkey)
        .map_err(map_internal)?
        .unwrap_or_default();

    let activesince = if best_height >= record.start_height as i32 {
        header_time_at_height(chainstate, record.start_height as i32)
            .map(|time| Value::String(time.to_string()))
            .unwrap_or_else(|| Value::Number(0.into()))
    } else {
        Value::Number(0.into())
    };
    let lastpaid = if best_height >= record.last_paid_height as i32 {
        header_time_at_height(chainstate, record.last_paid_height as i32)
            .map(|time| Value::String(time.to_string()))
            .unwrap_or_else(|| Value::Number(0.into()))
    } else {
        Value::Number(0.into())
    };

    let mut info = serde_json::Map::new();
    info.insert("status".to_string(), Value::String(status.to_string()));
    info.insert("collateral".to_string(), Value::String(outpoint_str));
    info.insert(
        "txhash".to_string(),
        Value::String(hash256_to_hex(&record.collateral.hash)),
    );
    info.insert(
        "outidx".to_string(),
        Value::Number((record.collateral.index as i64).into()),
    );
    let ip = if !record.ip.is_empty() {
        record.ip.clone()
    } else if let Some(entry) = selected_conf {
        entry.address.clone()
    } else {
        String::new()
    };
    let (_host, network) = fluxnode_network_info(&ip);
    info.insert("ip".to_string(), Value::String(ip));
    info.insert("network".to_string(), Value::String(network));
    info.insert(
        "added_height".to_string(),
        Value::Number((record.start_height as i64).into()),
    );
    info.insert(
        "confirmed_height".to_string(),
        Value::Number((record.confirmed_height as i64).into()),
    );
    info.insert(
        "last_confirmed_height".to_string(),
        Value::Number((record.last_confirmed_height as i64).into()),
    );
    info.insert(
        "last_paid_height".to_string(),
        Value::Number((record.last_paid_height as i64).into()),
    );
    info.insert(
        "tier".to_string(),
        Value::String(fluxnode_tier_name(record.tier).to_string()),
    );
    info.insert(
        "payment_address".to_string(),
        Value::String(payment_address),
    );
    info.insert("pubkey".to_string(), Value::String(hex_bytes(&pubkey)));
    info.insert("activesince".to_string(), activesince);
    info.insert("lastpaid".to_string(), lastpaid);

    if record.collateral_value > 0 {
        info.insert(
            "amount".to_string(),
            Value::String(format_money(record.collateral_value)),
        );
    }

    Ok(Value::Object(info))
}

fn ensure_fluxnode_mode(data_dir: &Path) -> Result<(), RpcError> {
    let conf_entries = read_fluxnode_conf(data_dir)?;
    if conf_entries.is_empty() {
        return Err(RpcError::new(
            RPC_INTERNAL_ERROR,
            "This is not a Flux Node (no fluxnode.conf entry found)",
        ));
    }
    Ok(())
}

fn rpc_createp2shstarttx<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    if params.len() < 4 || params.len() > 5 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "createp2shstarttx expects 4 or 5 parameters",
        ));
    }

    let redeem_script_hex = params[0]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "redeemscript must be a string"))?;
    let redeem_script = bytes_from_hex(redeem_script_hex)
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "redeemscript must be a hex string"))?;

    let vps_pubkey_hex = params[1]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "vpspubkey must be a string"))?;
    let vps_pubkey = bytes_from_hex(vps_pubkey_hex)
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "vpspubkey must be a hex string"))?;
    PublicKey::from_slice(&vps_pubkey).map_err(|_| {
        RpcError::new(
            RPC_INVALID_PARAMETER,
            "vpspubkey must be a valid public key",
        )
    })?;

    let txid = parse_hash(&params[2])?;
    let index = parse_u32(&params[3], "index")?;
    let collateral = OutPoint { hash: txid, index };

    let mut delegates: Vec<Vec<u8>> = Vec::new();
    if let Some(value) = params.get(4) {
        let list = value.as_array().ok_or_else(|| {
            RpcError::new(
                RPC_INVALID_PARAMETER,
                "delegates must be an array of pubkeys",
            )
        })?;
        if list.len() > 4 {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                "Too many delegates. Maximum is 4",
            ));
        }
        let mut seen = HashSet::new();
        for (idx, entry) in list.iter().enumerate() {
            let key_hex = entry.as_str().ok_or_else(|| {
                RpcError::new(
                    RPC_INVALID_PARAMETER,
                    "delegates must be an array of pubkeys",
                )
            })?;
            let key_bytes = bytes_from_hex(key_hex).ok_or_else(|| {
                RpcError::new(
                    RPC_INVALID_PARAMETER,
                    format!("Invalid delegate public key at index {idx}"),
                )
            })?;
            if key_bytes.len() != 33 {
                return Err(RpcError::new(
                    RPC_INVALID_PARAMETER,
                    format!("Delegate public key at index {idx} must be compressed"),
                ));
            }
            PublicKey::from_slice(&key_bytes).map_err(|_| {
                RpcError::new(
                    RPC_INVALID_PARAMETER,
                    format!("Invalid delegate public key at index {idx}"),
                )
            })?;
            if !seen.insert(key_bytes.clone()) {
                return Err(RpcError::new(
                    RPC_INVALID_PARAMETER,
                    format!("Duplicate delegate public key at index {idx}"),
                ));
            }
            delegates.push(key_bytes);
        }
    }

    let best_height = best_block_height(chainstate)?;
    let next_height = best_height.saturating_add(1);
    let pon_active = network_upgrade_active(
        next_height,
        &chain_params.consensus.upgrades,
        UpgradeIndex::Pon,
    );

    let using_delegates = pon_active && !delegates.is_empty();
    let flux_tx_version = if pon_active {
        if using_delegates {
            FLUXNODE_TX_TYPE_P2SH_BIT | FLUXNODE_TX_FEATURE_DELEGATES_BIT
        } else {
            FLUXNODE_TX_TYPE_P2SH_BIT
        }
    } else {
        FLUXNODE_INTERNAL_P2SH_TX_VERSION
    };

    let utxo = chainstate
        .utxo_entry(&collateral)
        .map_err(map_internal)?
        .ok_or_else(|| RpcError::new(RPC_TRANSACTION_ERROR, "Coins not found in chain"))?;
    let script_hash = extract_p2sh_hash(&utxo.script_pubkey).ok_or_else(|| {
        RpcError::new(
            RPC_TRANSACTION_ERROR,
            "Couldn't extract destination from coins",
        )
    })?;
    if hash160(&redeem_script) != script_hash {
        return Err(RpcError::new(
            RPC_TRANSACTION_ERROR,
            "Address not matching Redeemscript hash",
        ));
    }

    let sig_time = 0;
    let sig = Vec::new();

    let delegates_payload = if using_delegates {
        Some(FluxnodeDelegates {
            version: FluxnodeDelegates::INITIAL_VERSION,
            kind: FluxnodeDelegates::UPDATE,
            delegate_starting_keys: delegates,
        })
    } else {
        None
    };

    let tx = Transaction {
        f_overwintered: false,
        version: FLUXNODE_TX_UPGRADEABLE_VERSION,
        version_group_id: 0,
        vin: Vec::new(),
        vout: Vec::new(),
        lock_time: 0,
        expiry_height: 0,
        value_balance: 0,
        shielded_spends: Vec::new(),
        shielded_outputs: Vec::new(),
        join_splits: Vec::new(),
        join_split_pub_key: [0u8; 32],
        join_split_sig: [0u8; 64],
        binding_sig: [0u8; 64],
        fluxnode: Some(FluxnodeTx::V6(FluxnodeTxV6::Start(FluxnodeStartV6 {
            flux_tx_version,
            variant: FluxnodeStartVariantV6::P2sh {
                collateral,
                pubkey: vps_pubkey,
                redeem_script,
                sig_time,
                sig,
            },
            using_delegates,
            delegates: delegates_payload,
        }))),
    };

    let raw = tx.consensus_encode().map_err(map_internal)?;
    Ok(Value::String(hex_bytes(&raw)))
}

fn rpc_signp2shstarttx(
    wallet: &Mutex<Wallet>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    if params.is_empty() || params.len() > 2 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "signp2shstarttx expects 1 or 2 parameters",
        ));
    }
    let raw_hex = params[0].as_str().ok_or_else(|| {
        RpcError::new(RPC_INVALID_PARAMETER, "rawtransactionhex must be a string")
    })?;
    let raw = bytes_from_hex(raw_hex)
        .ok_or_else(|| RpcError::new(RPC_DESERIALIZATION_ERROR, "TX decode failed"))?;
    let mut tx = Transaction::consensus_decode(&raw)
        .map_err(|_| RpcError::new(RPC_DESERIALIZATION_ERROR, "TX decode failed"))?;

    let redeem_script = match tx.fluxnode.as_ref() {
        Some(FluxnodeTx::V6(FluxnodeTxV6::Start(start))) => match &start.variant {
            FluxnodeStartVariantV6::P2sh { redeem_script, .. } => redeem_script.clone(),
            _ => {
                return Err(RpcError::new(
                    RPC_INVALID_PARAMETER,
                    "transaction is not a P2SH fluxnode start transaction",
                ))
            }
        },
        _ => {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                "transaction is not a P2SH fluxnode start transaction",
            ))
        }
    };

    let pubkeys = parse_multisig_redeem_script(&redeem_script).ok_or_else(|| {
        RpcError::new(
            RPC_INVALID_ADDRESS_OR_KEY,
            "Failed to get pubkeys from redeemscript",
        )
    })?;

    let (secret, compressed) = if let Some(value) = params.get(1) {
        let wif = value
            .as_str()
            .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "privatekey must be a string"))?;
        let (secret, compressed) = parse_wif_secret_key(wif, chain_params.network)
            .map_err(|_| RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "Invalid private key"))?;
        (secret, compressed)
    } else {
        let guard = wallet
            .lock()
            .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;
        let mut found = None;
        for pubkey_bytes in &pubkeys {
            let pubkey = PublicKey::from_slice(pubkey_bytes).map_err(|_| {
                RpcError::new(
                    RPC_INVALID_ADDRESS_OR_KEY,
                    "Failed to get pubkeys from redeemscript",
                )
            })?;
            if let Some(secret) = guard
                .signing_key_for_pubkey(&pubkey)
                .map_err(map_wallet_error)?
            {
                found = Some((secret, pubkey_bytes.len() == 33));
                break;
            }
        }
        found.ok_or_else(|| RpcError::new(RPC_WALLET_ERROR, "Private key not available"))?
    };

    let now = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_secs();
    let sig_time = u32::try_from(now).unwrap_or(u32::MAX);
    {
        let start = match tx.fluxnode.as_mut() {
            Some(FluxnodeTx::V6(FluxnodeTxV6::Start(start))) => start,
            _ => {
                return Err(RpcError::new(
                    RPC_INVALID_PARAMETER,
                    "transaction is not a P2SH fluxnode start transaction",
                ))
            }
        };
        match &mut start.variant {
            FluxnodeStartVariantV6::P2sh {
                sig_time: sig_time_field,
                sig,
                ..
            } => {
                *sig_time_field = sig_time;
                sig.clear();
            }
            _ => {
                return Err(RpcError::new(
                    RPC_INVALID_PARAMETER,
                    "transaction is not a P2SH fluxnode start transaction",
                ))
            }
        }
    }

    let txid = tx.txid().map_err(map_internal)?;
    let message = hash256_to_hex(&txid).into_bytes();
    let signature = sign_compact_message(&secret, compressed, &message)
        .map_err(|_| RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "Failed to sign transaction"))?;
    {
        let start = match tx.fluxnode.as_mut() {
            Some(FluxnodeTx::V6(FluxnodeTxV6::Start(start))) => start,
            _ => {
                return Err(RpcError::new(
                    RPC_INVALID_PARAMETER,
                    "transaction is not a P2SH fluxnode start transaction",
                ))
            }
        };
        match &mut start.variant {
            FluxnodeStartVariantV6::P2sh { sig, .. } => sig.extend_from_slice(&signature),
            _ => {
                return Err(RpcError::new(
                    RPC_INVALID_PARAMETER,
                    "transaction is not a P2SH fluxnode start transaction",
                ))
            }
        }
    }

    let mut validated = false;
    for pubkey in &pubkeys {
        if fluxd_script::message::verify_signed_message(pubkey, &signature, &message).is_ok() {
            validated = true;
            break;
        }
    }
    if !validated {
        return Err(RpcError::new(
            RPC_INVALID_ADDRESS_OR_KEY,
            "Signature Verify Failed",
        ));
    }

    let encoded = tx.consensus_encode().map_err(map_internal)?;
    Ok(Value::String(hex_bytes(&encoded)))
}

fn rpc_sendp2shstarttx<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    mempool: &Mutex<Mempool>,
    mempool_policy: &MempoolPolicy,
    mempool_metrics: &MempoolMetrics,
    fee_estimator: &Mutex<FeeEstimator>,
    mempool_flags: &ValidationFlags,
    params: Vec<Value>,
    chain_params: &ChainParams,
    tx_announce: &broadcast::Sender<Hash256>,
) -> Result<Value, RpcError> {
    if params.len() != 1 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "sendp2shstarttx expects 1 parameter",
        ));
    }
    rpc_sendrawtransaction(
        chainstate,
        mempool,
        mempool_policy,
        mempool_metrics,
        fee_estimator,
        mempool_flags,
        vec![params[0].clone()],
        chain_params,
        tx_announce,
    )
}

fn rpc_startfluxnodewithdelegates<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    wallet: &Mutex<Wallet>,
    mempool: &Mutex<Mempool>,
    mempool_policy: &MempoolPolicy,
    mempool_metrics: &MempoolMetrics,
    fee_estimator: &Mutex<FeeEstimator>,
    mempool_flags: &ValidationFlags,
    params: Vec<Value>,
    chain_params: &ChainParams,
    tx_announce: &broadcast::Sender<Hash256>,
    data_dir: &Path,
) -> Result<Value, RpcError> {
    if params.len() != 3 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "startfluxnodewithdelegates expects 3 parameters",
        ));
    }
    let alias = params[0]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "alias must be a string"))?
        .to_string();

    let delegates_value = params[1].as_array().ok_or_else(|| {
        RpcError::new(
            RPC_INVALID_PARAMETER,
            "delegates must be an array of pubkeys",
        )
    })?;
    if delegates_value.len() > FluxnodeDelegates::MAX_PUBKEYS_LENGTH {
        return Ok(json!({
            "result": "failed",
            "error": format!("Too many delegates. Maximum is {}", FluxnodeDelegates::MAX_PUBKEYS_LENGTH),
        }));
    }
    if delegates_value.is_empty() {
        return Ok(json!({
            "result": "failed",
            "error": "At least one delegate key must be provided",
        }));
    }

    let mut delegates: Vec<Vec<u8>> = Vec::with_capacity(delegates_value.len());
    let mut seen = HashSet::new();
    for (idx, entry) in delegates_value.iter().enumerate() {
        let key_hex = entry.as_str().unwrap_or_default();
        let key_bytes = bytes_from_hex(key_hex).ok_or_else(|| {
            RpcError::new(
                RPC_INVALID_PARAMETER,
                format!("Invalid public key at index {idx}"),
            )
        })?;
        PublicKey::from_slice(&key_bytes).map_err(|_| {
            RpcError::new(
                RPC_INVALID_PARAMETER,
                format!("Invalid public key at index {idx}"),
            )
        })?;
        if key_bytes.len() != 33 {
            return Ok(json!({
                "result": "failed",
                "error": format!("Public key at index {idx} must be compressed"),
            }));
        }
        if !seen.insert(key_bytes.clone()) {
            return Ok(json!({
                "result": "failed",
                "error": format!("Duplicate public key at index {idx}"),
            }));
        }
        delegates.push(key_bytes);
    }

    let lockwallet = parse_bool(&params[2])?;

    let conf_entries = read_fluxnode_conf(data_dir)?;
    let Some(entry) = conf_entries.iter().find(|entry| entry.alias == alias) else {
        return Ok(json!({
            "result": "failed",
            "error": "Could not find alias in config. Verify with listfluxnodeconf.",
        }));
    };

    {
        let guard = mempool
            .lock()
            .map_err(|_| map_internal("mempool lock poisoned"))?;
        if mempool_contains_fluxnode_outpoint(&guard, &entry.collateral) {
            return Ok(json!({
                "result": "failed",
                "error": "Mempool already has a fluxnode transaction using this outpoint",
            }));
        }
    }

    let best_height = best_block_height(chainstate)?;
    let pon_active = network_upgrade_active(
        best_height,
        &chain_params.consensus.upgrades,
        UpgradeIndex::Pon,
    );
    let expiration = if pon_active {
        FLUXNODE_START_TX_EXPIRATION_HEIGHT_V2
    } else {
        FLUXNODE_START_TX_EXPIRATION_HEIGHT
    };
    let dos_remove = if pon_active {
        FLUXNODE_DOS_REMOVE_AMOUNT_V2
    } else {
        FLUXNODE_DOS_REMOVE_AMOUNT
    };
    if let Some(record) = chainstate
        .fluxnode_record(&entry.collateral)
        .map_err(map_internal)?
    {
        if let Some(reason) =
            fluxnode_start_blocked_reason(best_height, &record, expiration, dos_remove)
        {
            return Ok(json!({
                "result": "failed",
                "error": reason,
            }));
        }
    }

    let (collateral_secret, redeem_script) =
        match resolve_fluxnode_collateral_secret_and_redeem_script(
            chainstate,
            wallet,
            entry,
            chain_params,
            entry.collateral_privkey.as_deref(),
            entry.redeem_script.as_deref(),
        ) {
            Ok(resolved) => resolved,
            Err(err) => {
                lock_wallet_if_requested(wallet, lockwallet)?;
                return Ok(json!({
                    "result": "failed",
                    "error": err.message,
                }));
            }
        };

    let tx = match build_fluxnode_start_tx(
        chainstate,
        entry,
        chain_params,
        &collateral_secret,
        redeem_script,
        Some(delegates.clone()),
    ) {
        Ok(tx) => tx,
        Err(err) => {
            lock_wallet_if_requested(wallet, lockwallet)?;
            return Ok(json!({
                "result": "failed",
                "error": err.message,
            }));
        }
    };

    let raw = tx.consensus_encode().map_err(map_internal)?;
    let raw_hex = hex_bytes(&raw);

    let result = match rpc_sendrawtransaction(
        chainstate,
        mempool,
        mempool_policy,
        mempool_metrics,
        fee_estimator,
        mempool_flags,
        vec![Value::String(raw_hex)],
        chain_params,
        tx_announce,
    ) {
        Ok(txid) => {
            let delegate_hex: Vec<Value> = delegates
                .iter()
                .map(|key| Value::String(hex_bytes(key)))
                .collect();
            json!({
                "result": "success",
                "txid": txid,
                "delegates_count": delegates.len(),
                "delegates": delegate_hex,
            })
        }
        Err(err) => json!({
            "result": "failed",
            "error": err.message,
        }),
    };

    lock_wallet_if_requested(wallet, lockwallet)?;
    Ok(result)
}

fn rpc_startfluxnodeasdelegate<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    mempool: &Mutex<Mempool>,
    mempool_policy: &MempoolPolicy,
    mempool_metrics: &MempoolMetrics,
    fee_estimator: &Mutex<FeeEstimator>,
    mempool_flags: &ValidationFlags,
    params: Vec<Value>,
    chain_params: &ChainParams,
    tx_announce: &broadcast::Sender<Hash256>,
) -> Result<Value, RpcError> {
    if params.len() != 4 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "startfluxnodeasdelegate expects 4 parameters",
        ));
    }

    let txid = match parse_hash(&params[0]) {
        Ok(txid) => txid,
        Err(_) => {
            return Ok(json!({
                "result": "failed",
                "error": "Invalid transaction hash",
            }));
        }
    };
    let index = match parse_u32(&params[1], "outputindex") {
        Ok(index) => index,
        Err(_) => {
            return Ok(json!({
                "result": "failed",
                "error": "Invalid output index",
            }));
        }
    };

    let outpoint = OutPoint { hash: txid, index };

    {
        let guard = mempool
            .lock()
            .map_err(|_| map_internal("mempool lock poisoned"))?;
        if mempool_contains_fluxnode_outpoint(&guard, &outpoint) {
            return Ok(json!({
                "result": "failed",
                "error": "Mempool already has a fluxnode transaction using this outpoint",
            }));
        }
    }

    let best_height = best_block_height(chainstate)?;
    let pon_active = network_upgrade_active(
        best_height,
        &chain_params.consensus.upgrades,
        UpgradeIndex::Pon,
    );
    let expiration = if pon_active {
        FLUXNODE_START_TX_EXPIRATION_HEIGHT_V2
    } else {
        FLUXNODE_START_TX_EXPIRATION_HEIGHT
    };
    let dos_remove = if pon_active {
        FLUXNODE_DOS_REMOVE_AMOUNT_V2
    } else {
        FLUXNODE_DOS_REMOVE_AMOUNT
    };

    let record = chainstate
        .fluxnode_record(&outpoint)
        .map_err(map_internal)?;
    if let Some(record) = record.as_ref() {
        if let Some(reason) =
            fluxnode_start_blocked_reason(best_height, record, expiration, dos_remove)
        {
            return Ok(json!({
                "result": "failed",
                "error": reason,
            }));
        }
    }

    let delegate_wif = params[2]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "delegatekey must be a string"))?;
    let (delegate_secret, delegate_compressed) =
        match parse_wif_secret_key(delegate_wif, chain_params.network) {
            Ok(key) => key,
            Err(_) => {
                return Ok(json!({
                    "result": "failed",
                    "error": "Invalid delegate private key",
                }));
            }
        };
    if !delegate_compressed {
        return Ok(json!({
            "result": "failed",
            "error": "Invalid delegate private key",
        }));
    }
    let delegate_pubkey = secret_key_pubkey_bytes(&delegate_secret, true);

    let vps_pubkey_hex = params[3]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "vpspubkey must be a string"))?;
    let vps_pubkey = bytes_from_hex(vps_pubkey_hex)
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "vpspubkey must be a hex string"))?;
    PublicKey::from_slice(&vps_pubkey)
        .map_err(|_| RpcError::new(RPC_INVALID_PARAMETER, "Invalid VPS public key"))?;

    let Some(record) = record else {
        return Ok(json!({
            "result": "failed",
            "error": "No delegates are authorized for this collateral. Start once with a delegate UPDATE (e.g. startfluxnodewithdelegates / createp2shstarttx with delegates) first.",
        }));
    };
    let Some(delegates_key) = record.delegates else {
        return Ok(json!({
            "result": "failed",
            "error": "No delegates are authorized for this collateral. Start once with a delegate UPDATE (e.g. startfluxnodewithdelegates / createp2shstarttx with delegates) first.",
        }));
    };
    let delegates_bytes = chainstate
        .fluxnode_key(delegates_key)
        .map_err(map_internal)?
        .ok_or_else(|| map_internal("Missing delegate data"))?;
    let delegates_stored =
        fluxd_primitives::encoding::decode::<FluxnodeDelegates>(&delegates_bytes)
            .map_err(|_| map_internal("Invalid delegate data"))?;
    if delegates_stored.delegate_starting_keys.is_empty() {
        return Ok(json!({
            "result": "failed",
            "error": "No delegates are authorized for this collateral. Start once with a delegate UPDATE (e.g. startfluxnodewithdelegates / createp2shstarttx with delegates) first.",
        }));
    }
    let authorized = delegates_stored
        .delegate_starting_keys
        .iter()
        .any(|key| key.as_slice() == delegate_pubkey.as_slice());
    if !authorized {
        return Ok(json!({
            "result": "failed",
            "error": "This delegate key is not authorized for this collateral. Update delegates first.",
        }));
    }

    let collateral_pubkey_key = record
        .collateral_pubkey
        .ok_or_else(|| map_internal("Missing collateral pubkey for fluxnode record"))?;
    let collateral_pubkey = chainstate
        .fluxnode_key(collateral_pubkey_key)
        .map_err(map_internal)?
        .ok_or_else(|| map_internal("Missing collateral pubkey for fluxnode record"))?;

    let now = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_secs();
    let sig_time = u32::try_from(now).unwrap_or(u32::MAX);

    let mut tx = Transaction {
        f_overwintered: false,
        version: FLUXNODE_TX_UPGRADEABLE_VERSION,
        version_group_id: 0,
        vin: Vec::new(),
        vout: Vec::new(),
        lock_time: 0,
        expiry_height: 0,
        value_balance: 0,
        shielded_spends: Vec::new(),
        shielded_outputs: Vec::new(),
        join_splits: Vec::new(),
        join_split_pub_key: [0u8; 32],
        join_split_sig: [0u8; 64],
        binding_sig: [0u8; 64],
        fluxnode: Some(FluxnodeTx::V6(FluxnodeTxV6::Start(FluxnodeStartV6 {
            flux_tx_version: FLUXNODE_TX_TYPE_NORMAL_BIT | FLUXNODE_TX_FEATURE_DELEGATES_BIT,
            variant: FluxnodeStartVariantV6::Normal {
                collateral: outpoint.clone(),
                collateral_pubkey: collateral_pubkey.clone(),
                pubkey: vps_pubkey,
                sig_time,
                sig: Vec::new(),
            },
            using_delegates: true,
            delegates: Some(FluxnodeDelegates {
                version: FluxnodeDelegates::INITIAL_VERSION,
                kind: FluxnodeDelegates::SIGNING,
                delegate_starting_keys: Vec::new(),
            }),
        }))),
    };

    let txid = tx.txid().map_err(map_internal)?;
    let message = hash256_to_hex(&txid).into_bytes();
    let signature = sign_compact_message(&delegate_secret, true, &message)
        .map_err(|_| RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "Failed to sign transaction"))?;
    if let Some(FluxnodeTx::V6(FluxnodeTxV6::Start(start))) = tx.fluxnode.as_mut() {
        if let FluxnodeStartVariantV6::Normal { sig, .. } = &mut start.variant {
            sig.extend_from_slice(&signature);
        }
    }

    let raw = tx.consensus_encode().map_err(map_internal)?;
    let raw_hex = hex_bytes(&raw);
    let txid_value = match rpc_sendrawtransaction(
        chainstate,
        mempool,
        mempool_policy,
        mempool_metrics,
        fee_estimator,
        mempool_flags,
        vec![Value::String(raw_hex)],
        chain_params,
        tx_announce,
    ) {
        Ok(txid) => txid,
        Err(err) => {
            return Ok(json!({
                "result": "failed",
                "error": err.message,
            }));
        }
    };

    let delegate_address = {
        let hash = hash160(&delegate_pubkey);
        let mut script = Vec::with_capacity(25);
        script.extend_from_slice(&[0x76, 0xa9, 0x14]);
        script.extend_from_slice(&hash);
        script.extend_from_slice(&[0x88, 0xac]);
        script_pubkey_to_address(&script, chain_params.network).unwrap_or_default()
    };

    Ok(json!({
        "result": "success",
        "txid": txid_value,
        "delegate": delegate_address,
    }))
}

fn rpc_startp2shasdelegate<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    mempool: &Mutex<Mempool>,
    mempool_policy: &MempoolPolicy,
    mempool_metrics: &MempoolMetrics,
    fee_estimator: &Mutex<FeeEstimator>,
    mempool_flags: &ValidationFlags,
    params: Vec<Value>,
    chain_params: &ChainParams,
    tx_announce: &broadcast::Sender<Hash256>,
) -> Result<Value, RpcError> {
    if params.len() != 5 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "startp2shasdelegate expects 5 parameters",
        ));
    }

    let redeem_script_hex = params[0]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "redeemscript must be a string"))?;
    let redeem_script = bytes_from_hex(redeem_script_hex)
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "redeemscript must be a hex string"))?;

    let txid = match parse_hash(&params[1]) {
        Ok(txid) => txid,
        Err(_) => {
            return Ok(json!({
                "result": "failed",
                "error": "Invalid transaction hash",
            }));
        }
    };
    let index = match parse_u32(&params[2], "outputindex") {
        Ok(index) => index,
        Err(_) => {
            return Ok(json!({
                "result": "failed",
                "error": "Invalid output index",
            }));
        }
    };
    let outpoint = OutPoint { hash: txid, index };

    {
        let guard = mempool
            .lock()
            .map_err(|_| map_internal("mempool lock poisoned"))?;
        if mempool_contains_fluxnode_outpoint(&guard, &outpoint) {
            return Ok(json!({
                "result": "failed",
                "error": "Mempool already has a fluxnode transaction using this outpoint",
            }));
        }
    }

    let best_height = best_block_height(chainstate)?;
    let pon_active = network_upgrade_active(
        best_height,
        &chain_params.consensus.upgrades,
        UpgradeIndex::Pon,
    );
    let expiration = if pon_active {
        FLUXNODE_START_TX_EXPIRATION_HEIGHT_V2
    } else {
        FLUXNODE_START_TX_EXPIRATION_HEIGHT
    };
    let dos_remove = if pon_active {
        FLUXNODE_DOS_REMOVE_AMOUNT_V2
    } else {
        FLUXNODE_DOS_REMOVE_AMOUNT
    };

    let record = chainstate
        .fluxnode_record(&outpoint)
        .map_err(map_internal)?;
    if let Some(record) = record.as_ref() {
        if let Some(reason) =
            fluxnode_start_blocked_reason(best_height, record, expiration, dos_remove)
        {
            return Ok(json!({
                "result": "failed",
                "error": reason,
            }));
        }
    }

    let delegate_wif = params[3]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "delegatekey must be a string"))?;
    let (delegate_secret, delegate_compressed) =
        match parse_wif_secret_key(delegate_wif, chain_params.network) {
            Ok(key) => key,
            Err(_) => {
                return Ok(json!({
                    "result": "failed",
                    "error": "Invalid delegate private key",
                }));
            }
        };
    if !delegate_compressed {
        return Ok(json!({
            "result": "failed",
            "error": "Invalid delegate private key",
        }));
    }
    let delegate_pubkey = secret_key_pubkey_bytes(&delegate_secret, true);

    let vps_pubkey_hex = params[4]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "vpspubkey must be a string"))?;
    let vps_pubkey = bytes_from_hex(vps_pubkey_hex)
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "vpspubkey must be a hex string"))?;
    PublicKey::from_slice(&vps_pubkey)
        .map_err(|_| RpcError::new(RPC_INVALID_PARAMETER, "Invalid VPS public key"))?;

    let Some(record) = record else {
        return Ok(json!({
            "result": "failed",
            "error": "No delegates are authorized for this collateral",
        }));
    };
    let Some(delegates_key) = record.delegates else {
        return Ok(json!({
            "result": "failed",
            "error": "No delegates are authorized for this collateral",
        }));
    };
    let delegates_bytes = chainstate
        .fluxnode_key(delegates_key)
        .map_err(map_internal)?
        .ok_or_else(|| map_internal("Missing delegate data"))?;
    let delegates_stored =
        fluxd_primitives::encoding::decode::<FluxnodeDelegates>(&delegates_bytes)
            .map_err(|_| map_internal("Invalid delegate data"))?;
    if delegates_stored.delegate_starting_keys.is_empty() {
        return Ok(json!({
            "result": "failed",
            "error": "No delegates are authorized for this collateral",
        }));
    }
    let authorized = delegates_stored
        .delegate_starting_keys
        .iter()
        .any(|key| key.as_slice() == delegate_pubkey.as_slice());
    if !authorized {
        return Ok(json!({
            "result": "failed",
            "error": "This delegate key is not authorized for this collateral",
        }));
    }

    let utxo = chainstate
        .utxo_entry(&outpoint)
        .map_err(map_internal)?
        .ok_or_else(|| RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "collateral output not found"))?;
    let script_hash = extract_p2sh_hash(&utxo.script_pubkey)
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "collateral output is not p2sh"))?;
    if hash160(&redeem_script) != script_hash {
        return Ok(json!({
            "result": "failed",
            "error": "redeem script hash mismatch",
        }));
    }

    let now = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_secs();
    let sig_time = u32::try_from(now).unwrap_or(u32::MAX);

    let mut tx = Transaction {
        f_overwintered: false,
        version: FLUXNODE_TX_UPGRADEABLE_VERSION,
        version_group_id: 0,
        vin: Vec::new(),
        vout: Vec::new(),
        lock_time: 0,
        expiry_height: 0,
        value_balance: 0,
        shielded_spends: Vec::new(),
        shielded_outputs: Vec::new(),
        join_splits: Vec::new(),
        join_split_pub_key: [0u8; 32],
        join_split_sig: [0u8; 64],
        binding_sig: [0u8; 64],
        fluxnode: Some(FluxnodeTx::V6(FluxnodeTxV6::Start(FluxnodeStartV6 {
            flux_tx_version: FLUXNODE_TX_TYPE_P2SH_BIT | FLUXNODE_TX_FEATURE_DELEGATES_BIT,
            variant: FluxnodeStartVariantV6::P2sh {
                collateral: outpoint.clone(),
                pubkey: vps_pubkey,
                redeem_script: redeem_script.clone(),
                sig_time,
                sig: Vec::new(),
            },
            using_delegates: true,
            delegates: Some(FluxnodeDelegates {
                version: FluxnodeDelegates::INITIAL_VERSION,
                kind: FluxnodeDelegates::SIGNING,
                delegate_starting_keys: Vec::new(),
            }),
        }))),
    };

    let txid = tx.txid().map_err(map_internal)?;
    let message = hash256_to_hex(&txid).into_bytes();
    let signature = sign_compact_message(&delegate_secret, true, &message)
        .map_err(|_| RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "Failed to sign transaction"))?;
    if let Some(FluxnodeTx::V6(FluxnodeTxV6::Start(start))) = tx.fluxnode.as_mut() {
        if let FluxnodeStartVariantV6::P2sh { sig, .. } = &mut start.variant {
            sig.extend_from_slice(&signature);
        }
    }

    let raw = tx.consensus_encode().map_err(map_internal)?;
    let raw_hex = hex_bytes(&raw);
    let txid_value = match rpc_sendrawtransaction(
        chainstate,
        mempool,
        mempool_policy,
        mempool_metrics,
        fee_estimator,
        mempool_flags,
        vec![Value::String(raw_hex)],
        chain_params,
        tx_announce,
    ) {
        Ok(txid) => txid,
        Err(err) => {
            return Ok(json!({
                "result": "failed",
                "error": err.message,
            }));
        }
    };

    let delegate_address = {
        let hash = hash160(&delegate_pubkey);
        let mut script = Vec::with_capacity(25);
        script.extend_from_slice(&[0x76, 0xa9, 0x14]);
        script.extend_from_slice(&hash);
        script.extend_from_slice(&[0x88, 0xac]);
        script_pubkey_to_address(&script, chain_params.network).unwrap_or_default()
    };

    let p2sh_address = {
        let hash = hash160(&redeem_script);
        let mut script = Vec::with_capacity(23);
        script.extend_from_slice(&[0xa9, 0x14]);
        script.extend_from_slice(&hash);
        script.push(0x87);
        script_pubkey_to_address(&script, chain_params.network).unwrap_or_default()
    };

    Ok(json!({
        "result": "success",
        "txid": txid_value,
        "delegate": delegate_address,
        "p2sh": p2sh_address,
    }))
}

fn bench_testnet_arg(chain_params: &ChainParams) -> Option<&'static str> {
    if chain_params.network == Network::Testnet {
        Some("-testnet")
    } else {
        None
    }
}

fn find_bench_binary(names: &[&str]) -> Option<PathBuf> {
    let exe_dir = std::env::current_exe().ok()?;
    let exe_dir = exe_dir.parent()?;

    for name in names {
        let candidate = exe_dir.join(name);
        if candidate.is_file() {
            return Some(candidate);
        }
    }

    None
}

fn bench_cli_path() -> Option<PathBuf> {
    find_bench_binary(&["fluxbench-cli", "zelbench-cli"])
}

fn bench_daemon_path() -> Option<PathBuf> {
    find_bench_binary(&["fluxbenchd", "zelbenchd"])
}

fn run_bench_cli(chain_params: &ChainParams, args: &[&str]) -> Option<String> {
    let cli = bench_cli_path()?;
    let mut cmd = Command::new(cli);
    if let Some(arg) = bench_testnet_arg(chain_params) {
        cmd.arg(arg);
    }
    cmd.args(args)
        .stdin(Stdio::null())
        .stdout(Stdio::piped())
        .stderr(Stdio::null());
    let output = cmd.output().ok()?;
    if !output.status.success() {
        return None;
    }
    Some(String::from_utf8_lossy(&output.stdout).trim().to_string())
}

fn is_fluxbenchd_running(chain_params: &ChainParams) -> bool {
    let Some(output) = run_bench_cli(chain_params, &["getstatus", "true"]) else {
        return false;
    };
    let Ok(value) = serde_json::from_str::<Value>(&output) else {
        return false;
    };
    matches!(value.get("status").and_then(Value::as_str), Some("online"))
}

fn rpc_getbenchmarks(
    params: Vec<Value>,
    data_dir: &Path,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    ensure_no_params(&params)?;
    ensure_fluxnode_mode(data_dir)?;
    if !is_fluxbenchd_running(chain_params) {
        return Ok(Value::String("Benchmark not running".to_string()));
    }
    Ok(run_bench_cli(chain_params, &["getbenchmarks"])
        .map(Value::String)
        .unwrap_or_else(|| Value::String("Benchmark not running".to_string())))
}

fn rpc_getbenchstatus(
    params: Vec<Value>,
    data_dir: &Path,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    ensure_no_params(&params)?;
    ensure_fluxnode_mode(data_dir)?;
    if !is_fluxbenchd_running(chain_params) {
        return Ok(Value::String("Benchmark not running".to_string()));
    }
    Ok(run_bench_cli(chain_params, &["getstatus"])
        .map(Value::String)
        .unwrap_or_else(|| Value::String("Benchmark not running".to_string())))
}

fn rpc_startbenchmark(
    params: Vec<Value>,
    data_dir: &Path,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    ensure_no_params(&params)?;
    ensure_fluxnode_mode(data_dir)?;
    if is_fluxbenchd_running(chain_params) {
        return Ok(Value::String("Already running".to_string()));
    }

    let daemon = bench_daemon_path().ok_or_else(|| {
        RpcError::new(
            RPC_INTERNAL_ERROR,
            "Failed to find benchmark application".to_string(),
        )
    })?;
    let mut cmd = Command::new(daemon);
    if let Some(arg) = bench_testnet_arg(chain_params) {
        cmd.arg(arg);
    }
    cmd.stdin(Stdio::null())
        .stdout(Stdio::null())
        .stderr(Stdio::null());
    cmd.spawn().map_err(|err| {
        RpcError::new(
            RPC_INTERNAL_ERROR,
            format!("failed to start benchmark: {err}"),
        )
    })?;

    std::thread::sleep(Duration::from_secs(4));
    Ok(Value::String("Starting process".to_string()))
}

fn rpc_stopbenchmark(
    params: Vec<Value>,
    data_dir: &Path,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    ensure_no_params(&params)?;
    ensure_fluxnode_mode(data_dir)?;
    if !is_fluxbenchd_running(chain_params) {
        return Ok(Value::String("Not running".to_string()));
    }
    run_bench_cli(chain_params, &["stop"]);
    Ok(Value::String("Stopping process".to_string()))
}

fn rpc_zcbenchmark(params: Vec<Value>) -> Result<Value, RpcError> {
    if params.len() < 2 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "zcbenchmark expects at least 2 parameters",
        ));
    }
    let benchmark_type = params[0]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_TYPE_ERROR, "Invalid benchmarktype"))?;
    let samplecount = parse_i64(&params[1], "samplecount")?;
    if samplecount <= 0 {
        return Err(RpcError::new(RPC_TYPE_ERROR, "Invalid samplecount"));
    }
    let samplecount: usize = usize::try_from(samplecount)
        .map_err(|_| RpcError::new(RPC_INVALID_PARAMETER, "samplecount too large"))?;

    match benchmark_type {
        "sleep" => {}
        "parameterloading" => {
            return Err(RpcError::new(
                RPC_TYPE_ERROR,
                "Pre-Sapling Sprout parameters have been removed",
            ));
        }
        _ => return Err(RpcError::new(RPC_TYPE_ERROR, "Invalid benchmarktype")),
    }

    let mut results = Vec::with_capacity(samplecount);
    for _ in 0..samplecount {
        let start = Instant::now();
        std::thread::sleep(Duration::from_secs(1));
        results.push(json!({
            "runningtime": start.elapsed().as_secs_f64(),
        }));
    }
    Ok(Value::Array(results))
}

fn rpc_getdoslist<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    ensure_no_params(&params)?;
    let best_height = best_block_height(chainstate)?;
    let pon_active = network_upgrade_active(
        best_height,
        &chain_params.consensus.upgrades,
        UpgradeIndex::Pon,
    );
    let expiration = if pon_active {
        FLUXNODE_START_TX_EXPIRATION_HEIGHT_V2
    } else {
        FLUXNODE_START_TX_EXPIRATION_HEIGHT
    };
    let dos_remove = if pon_active {
        FLUXNODE_DOS_REMOVE_AMOUNT_V2
    } else {
        FLUXNODE_DOS_REMOVE_AMOUNT
    };

    let mut entries = Vec::new();
    for record in chainstate.fluxnode_records().map_err(map_internal)? {
        if record.confirmed_height != 0 {
            continue;
        }
        let Ok(start_height) = i32::try_from(record.start_height) else {
            continue;
        };
        if best_height < start_height {
            continue;
        }
        let age = best_height - start_height;
        if age <= expiration || age > dos_remove {
            continue;
        }
        let eligible_in = dos_remove - age;
        let payment_address =
            fluxnode_payment_address(chainstate, &record, chain_params)?.unwrap_or_default();
        let mut obj = serde_json::Map::new();
        obj.insert(
            "collateral".to_string(),
            Value::String(format_outpoint(&record.collateral)),
        );
        obj.insert(
            "added_height".to_string(),
            Value::Number((record.start_height as i64).into()),
        );
        obj.insert(
            "payment_address".to_string(),
            Value::String(payment_address),
        );
        obj.insert(
            "eligible_in".to_string(),
            Value::Number((eligible_in as i64).into()),
        );
        if record.collateral_value > 0 {
            obj.insert(
                "amount".to_string(),
                Value::String(format_money(record.collateral_value)),
            );
        }
        entries.push(Value::Object(obj));
    }
    entries.sort_by(|a, b| {
        let left = a
            .get("eligible_in")
            .and_then(|value| value.as_i64())
            .unwrap_or(i64::MAX);
        let right = b
            .get("eligible_in")
            .and_then(|value| value.as_i64())
            .unwrap_or(i64::MAX);
        left.cmp(&right)
    });
    Ok(Value::Array(entries))
}

fn rpc_getstartlist<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    ensure_no_params(&params)?;
    let best_height = best_block_height(chainstate)?;
    let pon_active = network_upgrade_active(
        best_height,
        &chain_params.consensus.upgrades,
        UpgradeIndex::Pon,
    );
    let expiration = if pon_active {
        FLUXNODE_START_TX_EXPIRATION_HEIGHT_V2
    } else {
        FLUXNODE_START_TX_EXPIRATION_HEIGHT
    };

    let mut entries = Vec::new();
    for record in chainstate.fluxnode_records().map_err(map_internal)? {
        if record.confirmed_height != 0 {
            continue;
        }
        let Ok(start_height) = i32::try_from(record.start_height) else {
            continue;
        };
        if best_height < start_height {
            continue;
        }
        let age = best_height - start_height;
        if age > expiration {
            continue;
        }
        let expires_in = expiration - age;
        let payment_address =
            fluxnode_payment_address(chainstate, &record, chain_params)?.unwrap_or_default();
        let mut obj = serde_json::Map::new();
        obj.insert(
            "collateral".to_string(),
            Value::String(format_outpoint(&record.collateral)),
        );
        obj.insert(
            "added_height".to_string(),
            Value::Number((record.start_height as i64).into()),
        );
        obj.insert(
            "payment_address".to_string(),
            Value::String(payment_address),
        );
        obj.insert(
            "expires_in".to_string(),
            Value::Number((expires_in as i64).into()),
        );
        if record.collateral_value > 0 {
            obj.insert(
                "amount".to_string(),
                Value::String(format_money(record.collateral_value)),
            );
        }
        entries.push(Value::Object(obj));
    }
    entries.sort_by(|a, b| {
        let left = a
            .get("expires_in")
            .and_then(|value| value.as_i64())
            .unwrap_or(i64::MAX);
        let right = b
            .get("expires_in")
            .and_then(|value| value.as_i64())
            .unwrap_or(i64::MAX);
        left.cmp(&right)
    });
    Ok(Value::Array(entries))
}

fn rpc_getblockhashes<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    params: Vec<Value>,
) -> Result<Value, RpcError> {
    if params.len() < 2 || params.len() > 3 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "getblockhashes expects 2 or 3 parameters",
        ));
    }
    let high = parse_u32(&params[0], "high")?;
    let low = parse_u32(&params[1], "low")?;
    let mut no_orphans = false;
    let mut logical_times = false;
    if params.len() > 2 {
        let options = params[2]
            .as_object()
            .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "options must be an object"))?;
        if let Some(value) = options.get("noOrphans") {
            no_orphans = parse_bool(value)?;
        }
        if let Some(value) = options.get("logicalTimes") {
            logical_times = parse_bool(value)?;
        }
    }

    let mut entries = chainstate.scan_timestamp_index().map_err(map_internal)?;
    entries.retain(|(timestamp, _)| *timestamp >= low && *timestamp < high);
    entries.sort_by(|a, b| a.0.cmp(&b.0).then_with(|| a.1.cmp(&b.1)));

    let mut out = Vec::new();
    for (timestamp, hash) in entries {
        if no_orphans {
            let entry = match chainstate.header_entry(&hash).map_err(map_internal)? {
                Some(entry) => entry,
                None => continue,
            };
            let main_hash = chainstate.height_hash(entry.height).map_err(map_internal)?;
            if main_hash != Some(hash) {
                continue;
            }
        }
        if logical_times {
            out.push(json!({
                "blockhash": hash256_to_hex(&hash),
                "logicalts": timestamp,
            }));
        } else {
            out.push(Value::String(hash256_to_hex(&hash)));
        }
    }
    Ok(Value::Array(out))
}

fn rpc_gettxstats<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    params: Vec<Value>,
) -> Result<Value, RpcError> {
    if params.len() < 2 || params.len() > 3 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "gettxstats expects 2 or 3 parameters",
        ));
    }

    let high = parse_u32(&params[0], "high")?;
    let low = parse_u32(&params[1], "low")?;

    let mut no_orphans = false;
    if params.len() > 2 {
        let options = params[2]
            .as_object()
            .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "options must be an object"))?;
        if let Some(value) = options.get("noOrphans") {
            no_orphans = parse_bool(value)?;
        }
    }

    let mut entries = chainstate.scan_timestamp_index().map_err(map_internal)?;
    entries.retain(|(timestamp, _)| *timestamp >= low && *timestamp < high);
    entries.sort_by(|a, b| a.0.cmp(&b.0).then_with(|| a.1.cmp(&b.1)));

    let mut blocks = 0u64;
    let mut tx_count = 0u64;
    let mut fluxnode_tx_count = 0u64;

    for (_timestamp, hash) in entries {
        if no_orphans {
            let entry = match chainstate.header_entry(&hash).map_err(map_internal)? {
                Some(entry) => entry,
                None => continue,
            };
            let main_hash = chainstate.height_hash(entry.height).map_err(map_internal)?;
            if main_hash != Some(hash) {
                continue;
            }
        }

        let Some(block_index) = chainstate
            .block_index_entry(&hash)
            .map_err(map_internal)?
        else {
            continue;
        };

        let bytes = chainstate
            .read_block(block_index.block)
            .map_err(map_internal)?;
        let block = Block::consensus_decode(&bytes).map_err(map_internal)?;

        blocks = blocks.saturating_add(1);
        tx_count = tx_count.saturating_add(block.transactions.len() as u64);
        fluxnode_tx_count = fluxnode_tx_count.saturating_add(
            block
                .transactions
                .iter()
                .filter(|tx| tx.fluxnode.is_some())
                .count() as u64,
        );
    }

    let regular_tx_count = tx_count.saturating_sub(fluxnode_tx_count);

    Ok(json!({
        "low": low,
        "high": high,
        "blocks": blocks,
        "txCount": tx_count,
        "regularTxCount": regular_tx_count,
        "fluxnodeTxCount": fluxnode_tx_count,
        "generatedAt": current_unix_seconds_u64().to_string(),
    }))
}

fn network_hashps<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    chain_params: &ChainParams,
    mut lookup: i64,
    height: i64,
) -> Result<i64, RpcError> {
    let best = chainstate.best_block().map_err(map_internal)?;
    let Some(best) = best else {
        return Ok(0);
    };

    let (mut pb_height, mut pb_hash) = (best.height, best.hash);
    if height >= 0 {
        let height: i32 = height
            .try_into()
            .map_err(|_| RpcError::new(RPC_INVALID_PARAMETER, "height out of range"))?;
        if height >= 0 && height < best.height {
            if let Some(hash) = chainstate.height_hash(height).map_err(map_internal)? {
                pb_height = height;
                pb_hash = hash;
            } else {
                return Ok(0);
            }
        }
    }

    if pb_height <= 0 {
        return Ok(0);
    }

    if lookup <= 0 {
        lookup = chain_params.consensus.digishield_averaging_window;
    }

    if lookup <= 0 {
        return Ok(0);
    }

    if lookup > pb_height as i64 {
        lookup = pb_height as i64;
    }

    let pb_entry = chainstate
        .header_entry(&pb_hash)
        .map_err(map_internal)?
        .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "missing header entry"))?;

    let mut pb0_entry = pb_entry.clone();

    let mut min_time = pb0_entry.time as i64;
    let mut max_time = min_time;

    for _ in 0..lookup {
        let prev_hash = pb0_entry.prev_hash;
        pb0_entry = chainstate
            .header_entry(&prev_hash)
            .map_err(map_internal)?
            .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "missing header entry"))?;

        let time = pb0_entry.time as i64;
        min_time = min_time.min(time);
        max_time = max_time.max(time);
    }

    if min_time == max_time {
        return Ok(0);
    }

    let time_diff = (max_time - min_time) as u64;
    if time_diff == 0 {
        return Ok(0);
    }

    let work_diff = pb_entry.chainwork_value() - pb0_entry.chainwork_value();
    let rate = work_diff / U256::from(time_diff);

    let max = U256::from(i64::MAX as u64);
    if rate > max {
        return Ok(i64::MAX);
    }

    Ok(rate.low_u64() as i64)
}

fn rpc_getnetworkhashps<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    if params.len() > 2 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "getnetworkhashps expects 0, 1, or 2 parameters",
        ));
    }

    let lookup = params.get(0).map(|v| parse_i64(v, "blocks")).transpose()?;
    let height = params.get(1).map(|v| parse_i64(v, "height")).transpose()?;
    let rate = network_hashps(
        chainstate,
        chain_params,
        lookup.unwrap_or(120),
        height.unwrap_or(-1),
    )?;
    Ok(json!(rate))
}

fn rpc_getnetworksolps<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    params: Vec<Value>,
    chain_params: &ChainParams,
) -> Result<Value, RpcError> {
    if params.len() > 2 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "getnetworksolps expects 0, 1, or 2 parameters",
        ));
    }

    let lookup = params.get(0).map(|v| parse_i64(v, "blocks")).transpose()?;
    let height = params.get(1).map(|v| parse_i64(v, "height")).transpose()?;
    let rate = network_hashps(
        chainstate,
        chain_params,
        lookup.unwrap_or(120),
        height.unwrap_or(-1),
    )?;
    Ok(json!(rate))
}

#[derive(Clone, Copy, Debug)]
struct LocalSolpsState {
    last_pow_headers: u64,
    last_seen_at: Option<Instant>,
}

fn local_solps(header_metrics: &HeaderMetrics) -> Result<f64, RpcError> {
    static STATE: OnceLock<Mutex<LocalSolpsState>> = OnceLock::new();

    let pow_headers = header_metrics.snapshot().pow_headers;
    let now = Instant::now();

    let lock = STATE.get_or_init(|| {
        Mutex::new(LocalSolpsState {
            last_pow_headers: pow_headers,
            last_seen_at: Some(now),
        })
    });
    let mut guard = lock
        .lock()
        .map_err(|_| map_internal("localsolps lock poisoned"))?;

    let solps = match guard.last_seen_at {
        None => 0.0,
        Some(prev) => {
            let dt = now.duration_since(prev).as_secs_f64();
            if dt <= 0.0 {
                0.0
            } else {
                let delta = pow_headers.saturating_sub(guard.last_pow_headers) as f64;
                delta / dt
            }
        }
    };

    guard.last_pow_headers = pow_headers;
    guard.last_seen_at = Some(now);

    Ok(solps)
}

fn rpc_getlocalsolps(
    params: Vec<Value>,
    header_metrics: &HeaderMetrics,
) -> Result<Value, RpcError> {
    ensure_no_params(&params)?;
    Ok(json!(local_solps(header_metrics)?))
}

fn rpc_estimatefee(
    params: Vec<Value>,
    fee_estimator: &Mutex<FeeEstimator>,
) -> Result<Value, RpcError> {
    if params.len() != 1 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "estimatefee expects 1 parameter",
        ));
    }
    let mut blocks = parse_u32(&params[0], "nblocks")?;
    if blocks < 1 {
        blocks = 1;
    }
    let estimate = fee_estimator
        .lock()
        .map_err(|_| map_internal("fee estimator lock poisoned"))?
        .estimate_fee_per_kb(blocks);
    match estimate {
        Some(amount) => Ok(amount_to_value(amount)),
        None => Ok(Number::from_f64(-1.0)
            .map(Value::Number)
            .unwrap_or(Value::Number((-1).into()))),
    }
}

fn rpc_estimatepriority(
    params: Vec<Value>,
    fee_estimator: &Mutex<FeeEstimator>,
) -> Result<Value, RpcError> {
    if params.len() != 1 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "estimatepriority expects 1 parameter",
        ));
    }
    let mut blocks = parse_u32(&params[0], "nblocks")?;
    if blocks < 1 {
        blocks = 1;
    }
    let estimate = fee_estimator
        .lock()
        .map_err(|_| map_internal("fee estimator lock poisoned"))?
        .estimate_priority(blocks);
    match estimate {
        Some(priority) => Ok(Number::from_f64(priority)
            .map(Value::Number)
            .unwrap_or(Value::Number(0.into()))),
        None => Ok(Number::from_f64(-1.0)
            .map(Value::Number)
            .unwrap_or(Value::Number((-1).into()))),
    }
}

fn rpc_prioritisetransaction(
    params: Vec<Value>,
    mempool: &Mutex<Mempool>,
) -> Result<Value, RpcError> {
    if params.len() != 3 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "prioritisetransaction expects 3 parameters",
        ));
    }

    let txid = parse_hash(&params[0])?;
    let priority_delta = parse_f64(&params[1], "priority_delta")?;
    let fee_delta = parse_i64(&params[2], "fee_delta")?;

    mempool
        .lock()
        .map_err(|_| map_internal("mempool lock poisoned"))?
        .prioritise_transaction(txid, priority_delta, fee_delta);

    Ok(Value::Bool(true))
}

fn rpc_getnetworkinfo(
    params: Vec<Value>,
    peer_registry: &PeerRegistry,
    net_totals: &NetTotals,
    mempool_policy: &MempoolPolicy,
) -> Result<Value, RpcError> {
    ensure_no_params(&params)?;
    let local_services: u64 = 1;
    let local_services_hex = format!("{:016x}", local_services);
    let snapshot = net_totals.snapshot();
    let connections = snapshot.connections.max(peer_registry.count());
    let networks = json!([
        {"name": "ipv4", "limited": false, "reachable": true, "proxy": ""},
        {"name": "ipv6", "limited": false, "reachable": true, "proxy": ""},
        {"name": "onion", "limited": true, "reachable": false, "proxy": ""}
    ]);
    Ok(json!({
        "version": node_version(),
        "subversion": format!("/fluxd-rust:{}/", env!("CARGO_PKG_VERSION")),
        "protocolversion": PROTOCOL_VERSION,
        "localservices": local_services_hex,
        "localservicesnames": service_flag_names(local_services),
        "timeoffset": 0,
        "connections": connections,
        "networks": networks,
        "relayfee": amount_to_value(mempool_policy.min_relay_fee_per_kb),
        "localaddresses": [],
        "warnings": ""
    }))
}

fn rpc_getconnectioncount(
    params: Vec<Value>,
    peer_registry: &PeerRegistry,
    net_totals: &NetTotals,
) -> Result<Value, RpcError> {
    ensure_no_params(&params)?;
    let snapshot = net_totals.snapshot();
    let count = snapshot.connections.max(peer_registry.count());
    Ok(Value::Number((count as i64).into()))
}

fn rpc_getnettotals(params: Vec<Value>, net_totals: &NetTotals) -> Result<Value, RpcError> {
    ensure_no_params(&params)?;
    let snapshot = net_totals.snapshot();
    let timemillis = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .map(|value| value.as_millis() as i64)
        .unwrap_or(0);
    Ok(json!({
        "totalbytesrecv": snapshot.bytes_recv,
        "totalbytessent": snapshot.bytes_sent,
        "timemillis": timemillis,
    }))
}

fn rpc_getpeerinfo(params: Vec<Value>, peer_registry: &PeerRegistry) -> Result<Value, RpcError> {
    ensure_no_params(&params)?;
    let peers = peer_registry.snapshot();
    let mut out = Vec::with_capacity(peers.len());
    for peer in peers {
        let services_hex = format!("{:016x}", peer.services);
        let services_names = service_flag_names(peer.services);
        out.push(json!({
            "addr": peer.addr.to_string(),
            "subver": peer.user_agent,
            "version": peer.version,
            "services": services_hex,
            "servicesnames": services_names,
            "startingheight": peer.start_height,
            "conntime": system_time_to_unix(peer.connected_since),
            "lastsend": system_time_to_unix(peer.last_send),
            "lastrecv": system_time_to_unix(peer.last_recv),
            "bytessent": peer.bytes_sent,
            "bytesrecv": peer.bytes_recv,
            "inbound": peer.inbound,
            "kind": peer_kind_name(peer.kind),
        }));
    }
    Ok(Value::Array(out))
}

fn service_flag_names(services: u64) -> Vec<&'static str> {
    const NODE_NETWORK: u64 = 1;
    const NODE_GETUTXO: u64 = 1 << 1;
    const NODE_BLOOM: u64 = 1 << 2;
    const NODE_WITNESS: u64 = 1 << 3;
    const NODE_COMPACT_FILTERS: u64 = 1 << 6;
    const NODE_NETWORK_LIMITED: u64 = 1 << 10;
    const NODE_P2P_V2: u64 = 1 << 11;

    let mut out = Vec::new();
    if services & NODE_NETWORK != 0 {
        out.push("NETWORK");
    }
    if services & NODE_GETUTXO != 0 {
        out.push("GETUTXO");
    }
    if services & NODE_BLOOM != 0 {
        out.push("BLOOM");
    }
    if services & NODE_WITNESS != 0 {
        out.push("WITNESS");
    }
    if services & NODE_COMPACT_FILTERS != 0 {
        out.push("COMPACT_FILTERS");
    }
    if services & NODE_NETWORK_LIMITED != 0 {
        out.push("NETWORK_LIMITED");
    }
    if services & NODE_P2P_V2 != 0 {
        out.push("P2P_V2");
    }
    out
}

fn rpc_listbanned(
    params: Vec<Value>,
    header_peer_book: &HeaderPeerBook,
) -> Result<Value, RpcError> {
    ensure_no_params(&params)?;
    let banned = header_peer_book.banned_peers();
    let mut out = Vec::with_capacity(banned.len());
    for entry in banned {
        out.push(json!({
            "address": entry.addr.to_string(),
            "banned_until": system_time_to_unix(entry.banned_until),
        }));
    }
    Ok(Value::Array(out))
}

fn parse_socket_addr_with_default(value: &str, default_port: u16) -> Result<SocketAddr, RpcError> {
    if let Ok(addr) = value.parse::<SocketAddr>() {
        return Ok(addr);
    }
    if let Ok(ip) = value.parse::<IpAddr>() {
        return Ok(SocketAddr::new(ip, default_port));
    }
    Err(RpcError::new(
        RPC_INVALID_PARAMETER,
        "invalid address (expected ip or ip:port)",
    ))
}

fn resolve_node_addrs(value: &str, default_port: u16) -> Vec<SocketAddr> {
    let value = value.trim();
    if value.is_empty() {
        return Vec::new();
    }
    if let Ok(addr) = value.parse::<SocketAddr>() {
        return vec![addr];
    }
    if let Ok(ip) = value.parse::<IpAddr>() {
        return vec![SocketAddr::new(ip, default_port)];
    }
    let resolved = if value.rfind(':').is_some() {
        value.to_socket_addrs()
    } else {
        (value, default_port).to_socket_addrs()
    };
    let mut out: Vec<SocketAddr> = match resolved {
        Ok(iter) => iter.collect(),
        Err(_) => Vec::new(),
    };
    out.sort_by_key(|addr| addr.to_string());
    out.dedup();
    out
}

fn rpc_clearbanned(
    params: Vec<Value>,
    header_peer_book: &HeaderPeerBook,
) -> Result<Value, RpcError> {
    ensure_no_params(&params)?;
    header_peer_book.clear_banned();
    Ok(Value::Null)
}

fn rpc_setban(
    params: Vec<Value>,
    chain_params: &ChainParams,
    peer_registry: &PeerRegistry,
    header_peer_book: &HeaderPeerBook,
) -> Result<Value, RpcError> {
    if params.len() < 2 || params.len() > 4 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "setban expects 2 to 4 parameters",
        ));
    }
    let addr_raw = params[0]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "address must be a string"))?;
    let addr = parse_socket_addr_with_default(addr_raw, chain_params.default_port)?;
    let command = params[1]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "command must be a string"))?;

    match command {
        "add" => {
            const DEFAULT_BAN_SECS: u64 = 24 * 60 * 60;

            let mut bantime: u64 = DEFAULT_BAN_SECS;
            let mut absolute = false;
            if params.len() >= 3 && !params[2].is_null() {
                let value = params[2].as_i64().ok_or_else(|| {
                    RpcError::new(RPC_INVALID_PARAMETER, "bantime must be an integer")
                })?;
                bantime = value.max(0) as u64;
            }
            if params.len() == 4 && !params[3].is_null() {
                absolute = params[3].as_bool().ok_or_else(|| {
                    RpcError::new(RPC_INVALID_PARAMETER, "absolute must be a boolean")
                })?;
            }
            if bantime == 0 {
                bantime = DEFAULT_BAN_SECS;
            }
            if absolute {
                let now = SystemTime::now()
                    .duration_since(UNIX_EPOCH)
                    .unwrap_or_default()
                    .as_secs();
                if bantime <= now {
                    header_peer_book.unban(addr);
                    return Ok(Value::Null);
                }
                bantime = bantime.saturating_sub(now);
            }

            header_peer_book.ban_for(addr, bantime);
            peer_registry.request_disconnect(addr);
        }
        "remove" => {
            header_peer_book.unban(addr);
        }
        _ => {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                "command must be 'add' or 'remove'",
            ))
        }
    }

    Ok(Value::Null)
}

fn rpc_disconnectnode(
    params: Vec<Value>,
    chain_params: &ChainParams,
    peer_registry: &PeerRegistry,
) -> Result<Value, RpcError> {
    if params.len() != 1 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "disconnectnode expects 1 parameter",
        ));
    }
    let addr_raw = params[0]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "address must be a string"))?;
    let addr = parse_socket_addr_with_default(addr_raw, chain_params.default_port)?;
    if !peer_registry
        .snapshot()
        .iter()
        .any(|peer| peer.addr == addr)
    {
        return Err(RpcError::new(
            RPC_CLIENT_NODE_NOT_CONNECTED,
            "Node not found in connected nodes",
        ));
    }
    peer_registry.request_disconnect(addr);
    Ok(Value::Null)
}

fn rpc_addnode(
    params: Vec<Value>,
    chain_params: &ChainParams,
    addr_book: &AddrBook,
    added_nodes: &Mutex<HashSet<String>>,
) -> Result<Value, RpcError> {
    if params.len() != 2 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "addnode expects 2 parameters",
        ));
    }
    let node_raw = params[0]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "node must be a string"))?;
    let node_raw = node_raw.trim();
    if node_raw.is_empty() {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "node must be a non-empty string",
        ));
    }
    let command = params[1]
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "command must be a string"))?;

    let resolved_addrs = resolve_node_addrs(node_raw, chain_params.default_port);
    match command {
        "add" => {
            let Ok(mut guard) = added_nodes.lock() else {
                return Err(RpcError::new(
                    RPC_INTERNAL_ERROR,
                    "added nodes lock poisoned",
                ));
            };
            if guard.contains(node_raw) {
                return Err(RpcError::new(
                    RPC_CLIENT_NODE_ALREADY_ADDED,
                    "Error: Node already added",
                ));
            }
            guard.insert(node_raw.to_string());
            let _ = addr_book.insert_many(resolved_addrs);
        }
        "remove" => {
            let Ok(mut guard) = added_nodes.lock() else {
                return Err(RpcError::new(
                    RPC_INTERNAL_ERROR,
                    "added nodes lock poisoned",
                ));
            };
            if !guard.remove(node_raw) {
                return Err(RpcError::new(
                    RPC_CLIENT_NODE_NOT_ADDED,
                    "Error: Node has not been added.",
                ));
            }
        }
        "onetry" => {
            for addr in &resolved_addrs {
                addr_book.record_attempt(*addr);
            }
            let _ = addr_book.insert_many(resolved_addrs);
        }
        _ => {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                "command must be 'add', 'remove', or 'onetry'",
            ))
        }
    }

    Ok(Value::Null)
}

fn rpc_getaddednodeinfo(
    params: Vec<Value>,
    chain_params: &ChainParams,
    peer_registry: &PeerRegistry,
    added_nodes: &Mutex<HashSet<String>>,
) -> Result<Value, RpcError> {
    let (dns, node_filter) = match params.len() {
        0 => (true, None),
        1 => {
            if let Some(value) = params[0].as_bool() {
                (value, None)
            } else if let Some(value) = params[0].as_str() {
                (true, Some(value.to_string()))
            } else {
                return Err(RpcError::new(
                    RPC_INVALID_PARAMETER,
                    "getaddednodeinfo expects dns boolean or node string",
                ));
            }
        }
        2 => {
            let dns = params[0]
                .as_bool()
                .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "dns must be a boolean"))?;
            let node = params[1]
                .as_str()
                .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "node must be a string"))?;
            (dns, Some(node.to_string()))
        }
        _ => {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                "getaddednodeinfo expects 0 to 2 parameters",
            ))
        }
    };

    let mut nodes = {
        let Ok(guard) = added_nodes.lock() else {
            return Err(RpcError::new(
                RPC_INTERNAL_ERROR,
                "added nodes lock poisoned",
            ));
        };
        guard.iter().cloned().collect::<Vec<_>>()
    };
    nodes.sort_by_key(|node| node.to_string());

    if let Some(filter) = node_filter.as_deref() {
        if !nodes.contains(&filter.to_string()) {
            return Err(RpcError::new(
                RPC_CLIENT_NODE_NOT_ADDED,
                "Error: Node has not been added.",
            ));
        }
        nodes = vec![filter.to_string()];
    }

    if !dns {
        let out = nodes
            .into_iter()
            .map(|node| json!({ "addednode": node }))
            .collect();
        return Ok(Value::Array(out));
    }

    let connected: HashMap<SocketAddr, &'static str> = peer_registry
        .snapshot()
        .into_iter()
        .map(|entry| {
            (
                entry.addr,
                if entry.inbound { "inbound" } else { "outbound" },
            )
        })
        .collect();

    let mut out = Vec::with_capacity(nodes.len());
    for node in nodes {
        let resolved = resolve_node_addrs(&node, chain_params.default_port);
        let mut connected_any = false;
        let mut addresses = Vec::with_capacity(resolved.len());
        for addr in resolved {
            let status = match connected.get(&addr) {
                Some(value) => {
                    connected_any = true;
                    Value::String((*value).to_string())
                }
                None => Value::String("false".to_string()),
            };
            addresses.push(json!({
                "address": addr.to_string(),
                "connected": status,
            }));
        }
        out.push(json!({
            "addednode": node,
            "connected": connected_any,
            "addresses": addresses,
        }));
    }
    Ok(Value::Array(out))
}

fn branch_len<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    tip_hash: &Hash256,
    tip_height: i32,
) -> Result<i32, RpcError> {
    let mut height = tip_height;
    let mut hash = *tip_hash;
    loop {
        if let Some(main_hash) = chainstate.height_hash(height).map_err(map_internal)? {
            if main_hash == hash {
                return Ok(tip_height - height);
            }
        }
        if height == 0 {
            break;
        }
        let entry = chainstate
            .header_entry(&hash)
            .map_err(map_internal)?
            .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "missing header entry"))?;
        hash = entry.prev_hash;
        height -= 1;
    }
    Ok(tip_height)
}

fn tx_to_json(tx: &Transaction, network: Network) -> Result<Value, RpcError> {
    let txid = tx.txid().map_err(map_internal)?;
    let encoded = tx.consensus_encode().map_err(map_internal)?;
    let mut entry = json!({
        "txid": hash256_to_hex(&txid),
        "version": tx.version,
        "size": encoded.len(),
        "overwintered": tx.f_overwintered,
        "locktime": tx.lock_time,
    });

    if let Some(fluxnode) = tx.fluxnode.as_ref() {
        match fluxnode {
            FluxnodeTx::V5(FluxnodeTxV5::Start(start)) => {
                entry["nType"] = Value::Number(2.into());
                entry["collateralOutputHash"] = Value::String(hash256_to_hex(&start.collateral.hash));
                entry["collateralOutputIndex"] = Value::Number((start.collateral.index as i64).into());
            }
            FluxnodeTx::V6(FluxnodeTxV6::Start(start)) => {
                entry["nType"] = Value::Number(2.into());
                let collateral = match &start.variant {
                    FluxnodeStartVariantV6::Normal { collateral, .. } => collateral,
                    FluxnodeStartVariantV6::P2sh { collateral, .. } => collateral,
                };
                entry["collateralOutputHash"] = Value::String(hash256_to_hex(&collateral.hash));
                entry["collateralOutputIndex"] = Value::Number((collateral.index as i64).into());
            }
            FluxnodeTx::V5(FluxnodeTxV5::Confirm(confirm))
            | FluxnodeTx::V6(FluxnodeTxV6::Confirm(confirm)) => {
                entry["nType"] = Value::Number(4.into());
                entry["ip"] = Value::String(confirm.ip.clone());
                entry["benchmarkTier"] = Value::String(fluxnode_tier_name(confirm.benchmark_tier).to_string());
                entry["collateralOutputHash"] = Value::String(hash256_to_hex(&confirm.collateral.hash));
                entry["collateralOutputIndex"] = Value::Number((confirm.collateral.index as i64).into());
            }
        }
    }

    if tx.f_overwintered {
        entry["versiongroupid"] = Value::String(format!("{:08x}", tx.version_group_id));
        entry["expiryheight"] = Value::Number(tx.expiry_height.into());
    }

    let mut vin = Vec::with_capacity(tx.vin.len());
    for input in &tx.vin {
        let mut map = serde_json::Map::new();
        if input.prevout.hash == [0u8; 32] && input.prevout.index == u32::MAX {
            map.insert(
                "coinbase".to_string(),
                Value::String(hex_bytes(&input.script_sig)),
            );
        } else {
            map.insert(
                "txid".to_string(),
                Value::String(hash256_to_hex(&input.prevout.hash)),
            );
            map.insert(
                "vout".to_string(),
                Value::Number(input.prevout.index.into()),
            );
            map.insert(
                "scriptSig".to_string(),
                json!({
                    "asm": script_to_asm(&input.script_sig),
                    "hex": hex_bytes(&input.script_sig),
                }),
            );
        }
        map.insert("sequence".to_string(), Value::Number(input.sequence.into()));
        vin.push(Value::Object(map));
    }
    entry["vin"] = Value::Array(vin);

    let mut vout = Vec::with_capacity(tx.vout.len());
    for (index, output) in tx.vout.iter().enumerate() {
        let script = script_pubkey_json(&output.script_pubkey, network);
        let out = json!({
            "value": amount_to_value(output.value),
            "n": index,
            "scriptPubKey": script,
        });
        vout.push(out);
    }
    entry["vout"] = Value::Array(vout);
    Ok(entry)
}

fn script_type_name(script: &[u8]) -> &'static str {
    match classify_script_pubkey(script) {
        ScriptType::P2Pk => "pubkey",
        ScriptType::P2Pkh => "pubkeyhash",
        ScriptType::P2Sh => "scripthash",
        ScriptType::P2Wpkh => "witness_v0_keyhash",
        ScriptType::P2Wsh => "witness_v0_scripthash",
        ScriptType::Unknown => "nonstandard",
    }
}

fn script_pubkey_json(script: &[u8], network: Network) -> Value {
    let script_type = script_type_name(script);
    let mut map = serde_json::Map::new();
    map.insert("asm".to_string(), Value::String(script_to_asm(script)));
    map.insert("hex".to_string(), Value::String(hex_bytes(script)));
    map.insert("type".to_string(), Value::String(script_type.to_string()));
    if let Some(req_sigs) = script_req_sigs(script_type) {
        map.insert("reqSigs".to_string(), Value::Number(req_sigs.into()));
    }
    if let Some(address) = script_pubkey_to_address(script, network) {
        map.insert(
            "addresses".to_string(),
            Value::Array(vec![Value::String(address)]),
        );
    }
    Value::Object(map)
}

fn script_p2sh_address(script: &[u8], network: Network) -> String {
    let hash = hash160(script);
    let mut script_pubkey = Vec::with_capacity(23);
    script_pubkey.push(0xa9);
    script_pubkey.push(0x14);
    script_pubkey.extend_from_slice(&hash);
    script_pubkey.push(0x87);
    script_pubkey_to_address(&script_pubkey, network).unwrap_or_default()
}

fn multisig_small_int_opcode(value: usize) -> Result<u8, RpcError> {
    match value {
        1..=16 => Ok(0x50u8 + value as u8),
        _ => Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "multisig param out of range",
        )),
    }
}

fn script_req_sigs(script_type: &str) -> Option<i64> {
    match script_type {
        "pubkeyhash" | "scripthash" | "witness_v0_keyhash" => Some(1),
        _ => None,
    }
}

fn script_to_asm(script: &[u8]) -> String {
    let mut parts = Vec::new();
    let mut idx = 0usize;
    while idx < script.len() {
        let opcode = script[idx];
        idx += 1;
        match opcode {
            0x00 => parts.push("0".to_string()),
            0x01..=0x4b => {
                let len = opcode as usize;
                if idx + len > script.len() {
                    parts.push("OP_INVALID_PUSH".to_string());
                    break;
                }
                parts.push(hex_bytes(&script[idx..idx + len]));
                idx += len;
            }
            0x4c => {
                if idx >= script.len() {
                    parts.push("OP_PUSHDATA1".to_string());
                    break;
                }
                let len = script[idx] as usize;
                idx += 1;
                if idx + len > script.len() {
                    parts.push("OP_INVALID_PUSHDATA1".to_string());
                    break;
                }
                parts.push(hex_bytes(&script[idx..idx + len]));
                idx += len;
            }
            0x4d => {
                if idx + 1 >= script.len() {
                    parts.push("OP_PUSHDATA2".to_string());
                    break;
                }
                let len = u16::from_le_bytes([script[idx], script[idx + 1]]) as usize;
                idx += 2;
                if idx + len > script.len() {
                    parts.push("OP_INVALID_PUSHDATA2".to_string());
                    break;
                }
                parts.push(hex_bytes(&script[idx..idx + len]));
                idx += len;
            }
            0x4e => {
                if idx + 3 >= script.len() {
                    parts.push("OP_PUSHDATA4".to_string());
                    break;
                }
                let len = u32::from_le_bytes([
                    script[idx],
                    script[idx + 1],
                    script[idx + 2],
                    script[idx + 3],
                ]) as usize;
                idx += 4;
                if idx + len > script.len() {
                    parts.push("OP_INVALID_PUSHDATA4".to_string());
                    break;
                }
                parts.push(hex_bytes(&script[idx..idx + len]));
                idx += len;
            }
            0x51..=0x60 => parts.push((opcode - 0x50).to_string()),
            opcode => parts.push(opcode_name(opcode)),
        }
    }
    parts.join(" ")
}

fn opcode_name(opcode: u8) -> String {
    match opcode {
        0x61 => "OP_NOP".to_string(),
        0x63 => "OP_IF".to_string(),
        0x64 => "OP_NOTIF".to_string(),
        0x67 => "OP_ELSE".to_string(),
        0x68 => "OP_ENDIF".to_string(),
        0x69 => "OP_VERIFY".to_string(),
        0x6a => "OP_RETURN".to_string(),
        0x76 => "OP_DUP".to_string(),
        0xa9 => "OP_HASH160".to_string(),
        0x87 => "OP_EQUAL".to_string(),
        0x88 => "OP_EQUALVERIFY".to_string(),
        0xac => "OP_CHECKSIG".to_string(),
        0xae => "OP_CHECKMULTISIG".to_string(),
        _ => format!("0x{opcode:02x}"),
    }
}

fn fluxnode_tier_name(tier: u8) -> &'static str {
    match tier {
        1 => "CUMULUS",
        2 => "NIMBUS",
        3 => "STRATUS",
        _ => "UNKNOWN",
    }
}

fn amount_to_value(amount: i64) -> Value {
    let value = amount as f64 / COIN as f64;
    Number::from_f64(value)
        .map(Value::Number)
        .unwrap_or(Value::Number(0.into()))
}

fn format_money(amount: i64) -> String {
    let abs = (amount as i128).abs();
    let whole = abs / COIN as i128;
    let frac = abs % COIN as i128;
    let mut out = format!("{whole}.{frac:08}");

    while out.len() >= 3 {
        let len = out.len();
        let bytes = out.as_bytes();
        if bytes[len - 1] == b'0' && bytes[len - 3].is_ascii_digit() {
            out.pop();
        } else {
            break;
        }
    }

    if amount < 0 {
        out.insert(0, '-');
    }
    out
}

fn parse_amount(value: &Value) -> Result<i64, RpcError> {
    let text = match value {
        Value::Number(num) => num.to_string(),
        Value::String(text) => text.clone(),
        _ => {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                "amount must be a number or string",
            ))
        }
    };
    let text = text.trim();
    if text.is_empty() {
        return Err(RpcError::new(RPC_INVALID_PARAMETER, "amount is empty"));
    }

    let negative = text.starts_with('-');
    let text = text.strip_prefix('-').unwrap_or(text);

    let (whole, fractional) = match text.split_once('.') {
        Some((whole, fractional)) => (whole, fractional),
        None => (text, ""),
    };
    if whole.is_empty() && fractional.is_empty() {
        return Err(RpcError::new(RPC_INVALID_PARAMETER, "invalid amount"));
    }
    if !whole.is_empty() && !whole.chars().all(|ch| ch.is_ascii_digit()) {
        return Err(RpcError::new(RPC_INVALID_PARAMETER, "invalid amount"));
    }
    if !fractional.is_empty() && !fractional.chars().all(|ch| ch.is_ascii_digit()) {
        return Err(RpcError::new(RPC_INVALID_PARAMETER, "invalid amount"));
    }
    if fractional.len() > 8 {
        return Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "amount has too many decimal places",
        ));
    }

    let whole_value = if whole.is_empty() {
        0i64
    } else {
        whole
            .parse::<i64>()
            .map_err(|_| RpcError::new(RPC_INVALID_PARAMETER, "invalid amount"))?
    };
    let fractional_value = if fractional.is_empty() {
        0i64
    } else {
        let parsed = fractional
            .parse::<i64>()
            .map_err(|_| RpcError::new(RPC_INVALID_PARAMETER, "invalid amount"))?;
        let scale = 10i64.pow(8u32.saturating_sub(fractional.len() as u32));
        parsed
            .checked_mul(scale)
            .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "invalid amount"))?
    };

    let amount = whole_value
        .checked_mul(COIN)
        .and_then(|value| value.checked_add(fractional_value))
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "invalid amount"))?;
    let amount = if negative {
        amount
            .checked_neg()
            .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "invalid amount"))?
    } else {
        amount
    };
    if amount < 0 {
        return Err(RpcError::new(RPC_INVALID_PARAMETER, "amount out of range"));
    }
    if !fluxd_consensus::money::money_range(amount) {
        return Err(RpcError::new(RPC_INVALID_PARAMETER, "amount out of range"));
    }
    Ok(amount)
}

#[cfg(test)]
mod tests {
    use fluxd_primitives::transaction::OVERWINTER_VERSION_GROUP_ID;

    use super::*;
    use crate::mempool::MempoolEntry;
    use fluxd_chainstate::flatfiles::FlatFileStore;
    use fluxd_chainstate::validation::ValidationFlags;
    use fluxd_consensus::params::{chain_params, Network};
    use fluxd_fluxnode::storage::dedupe_key;
    use fluxd_primitives::block::BlockHeader;
    use fluxd_storage::memory::MemoryStore;
    use fluxd_storage::{Column, WriteBatch};
    use rand::RngCore;
    use sapling_crypto::note::Rseed;
    use sapling_crypto::note_encryption::{sapling_note_encryption, SaplingDomain};
    use sapling_crypto::value::NoteValue;
    use sapling_crypto::PaymentAddress;
    use serde_json::json;
    use std::path::PathBuf;
    use std::sync::{Arc, Mutex};
    use std::time::{SystemTime, UNIX_EPOCH};
    use zcash_note_encryption::Domain;

    fn temp_data_dir(prefix: &str) -> PathBuf {
        let nanos = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap_or_default()
            .as_nanos();
        std::env::temp_dir().join(format!("{prefix}-{}-{nanos}", std::process::id()))
    }

    fn is_hex_64(value: &str) -> bool {
        if value.len() != 64 {
            return false;
        }
        value
            .as_bytes()
            .iter()
            .all(|byte| matches!(byte, b'0'..=b'9' | b'a'..=b'f' | b'A'..=b'F'))
    }

    fn setup_regtest_chainstate() -> (
        ChainState<MemoryStore>,
        fluxd_consensus::params::ChainParams,
        PathBuf,
    ) {
        let data_dir = temp_data_dir("fluxd-rpc-test");
        std::fs::create_dir_all(&data_dir).expect("create data dir");
        let blocks_dir = data_dir.join("blocks");
        let blocks = FlatFileStore::new(&blocks_dir, 10_000_000).expect("flatfiles");
        let undo =
            FlatFileStore::new_with_prefix(&blocks_dir, "undo", 10_000_000).expect("flatfiles");
        let store = Arc::new(MemoryStore::new());
        let chainstate = ChainState::new(Arc::clone(&store), blocks, undo);

        let params = chain_params(Network::Regtest);
        let flags = ValidationFlags::default();
        let write_lock = Mutex::new(());
        crate::ensure_genesis(&chainstate, &params, &flags, None, &write_lock)
            .expect("insert genesis");

        (chainstate, params, data_dir)
    }

    fn setup_testnet_chainstate() -> (
        ChainState<MemoryStore>,
        fluxd_consensus::params::ChainParams,
        PathBuf,
    ) {
        let data_dir = temp_data_dir("fluxd-rpc-test-testnet");
        std::fs::create_dir_all(&data_dir).expect("create data dir");
        let blocks_dir = data_dir.join("blocks");
        let blocks = FlatFileStore::new(&blocks_dir, 10_000_000).expect("flatfiles");
        let undo =
            FlatFileStore::new_with_prefix(&blocks_dir, "undo", 10_000_000).expect("flatfiles");
        let store = Arc::new(MemoryStore::new());
        let chainstate = ChainState::new(Arc::clone(&store), blocks, undo);

        let params = chain_params(Network::Testnet);
        let flags = ValidationFlags::default();
        let write_lock = Mutex::new(());
        crate::ensure_genesis(&chainstate, &params, &flags, None, &write_lock)
            .expect("insert genesis");

        (chainstate, params, data_dir)
    }

    fn setup_regtest_chainstate_store() -> (
        ChainState<Store>,
        fluxd_consensus::params::ChainParams,
        PathBuf,
        Arc<Store>,
    ) {
        let data_dir = temp_data_dir("fluxd-rpc-test-store");
        std::fs::create_dir_all(&data_dir).expect("create data dir");
        let blocks_dir = data_dir.join("blocks");
        let blocks = FlatFileStore::new(&blocks_dir, 10_000_000).expect("flatfiles");
        let undo =
            FlatFileStore::new_with_prefix(&blocks_dir, "undo", 10_000_000).expect("flatfiles");
        let store = Arc::new(Store::Memory(MemoryStore::new()));
        let chainstate = ChainState::new(Arc::clone(&store), blocks, undo);

        let params = chain_params(Network::Regtest);
        let flags = ValidationFlags::default();
        let write_lock = Mutex::new(());
        crate::ensure_genesis(&chainstate, &params, &flags, None, &write_lock)
            .expect("insert genesis");

        (chainstate, params, data_dir, store)
    }

    fn extend_regtest_chain_to_height(
        chainstate: &ChainState<MemoryStore>,
        params: &fluxd_consensus::params::ChainParams,
        target_height: i32,
    ) {
        let flags = ValidationFlags::default();
        loop {
            let tip = chainstate
                .best_block()
                .expect("best block")
                .expect("best block present");
            if tip.height >= target_height {
                break;
            }
            let tip_entry = chainstate
                .header_entry(&tip.hash)
                .expect("header entry")
                .expect("header entry present");
            let height = tip.height + 1;
            let spacing = params.consensus.pow_target_spacing.max(1) as u32;
            let time = tip_entry.time.saturating_add(spacing);
            let bits = chainstate
                .next_work_required_bits(&tip.hash, height, time as i64, &params.consensus)
                .expect("next bits");

            let miner_value = block_subsidy(height, &params.consensus);
            let exchange_amount = exchange_fund_amount(height, &params.funding);
            let foundation_amount = foundation_fund_amount(height, &params.funding);
            let swap_amount = swap_pool_amount(height as i64, &params.swap_pool);

            let mut vout = Vec::new();
            vout.push(TxOut {
                value: miner_value,
                script_pubkey: Vec::new(),
            });
            if exchange_amount > 0 {
                let script =
                    address_to_script_pubkey(params.funding.exchange_address, params.network)
                        .expect("exchange address script");
                vout.push(TxOut {
                    value: exchange_amount,
                    script_pubkey: script,
                });
            }
            if foundation_amount > 0 {
                let script =
                    address_to_script_pubkey(params.funding.foundation_address, params.network)
                        .expect("foundation address script");
                vout.push(TxOut {
                    value: foundation_amount,
                    script_pubkey: script,
                });
            }
            if swap_amount > 0 {
                let script = address_to_script_pubkey(params.swap_pool.address, params.network)
                    .expect("swap pool address script");
                vout.push(TxOut {
                    value: swap_amount,
                    script_pubkey: script,
                });
            }
            let coinbase = Transaction {
                f_overwintered: false,
                version: 1,
                version_group_id: 0,
                vin: vec![TxIn {
                    prevout: OutPoint::null(),
                    script_sig: Vec::new(),
                    sequence: u32::MAX,
                }],
                vout,
                lock_time: 0,
                expiry_height: 0,
                value_balance: 0,
                shielded_spends: Vec::new(),
                shielded_outputs: Vec::new(),
                join_splits: Vec::new(),
                join_split_pub_key: [0u8; 32],
                join_split_sig: [0u8; 64],
                binding_sig: [0u8; 64],
                fluxnode: None,
            };

            let coinbase_txid = coinbase.txid().expect("coinbase txid");
            let final_sapling_root = chainstate.sapling_root().expect("sapling root");
            let header = BlockHeader {
                version: CURRENT_VERSION,
                prev_block: tip.hash,
                merkle_root: coinbase_txid,
                final_sapling_root,
                time,
                bits,
                nonce: [0u8; 32],
                solution: Vec::new(),
                nodes_collateral: OutPoint::null(),
                block_sig: Vec::new(),
            };

            let mut header_batch = WriteBatch::new();
            chainstate
                .insert_headers_batch_with_pow(
                    &[header.clone()],
                    &params.consensus,
                    &mut header_batch,
                    false,
                )
                .expect("insert header");
            chainstate
                .commit_batch(header_batch)
                .expect("commit header");

            let block = Block {
                header,
                transactions: vec![coinbase],
            };
            let block_bytes = block.consensus_encode().expect("encode block");
            let batch = chainstate
                .connect_block(
                    &block,
                    height,
                    params,
                    &flags,
                    true,
                    None,
                    None,
                    Some(block_bytes.as_slice()),
                    None,
                )
                .expect("connect block");
            chainstate.commit_batch(batch).expect("commit block");
        }
    }

    fn p2pkh_script(pubkey_hash: [u8; 20]) -> Vec<u8> {
        let mut script = Vec::with_capacity(25);
        script.extend_from_slice(&[0x76, 0xa9, 0x14]);
        script.extend_from_slice(&pubkey_hash);
        script.extend_from_slice(&[0x88, 0xac]);
        script
    }

    fn setup_regtest_chain_with_p2pkh_utxo() -> (
        ChainState<MemoryStore>,
        fluxd_consensus::params::ChainParams,
        PathBuf,
        String,
        Hash256,
        u32,
    ) {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();

        let tip = chainstate
            .best_block()
            .expect("best block")
            .expect("best block present");
        let tip_entry = chainstate
            .header_entry(&tip.hash)
            .expect("header entry")
            .expect("header entry present");
        let height = tip.height + 1;
        let spacing = params.consensus.pow_target_spacing.max(1) as u32;
        let time = tip_entry.time.saturating_add(spacing);
        let bits = chainstate
            .next_work_required_bits(&tip.hash, height, time as i64, &params.consensus)
            .expect("next bits");

        let pubkey_hash = [0x11u8; 20];
        let script_pubkey = p2pkh_script(pubkey_hash);
        let address =
            script_pubkey_to_address(&script_pubkey, params.network).expect("p2pkh address");

        let miner_value = block_subsidy(height, &params.consensus);
        let coinbase = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: vec![TxIn {
                prevout: OutPoint::null(),
                script_sig: Vec::new(),
                sequence: u32::MAX,
            }],
            vout: vec![TxOut {
                value: miner_value,
                script_pubkey: script_pubkey.clone(),
            }],
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };

        let coinbase_txid = coinbase.txid().expect("coinbase txid");
        let final_sapling_root = chainstate.sapling_root().expect("sapling root");
        let header = BlockHeader {
            version: CURRENT_VERSION,
            prev_block: tip.hash,
            merkle_root: coinbase_txid,
            final_sapling_root,
            time,
            bits,
            nonce: [0u8; 32],
            solution: Vec::new(),
            nodes_collateral: OutPoint::null(),
            block_sig: Vec::new(),
        };

        let mut header_batch = WriteBatch::new();
        chainstate
            .insert_headers_batch_with_pow(
                &[header.clone()],
                &params.consensus,
                &mut header_batch,
                false,
            )
            .expect("insert header");
        chainstate
            .commit_batch(header_batch)
            .expect("commit header");

        let block = Block {
            header,
            transactions: vec![coinbase],
        };
        let block_bytes = block.consensus_encode().expect("encode block");
        let flags = ValidationFlags::default();
        let batch = chainstate
            .connect_block(
                &block,
                height,
                &params,
                &flags,
                true,
                None,
                None,
                Some(block_bytes.as_slice()),
                None,
            )
            .expect("connect block");
        chainstate.commit_batch(batch).expect("commit block");

        (chainstate, params, data_dir, address, coinbase_txid, 0)
    }

    fn setup_testnet_chain_with_p2pkh_utxo() -> (
        ChainState<MemoryStore>,
        fluxd_consensus::params::ChainParams,
        PathBuf,
        String,
        Hash256,
        u32,
    ) {
        let (chainstate, params, data_dir) = setup_testnet_chainstate();

        let tip = chainstate
            .best_block()
            .expect("best block")
            .expect("best block present");
        let tip_entry = chainstate
            .header_entry(&tip.hash)
            .expect("header entry")
            .expect("header entry present");
        let height = tip.height + 1;
        let spacing = params.consensus.pow_target_spacing.max(1) as u32;
        let time = tip_entry.time.saturating_add(spacing);
        let bits = chainstate
            .next_work_required_bits(&tip.hash, height, time as i64, &params.consensus)
            .expect("next bits");

        let pubkey_hash = [0x11u8; 20];
        let script_pubkey = p2pkh_script(pubkey_hash);
        let address =
            script_pubkey_to_address(&script_pubkey, params.network).expect("p2pkh address");

        let miner_value = block_subsidy(height, &params.consensus);
        let coinbase = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: vec![TxIn {
                prevout: OutPoint::null(),
                script_sig: Vec::new(),
                sequence: u32::MAX,
            }],
            vout: vec![TxOut {
                value: miner_value,
                script_pubkey: script_pubkey.clone(),
            }],
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };

        let coinbase_txid = coinbase.txid().expect("coinbase txid");
        let final_sapling_root = chainstate.sapling_root().expect("sapling root");
        let header = BlockHeader {
            version: CURRENT_VERSION,
            prev_block: tip.hash,
            merkle_root: coinbase_txid,
            final_sapling_root,
            time,
            bits,
            nonce: [0u8; 32],
            solution: Vec::new(),
            nodes_collateral: OutPoint::null(),
            block_sig: Vec::new(),
        };

        let mut header_batch = WriteBatch::new();
        chainstate
            .insert_headers_batch_with_pow(
                &[header.clone()],
                &params.consensus,
                &mut header_batch,
                false,
            )
            .expect("insert header");
        chainstate
            .commit_batch(header_batch)
            .expect("commit header");

        let block = Block {
            header,
            transactions: vec![coinbase],
        };
        let block_bytes = block.consensus_encode().expect("encode block");
        let flags = ValidationFlags::default();
        let batch = chainstate
            .connect_block(
                &block,
                height,
                &params,
                &flags,
                true,
                None,
                None,
                Some(block_bytes.as_slice()),
                None,
            )
            .expect("connect block");
        chainstate.commit_batch(batch).expect("commit block");

        (chainstate, params, data_dir, address, coinbase_txid, 0)
    }

    fn mine_regtest_block_to_script(
        chainstate: &ChainState<MemoryStore>,
        params: &fluxd_consensus::params::ChainParams,
        miner_script_pubkey: Vec<u8>,
    ) -> (Hash256, u32, i32, i64) {
        let tip = chainstate
            .best_block()
            .expect("best block")
            .expect("best block present");
        let tip_entry = chainstate
            .header_entry(&tip.hash)
            .expect("header entry")
            .expect("header entry present");
        let height = tip.height + 1;
        let time = tip_entry.time.saturating_add(1);
        let bits = chainstate
            .next_work_required_bits(&tip.hash, height, time as i64, &params.consensus)
            .expect("next bits");

        let miner_value = block_subsidy(height, &params.consensus);
        let exchange_amount = exchange_fund_amount(height, &params.funding);
        let foundation_amount = foundation_fund_amount(height, &params.funding);
        let swap_amount = swap_pool_amount(height as i64, &params.swap_pool);

        let mut vout = Vec::new();
        vout.push(TxOut {
            value: miner_value,
            script_pubkey: miner_script_pubkey,
        });
        if exchange_amount > 0 {
            let script = address_to_script_pubkey(params.funding.exchange_address, params.network)
                .expect("exchange address script");
            vout.push(TxOut {
                value: exchange_amount,
                script_pubkey: script,
            });
        }
        if foundation_amount > 0 {
            let script =
                address_to_script_pubkey(params.funding.foundation_address, params.network)
                    .expect("foundation address script");
            vout.push(TxOut {
                value: foundation_amount,
                script_pubkey: script,
            });
        }
        if swap_amount > 0 {
            let script = address_to_script_pubkey(params.swap_pool.address, params.network)
                .expect("swap pool address script");
            vout.push(TxOut {
                value: swap_amount,
                script_pubkey: script,
            });
        }

        let coinbase = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: vec![TxIn {
                prevout: OutPoint::null(),
                script_sig: Vec::new(),
                sequence: u32::MAX,
            }],
            vout,
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let coinbase_txid = coinbase.txid().expect("coinbase txid");
        let final_sapling_root = chainstate.sapling_root().expect("sapling root");
        let header = BlockHeader {
            version: CURRENT_VERSION,
            prev_block: tip.hash,
            merkle_root: coinbase_txid,
            final_sapling_root,
            time,
            bits,
            nonce: [0u8; 32],
            solution: Vec::new(),
            nodes_collateral: OutPoint::null(),
            block_sig: Vec::new(),
        };

        let mut header_batch = WriteBatch::new();
        chainstate
            .insert_headers_batch_with_pow(
                &[header.clone()],
                &params.consensus,
                &mut header_batch,
                false,
            )
            .expect("insert header");
        chainstate
            .commit_batch(header_batch)
            .expect("commit header");

        let block = Block {
            header,
            transactions: vec![coinbase],
        };
        let block_bytes = block.consensus_encode().expect("encode block");
        let flags = ValidationFlags::default();
        let batch = chainstate
            .connect_block(
                &block,
                height,
                params,
                &flags,
                true,
                None,
                None,
                Some(block_bytes.as_slice()),
                None,
            )
            .expect("connect block");
        chainstate.commit_batch(batch).expect("commit block");

        (coinbase_txid, 0, height, miner_value)
    }

    fn add_fluxnode_record_to_batch(
        batch: &mut WriteBatch,
        outpoint: OutPoint,
        tier: u8,
        start_height: u32,
        confirmed_height: u32,
        operator_pubkey: Vec<u8>,
        collateral_pubkey: Vec<u8>,
        collateral_value: i64,
    ) -> FluxnodeRecord {
        let operator_pubkey_key = dedupe_key(&operator_pubkey);
        let collateral_pubkey_key = dedupe_key(&collateral_pubkey);

        batch.put(Column::FluxnodeKey, &operator_pubkey_key.0, operator_pubkey);
        batch.put(
            Column::FluxnodeKey,
            &collateral_pubkey_key.0,
            collateral_pubkey,
        );

        let record = FluxnodeRecord {
            collateral: outpoint.clone(),
            tier,
            start_height,
            confirmed_height,
            last_confirmed_height: start_height,
            last_paid_height: 0,
            collateral_value,
            operator_pubkey: operator_pubkey_key,
            collateral_pubkey: Some(collateral_pubkey_key),
            p2sh_script: None,
            delegates: None,
            ip: String::new(),
        };
        let key = fluxd_chainstate::utxo::outpoint_key_bytes(&outpoint);
        batch.put(Column::Fluxnode, key.as_bytes(), record.encode());
        record
    }

    #[test]
    fn parse_amount_accepts_basic_inputs() {
        assert_eq!(parse_amount(&json!(0)).unwrap(), 0);
        assert_eq!(parse_amount(&json!(1)).unwrap(), COIN);
        assert_eq!(parse_amount(&json!("1")).unwrap(), COIN);
        assert_eq!(parse_amount(&json!("1.00000001")).unwrap(), COIN + 1);
        assert_eq!(parse_amount(&json!("0.1")).unwrap(), COIN / 10);
        assert_eq!(parse_amount(&json!(".1")).unwrap(), COIN / 10);
        assert_eq!(parse_amount(&json!("1.")).unwrap(), COIN);
    }

    #[test]
    fn parse_amount_rejects_invalid_inputs() {
        assert!(parse_amount(&json!(-1)).is_err());
        assert!(parse_amount(&json!("-1")).is_err());
        assert!(parse_amount(&json!("1.000000001")).is_err());
        assert!(parse_amount(&json!("foo")).is_err());
        assert!(parse_amount(&json!("1e-8")).is_err());
        assert!(parse_amount(&json!("")).is_err());
    }

    #[test]
    fn rpc_allowlist_defaults_to_localhost_only() {
        let list = RpcAllowList::from_allow_ips(&[]).expect("allowlist");
        assert!(list.allows(IpAddr::V4(std::net::Ipv4Addr::LOCALHOST)));
        assert!(list.allows(IpAddr::V6(std::net::Ipv6Addr::LOCALHOST)));
        assert!(!list.allows(IpAddr::V4(std::net::Ipv4Addr::new(8, 8, 8, 8))));
    }

    #[test]
    fn rpc_allowlist_parses_ipv4_cidr_ranges() {
        let list = RpcAllowList::from_allow_ips(&["10.0.0.0/8".to_string()]).expect("allowlist");
        assert!(list.allows(IpAddr::V4(std::net::Ipv4Addr::new(10, 1, 2, 3))));
        assert!(!list.allows(IpAddr::V4(std::net::Ipv4Addr::new(11, 0, 0, 1))));
    }

    #[test]
    fn rpc_allowlist_parses_allow_all_ipv4() {
        let list = RpcAllowList::from_allow_ips(&["0.0.0.0/0".to_string()]).expect("allowlist");
        assert!(list.allows(IpAddr::V4(std::net::Ipv4Addr::new(1, 2, 3, 4))));
    }

    #[test]
    fn rpc_allowlist_rejects_invalid_entries() {
        let err = RpcAllowList::from_allow_ips(&["10.0.0.0/33".to_string()]).unwrap_err();
        assert!(err.contains("invalid rpcallowip"));
    }

    #[test]
    fn getblockchaininfo_has_cpp_schema_keys() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let value =
            rpc_getblockchaininfo(&chainstate, Vec::new(), &params, &data_dir).expect("rpc");
        let obj = value.as_object().expect("object");

        let chain = obj.get("chain").and_then(Value::as_str).unwrap_or("");
        assert_eq!(chain, "regtest");

        for key in [
            "blocks",
            "headers",
            "bestblockhash",
            "difficulty",
            "verificationprogress",
            "chainwork",
            "pruned",
            "size_on_disk",
            "commitments",
            "softforks",
            "valuePools",
            "upgrades",
            "consensus",
        ] {
            assert!(obj.contains_key(key), "missing key {key}");
        }

        assert!(obj.get("bestblockhash").and_then(Value::as_str).is_some());
        let best_block = obj.get("bestblockhash").and_then(Value::as_str).unwrap();
        assert!(is_hex_64(best_block));
        assert!(obj.get("softforks").and_then(Value::as_array).is_some());
        assert!(obj.get("commitments").and_then(Value::as_u64).is_some());
    }

    #[test]
    fn gettxoutsetinfo_has_cpp_schema_keys() {
        let (chainstate, _params, data_dir) = setup_regtest_chainstate();
        let value = rpc_gettxoutsetinfo(&chainstate, Vec::new(), &data_dir).expect("rpc");
        let obj = value.as_object().expect("object");
 
        for key in [
            "height",
            "bestblock",
            "transactions",
            "txouts",
            "bytes_serialized",
            "hash_serialized",
            "total_amount",
        ] {
            assert!(obj.contains_key(key), "missing key {key}");
        }
 
        let index_stats = rpc_getindexstats(&chainstate, Vec::new()).expect("rpc");
        let index_obj = index_stats.as_object().expect("object");
        for key in ["spent_index_entries", "address_outpoint_entries"] {
            assert!(index_obj.contains_key(key), "missing key {key}");
        }
    }
 
    #[test]
    fn getindexstats_counts_match_db_scans() {
        let (chainstate, _params, _data_dir, _address, coinbase_txid, vout) =
            setup_regtest_chain_with_p2pkh_utxo();
 
        let outpoint = OutPoint {
            hash: coinbase_txid,
            index: vout,
        };
        assert!(chainstate.spent_info(&outpoint).expect("spent info").is_none());
 
        let stats = rpc_getindexstats(&chainstate, Vec::new()).expect("rpc");
        let obj = stats.as_object().expect("object");
        let spent = obj
            .get("spent_index_entries")
            .and_then(Value::as_u64)
            .expect("spent_index_entries");
        let address = obj
            .get("address_outpoint_entries")
            .and_then(Value::as_u64)
            .expect("address_outpoint_entries");
 
        let computed = chainstate.refresh_index_stats().expect("refresh index stats");
        assert_eq!(spent, computed.spent_index_entries);
        assert_eq!(address, computed.address_outpoint_entries);
    }


    #[test]
    fn txoutproof_roundtrip_returns_txids() {
        let (chainstate, _params, _data_dir, _address, txid, _vout) =
            setup_regtest_chain_with_p2pkh_utxo();

        let proof = rpc_gettxoutproof(
            &chainstate,
            vec![Value::Array(vec![Value::String(hash256_to_hex(&txid))])],
        )
        .expect("rpc");
        let proof_hex = proof.as_str().expect("hex string").to_string();
        assert!(bytes_from_hex(&proof_hex).is_some(), "proof should be hex");

        let matches =
            rpc_verifytxoutproof(&chainstate, vec![Value::String(proof_hex)]).expect("rpc");
        let txids = matches.as_array().expect("array");
        assert_eq!(txids.len(), 1);
        assert_eq!(txids[0].as_str(), Some(hash256_to_hex(&txid).as_str()));
    }

    #[test]
    fn getinfo_has_cpp_schema_keys() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let mempool = Mutex::new(Mempool::new(0));
        let wallet =
            Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("create wallet"));
        let net_totals = NetTotals::default();
        let peer_registry = PeerRegistry::default();
        let mempool_policy = MempoolPolicy::standard(0, false);

        let value = rpc_getinfo(
            &chainstate,
            &mempool,
            &wallet,
            Vec::new(),
            &params,
            &data_dir,
            &net_totals,
            &peer_registry,
            &mempool_policy,
        )
        .expect("rpc");
        let obj = value.as_object().expect("object");

        for key in [
            "version",
            "protocolversion",
            "walletversion",
            "balance",
            "blocks",
            "timeoffset",
            "connections",
            "proxy",
            "difficulty",
            "testnet",
            "keypoololdest",
            "keypoolsize",
            "paytxfee",
            "relayfee",
            "errors",
        ] {
            assert!(obj.contains_key(key), "missing key {key}");
        }

        assert!(obj.get("version").and_then(Value::as_i64).is_some());
        assert!(obj.get("protocolversion").and_then(Value::as_i64).is_some());
        assert!(obj.get("walletversion").and_then(Value::as_i64).is_some());
        assert!(obj.get("balance").and_then(Value::as_f64).is_some());
        assert!(obj.get("blocks").and_then(Value::as_i64).is_some());
        assert!(obj.get("connections").and_then(Value::as_i64).is_some());
    }

    #[test]
    fn getnetworkinfo_has_cpp_schema_keys() {
        let net_totals = NetTotals::default();
        let peer_registry = PeerRegistry::default();
        let mempool_policy = MempoolPolicy::standard(0, false);

        let value = rpc_getnetworkinfo(Vec::new(), &peer_registry, &net_totals, &mempool_policy)
            .expect("rpc");
        let obj = value.as_object().expect("object");

        for key in [
            "version",
            "subversion",
            "protocolversion",
            "localservices",
            "timeoffset",
            "connections",
            "networks",
            "relayfee",
            "localaddresses",
            "warnings",
        ] {
            assert!(obj.contains_key(key), "missing key {key}");
        }

        let networks = obj
            .get("networks")
            .and_then(Value::as_array)
            .expect("networks array");
        assert!(!networks.is_empty(), "networks should not be empty");
        let network = networks[0].as_object().expect("network object");
        for key in ["name", "limited", "reachable", "proxy"] {
            assert!(network.contains_key(key), "missing networks key {key}");
        }
    }

    #[test]
    fn getnettotals_has_cpp_schema_keys() {
        let net_totals = NetTotals::default();
        let value = rpc_getnettotals(Vec::new(), &net_totals).expect("rpc");
        let obj = value.as_object().expect("object");
        for key in ["totalbytesrecv", "totalbytessent", "timemillis"] {
            assert!(obj.contains_key(key), "missing key {key}");
        }
    }

    #[test]
    fn getpeerinfo_has_cpp_schema_keys() {
        let peer_registry = PeerRegistry::default();
        let addr: std::net::SocketAddr = "127.0.0.1:12345".parse().expect("addr");
        let id = peer_registry.register(addr, PeerKind::Header);
        peer_registry.update_version(id, 170020, 0x5, "/MagicBean:9.0.6/".to_string(), 123);

        let value = rpc_getpeerinfo(Vec::new(), &peer_registry).expect("rpc");
        let peers = value.as_array().expect("array");
        assert_eq!(peers.len(), 1);
        let obj = peers[0].as_object().expect("object");
        for key in [
            "addr",
            "subver",
            "version",
            "services",
            "servicesnames",
            "startingheight",
            "conntime",
            "lastsend",
            "lastrecv",
            "bytessent",
            "bytesrecv",
            "inbound",
            "kind",
        ] {
            assert!(obj.contains_key(key), "missing key {key}");
        }
    }

    #[test]
    fn getdbinfo_has_cpp_schema_keys() {
        let (chainstate, _params, data_dir, store) = setup_regtest_chainstate_store();
        let value = rpc_getdbinfo(&chainstate, store.as_ref(), Vec::new(), &data_dir).expect("rpc");
        let obj = value.as_object().expect("object");
        for key in [
            "backend",
            "paths",
            "chain",
            "supply",
            "sizes",
            "flatfiles_meta",
            "flatfiles_fs",
            "db_partitions",
            "files",
            "fjall",
        ] {
            assert!(obj.contains_key(key), "missing key {key}");
        }
    }

    #[test]
    fn getconnectioncount_has_cpp_schema() {
        let net_totals = NetTotals::default();
        let peer_registry = PeerRegistry::default();
        let addr: std::net::SocketAddr = "127.0.0.1:12345".parse().expect("addr");
        peer_registry.register(addr, PeerKind::Header);
        let value = rpc_getconnectioncount(Vec::new(), &peer_registry, &net_totals).expect("rpc");
        assert_eq!(value.as_i64(), Some(1));
    }

    #[test]
    fn getdeprecationinfo_has_cpp_schema_keys() {
        let value = rpc_getdeprecationinfo(Vec::new()).expect("rpc");
        let obj = value.as_object().expect("object");
        for key in ["deprecated", "version", "subversion", "warnings"] {
            assert!(obj.contains_key(key), "missing key {key}");
        }
    }

    #[test]
    fn listbanned_has_cpp_schema_keys() {
        let book = HeaderPeerBook::default();
        let addr: std::net::SocketAddr = "127.0.0.1:12345".parse().expect("addr");
        book.ban_for(addr, 60);

        let value = rpc_listbanned(Vec::new(), &book).expect("rpc");
        let entries = value.as_array().expect("array");
        assert_eq!(entries.len(), 1);
        let obj = entries[0].as_object().expect("object");
        for key in ["address", "banned_until"] {
            assert!(obj.contains_key(key), "missing key {key}");
        }
    }

    #[test]
    fn addnode_and_getaddednodeinfo_have_cpp_schema_keys() {
        let (_chainstate, params, _data_dir) = setup_regtest_chainstate();

        let addr_book = AddrBook::default();
        let added_nodes = Mutex::new(HashSet::<String>::new());

        rpc_addnode(
            vec![
                Value::String("127.0.0.1:16125".to_string()),
                Value::String("add".to_string()),
            ],
            &params,
            &addr_book,
            &added_nodes,
        )
        .expect("addnode");

        let peer_registry = PeerRegistry::default();
        let addr: std::net::SocketAddr = "127.0.0.1:16125".parse().expect("addr");
        peer_registry.register(addr, PeerKind::Header);

        let value = rpc_getaddednodeinfo(
            vec![Value::Bool(false)],
            &params,
            &peer_registry,
            &added_nodes,
        )
        .expect("getaddednodeinfo");
        let list = value.as_array().expect("array");
        assert_eq!(list.len(), 1);
        let obj = list[0].as_object().expect("object");
        assert!(obj.contains_key("addednode"), "missing key addednode");
        assert!(!obj.contains_key("connected"), "unexpected connected key");
        assert!(!obj.contains_key("addresses"), "unexpected addresses key");

        let value = rpc_getaddednodeinfo(
            vec![Value::Bool(true)],
            &params,
            &peer_registry,
            &added_nodes,
        )
        .expect("getaddednodeinfo");
        let list = value.as_array().expect("array");
        assert_eq!(list.len(), 1);
        let obj = list[0].as_object().expect("object");
        for key in ["addednode", "connected", "addresses"] {
            assert!(obj.contains_key(key), "missing key {key}");
        }
        assert_eq!(obj.get("connected").and_then(Value::as_bool), Some(true));
        let addresses = obj
            .get("addresses")
            .and_then(Value::as_array)
            .expect("addresses array");
        assert_eq!(addresses.len(), 1);
        let entry = addresses[0].as_object().expect("address entry");
        assert_eq!(
            entry.get("address").and_then(Value::as_str),
            Some("127.0.0.1:16125")
        );
        assert_eq!(
            entry.get("connected").and_then(Value::as_str),
            Some("outbound")
        );
    }

    #[test]
    fn disconnectnode_has_cpp_schema() {
        let (_chainstate, params, _data_dir) = setup_regtest_chainstate();
        let peer_registry = PeerRegistry::default();
        peer_registry.register("127.0.0.1:12345".parse().expect("addr"), PeerKind::Header);
        let value = rpc_disconnectnode(
            vec![Value::String("127.0.0.1:12345".to_string())],
            &params,
            &peer_registry,
        )
        .expect("disconnectnode");
        assert!(value.is_null());
    }

    #[test]
    fn disconnectnode_errors_when_not_connected() {
        let (_chainstate, params, _data_dir) = setup_regtest_chainstate();
        let peer_registry = PeerRegistry::default();
        let err = rpc_disconnectnode(
            vec![Value::String("127.0.0.1:12345".to_string())],
            &params,
            &peer_registry,
        )
        .expect_err("disconnectnode should fail");
        assert_eq!(err.code, RPC_CLIENT_NODE_NOT_CONNECTED);
    }

    #[test]
    fn addnode_errors_on_duplicates_and_missing_removes() {
        let (_chainstate, params, _data_dir) = setup_regtest_chainstate();
        let addr_book = AddrBook::default();
        let added_nodes = Mutex::new(HashSet::<String>::new());

        rpc_addnode(
            vec![
                Value::String("127.0.0.1:16125".to_string()),
                Value::String("add".to_string()),
            ],
            &params,
            &addr_book,
            &added_nodes,
        )
        .expect("addnode");

        let err = rpc_addnode(
            vec![
                Value::String("127.0.0.1:16125".to_string()),
                Value::String("add".to_string()),
            ],
            &params,
            &addr_book,
            &added_nodes,
        )
        .expect_err("duplicate addnode should fail");
        assert_eq!(err.code, RPC_CLIENT_NODE_ALREADY_ADDED);

        let err = rpc_addnode(
            vec![
                Value::String("127.0.0.1:16126".to_string()),
                Value::String("remove".to_string()),
            ],
            &params,
            &addr_book,
            &added_nodes,
        )
        .expect_err("remove missing addnode should fail");
        assert_eq!(err.code, RPC_CLIENT_NODE_NOT_ADDED);
    }

    #[test]
    fn setban_and_clearbanned_have_cpp_schema() {
        let (_chainstate, params, _data_dir) = setup_regtest_chainstate();
        let peer_registry = PeerRegistry::default();
        let book = HeaderPeerBook::default();

        rpc_setban(
            vec![
                Value::String("127.0.0.1".to_string()),
                Value::String("add".to_string()),
                json!(60),
            ],
            &params,
            &peer_registry,
            &book,
        )
        .expect("setban");

        let banned = rpc_listbanned(Vec::new(), &book).expect("listbanned");
        let banned = banned.as_array().expect("array");
        assert_eq!(banned.len(), 1);

        rpc_clearbanned(Vec::new(), &book).expect("clearbanned");
        let banned = rpc_listbanned(Vec::new(), &book).expect("listbanned");
        let banned = banned.as_array().expect("array");
        assert!(banned.is_empty());
    }

    #[test]
    fn getblockcount_has_cpp_schema() {
        let (chainstate, _params, _data_dir) = setup_regtest_chainstate();
        let value = rpc_getblockcount(&chainstate, Vec::new()).expect("rpc");
        assert!(value.as_i64().is_some());
    }

    #[test]
    fn getbestblockhash_has_cpp_schema() {
        let (chainstate, _params, _data_dir) = setup_regtest_chainstate();
        let value = rpc_getbestblockhash(&chainstate, Vec::new()).expect("rpc");
        let hash = value.as_str().expect("hash string");
        assert!(is_hex_64(hash));
    }

    #[test]
    fn getblockhash_has_cpp_schema() {
        let (chainstate, _params, _data_dir) = setup_regtest_chainstate();
        let best = rpc_getbestblockhash(&chainstate, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("hash")
            .to_string();
        let value = rpc_getblockhash(&chainstate, vec![json!(0)]).expect("rpc");
        assert_eq!(value.as_str().unwrap(), best);
    }

    #[test]
    fn getdifficulty_has_cpp_schema() {
        let (chainstate, params, _data_dir) = setup_regtest_chainstate();
        let value = rpc_getdifficulty(&chainstate, Vec::new(), &params).expect("rpc");
        assert!(value.as_f64().is_some());
    }

    #[test]
    fn getchaintips_has_cpp_schema_keys() {
        let (chainstate, _params, _data_dir) = setup_regtest_chainstate();
        let value = rpc_getchaintips(&chainstate, Vec::new()).expect("rpc");
        let tips = value.as_array().expect("array");
        assert!(!tips.is_empty());
        let tip = tips[0].as_object().expect("object");
        for key in ["height", "hash", "branchlen", "status"] {
            assert!(tip.contains_key(key), "missing key {key}");
        }
    }

    #[test]
    fn getchaintips_accepts_blockheight_param() {
        let (chainstate, _params, _data_dir) = setup_regtest_chainstate();
        let value = rpc_getchaintips(&chainstate, vec![json!(9999)]).expect("rpc");
        let tips = value.as_array().expect("array");
        assert!(!tips.is_empty());
    }

    #[test]
    fn getchaintips_reports_valid_headers_and_invalid_statuses() {
        let (chainstate, params, _data_dir) = setup_regtest_chainstate();

        let genesis = params.consensus.hash_genesis_block;
        let genesis_entry = chainstate
            .header_entry(&genesis)
            .expect("header entry")
            .expect("genesis header entry");

        let height = 1;
        let spacing = params.consensus.pow_target_spacing.max(1) as u32;
        let time = genesis_entry.time.saturating_add(spacing);
        let bits = chainstate
            .next_work_required_bits(&genesis, height, time as i64, &params.consensus)
            .expect("next bits");

        let header = BlockHeader {
            version: CURRENT_VERSION,
            prev_block: genesis,
            merkle_root: [0x22u8; 32],
            final_sapling_root: chainstate.sapling_root().expect("sapling root"),
            time,
            bits,
            nonce: [0u8; 32],
            solution: Vec::new(),
            nodes_collateral: OutPoint::null(),
            block_sig: Vec::new(),
        };
        let hash = header.hash();

        let mut header_batch = WriteBatch::new();
        chainstate
            .insert_headers_batch_with_pow(&[header], &params.consensus, &mut header_batch, false)
            .expect("insert header");
        chainstate
            .commit_batch(header_batch)
            .expect("commit header");

        let mut batch = WriteBatch::new();
        chainstate.store_unconnected_block_bytes(&mut batch, &hash, &[1u8]);
        chainstate.commit_batch(batch).expect("commit unconnected");

        let value = rpc_getchaintips(&chainstate, Vec::new()).expect("rpc");
        let tips = value.as_array().expect("array");
        let statuses: Vec<_> = tips
            .iter()
            .filter_map(|entry| entry.as_object())
            .filter(|entry| entry.get("height").and_then(Value::as_i64) == Some(1))
            .filter_map(|entry| entry.get("status").and_then(Value::as_str))
            .collect();
        assert!(statuses.contains(&"valid-headers"));

        let mut fail_batch = WriteBatch::new();
        chainstate
            .mark_header_failed(&mut fail_batch, &hash)
            .expect("mark failed");
        chainstate.commit_batch(fail_batch).expect("commit failed");

        let value = rpc_getchaintips(&chainstate, Vec::new()).expect("rpc");
        let tips = value.as_array().expect("array");
        let statuses: Vec<_> = tips
            .iter()
            .filter_map(|entry| entry.as_object())
            .filter(|entry| entry.get("height").and_then(Value::as_i64) == Some(1))
            .filter_map(|entry| entry.get("status").and_then(Value::as_str))
            .collect();
        assert!(statuses.contains(&"invalid"));
    }

    #[test]
    fn getblockheader_has_cpp_schema_keys() {
        let (chainstate, params, _data_dir) = setup_regtest_chainstate();
        let best = chainstate
            .best_block()
            .expect("best block")
            .expect("best block present");
        let hash_hex = hash256_to_hex(&best.hash);
        let value = rpc_getblockheader(&chainstate, vec![Value::String(hash_hex.clone())], &params)
            .expect("rpc");
        let obj = value.as_object().expect("object");
        for key in [
            "hash",
            "confirmations",
            "height",
            "version",
            "merkleroot",
            "finalsaplingroot",
            "time",
            "bits",
            "difficulty",
            "chainwork",
        ] {
            assert!(obj.contains_key(key), "missing key {key}");
        }
        assert_eq!(obj.get("hash").and_then(Value::as_str).unwrap(), hash_hex);
    }

    #[test]
    fn getblock_has_cpp_schema_keys() {
        let (chainstate, params, _data_dir) = setup_regtest_chainstate();
        let best = chainstate
            .best_block()
            .expect("best block")
            .expect("best block present");
        let value = rpc_getblock(&chainstate, vec![json!(best.height)], &params).expect("rpc");
        let obj = value.as_object().expect("object");
        for key in [
            "hash",
            "confirmations",
            "size",
            "height",
            "version",
            "merkleroot",
            "finalsaplingroot",
            "tx",
            "time",
            "bits",
            "difficulty",
            "chainwork",
        ] {
            assert!(obj.contains_key(key), "missing key {key}");
        }
        assert!(obj.get("tx").and_then(Value::as_array).is_some());
    }

    #[test]
    fn getmempoolinfo_has_cpp_schema_keys() {
        let mempool = Mutex::new(Mempool::new(0));
        let value = rpc_getmempoolinfo(Vec::new(), &mempool).expect("rpc");
        let obj = value.as_object().expect("object");
        for key in ["size", "bytes", "usage"] {
            assert!(obj.contains_key(key), "missing key {key}");
        }
    }

    #[test]
    fn getrawmempool_has_cpp_schema() {
        let (chainstate, _params, _data_dir) = setup_regtest_chainstate();
        let mempool = Mutex::new(Mempool::new(0));
        let value = rpc_getrawmempool(&chainstate, Vec::new(), &mempool).expect("rpc");
        let txids = value.as_array().expect("array");
        assert!(txids.is_empty());
    }

    #[test]
    fn getrawmempool_verbose_has_cpp_schema() {
        let (chainstate, _params, _data_dir) = setup_regtest_chainstate();
        let mempool = Mutex::new(Mempool::new(0));
        let value = rpc_getrawmempool(&chainstate, vec![json!(true)], &mempool).expect("rpc");
        assert!(value.as_object().is_some());
    }

    #[test]
    fn getrawmempool_verbose_includes_depends() {
        let (chainstate, _params, _data_dir) = setup_regtest_chainstate();
        let script_pubkey = p2pkh_script([0x22u8; 20]);

        let parent_tx = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: vec![TxIn {
                prevout: OutPoint {
                    hash: [0x33u8; 32],
                    index: 0,
                },
                script_sig: Vec::new(),
                sequence: 0,
            }],
            vout: vec![TxOut {
                value: 123,
                script_pubkey: script_pubkey.clone(),
            }],
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let parent_txid = parent_tx.txid().expect("txid");
        let parent_raw = parent_tx.consensus_encode().expect("encode tx");

        let child_tx = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: vec![TxIn {
                prevout: OutPoint {
                    hash: parent_txid,
                    index: 0,
                },
                script_sig: Vec::new(),
                sequence: 0,
            }],
            vout: vec![TxOut {
                value: 123,
                script_pubkey,
            }],
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let child_txid = child_tx.txid().expect("txid");
        let child_raw = child_tx.consensus_encode().expect("encode tx");

        let mut inner = Mempool::new(0);
        inner
            .insert(MempoolEntry {
                txid: parent_txid,
                tx: parent_tx,
                raw: parent_raw,
                time: 0,
                height: 0,
                fee: 0,
                value_in: 0,
                modified_size: 0,
                priority: 0.0,
                was_clear_at_entry: true,
                fee_delta: 0,
                priority_delta: 0.0,
                spent_outpoints: Vec::new(),
                parents: Vec::new(),
            })
            .expect("insert parent");
        inner
            .insert(MempoolEntry {
                txid: child_txid,
                tx: child_tx,
                raw: child_raw,
                time: 0,
                height: 0,
                fee: 0,
                value_in: 0,
                modified_size: 0,
                priority: 0.0,
                was_clear_at_entry: false,
                fee_delta: 0,
                priority_delta: 0.0,
                spent_outpoints: Vec::new(),
                parents: vec![parent_txid],
            })
            .expect("insert child");
        let mempool = Mutex::new(inner);

        let value = rpc_getrawmempool(&chainstate, vec![json!(true)], &mempool).expect("rpc");
        let obj = value.as_object().expect("object");
        let child = obj
            .get(&hash256_to_hex(&child_txid))
            .and_then(Value::as_object)
            .expect("child object");
        let depends = child
            .get("depends")
            .and_then(Value::as_array)
            .expect("depends array");
        assert_eq!(
            depends
                .iter()
                .filter_map(Value::as_str)
                .map(str::to_string)
                .collect::<Vec<_>>(),
            vec![hash256_to_hex(&parent_txid)]
        );
    }

    #[test]
    fn gettxout_has_cpp_schema_keys() {
        let (chainstate, params, _data_dir, _address, txid, vout) =
            setup_regtest_chain_with_p2pkh_utxo();
        let mempool = Mutex::new(Mempool::new(0));
        let value = rpc_gettxout(
            &chainstate,
            &mempool,
            vec![Value::String(hash256_to_hex(&txid)), json!(vout)],
            &params,
        )
        .expect("rpc");
        let obj = value.as_object().expect("object");
        for key in [
            "bestblock",
            "confirmations",
            "value",
            "scriptPubKey",
            "version",
            "coinbase",
        ] {
            assert!(obj.contains_key(key), "missing key {key}");
        }
        let bestblock = obj.get("bestblock").and_then(Value::as_str).unwrap();
        assert!(is_hex_64(bestblock));
    }

    #[test]
    fn gettxout_can_serve_mempool_outputs() {
        let (chainstate, params, _data_dir) = setup_regtest_chainstate();

        let script_pubkey = p2pkh_script([0x22u8; 20]);
        let tx = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: vec![TxIn {
                prevout: OutPoint {
                    hash: [0x33u8; 32],
                    index: 0,
                },
                script_sig: Vec::new(),
                sequence: 0,
            }],
            vout: vec![TxOut {
                value: 123,
                script_pubkey,
            }],
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let txid = tx.txid().expect("txid");
        let raw = tx.consensus_encode().expect("encode tx");

        let entry = MempoolEntry {
            txid,
            tx,
            raw,
            time: 0,
            height: 0,
            fee: 0,
            value_in: 0,
            modified_size: 0,
            priority: 0.0,
            was_clear_at_entry: true,
            fee_delta: 0,
            priority_delta: 0.0,
            spent_outpoints: Vec::new(),
            parents: Vec::new(),
        };
        let mut inner = Mempool::new(0);
        inner.insert(entry).expect("insert mempool tx");
        let mempool = Mutex::new(inner);

        let value = rpc_gettxout(
            &chainstate,
            &mempool,
            vec![Value::String(hash256_to_hex(&txid)), json!(0)],
            &params,
        )
        .expect("rpc");
        let obj = value.as_object().expect("object");
        assert_eq!(obj.get("confirmations").and_then(Value::as_i64), Some(0));
        assert_eq!(obj.get("coinbase").and_then(Value::as_bool), Some(false));
        assert_eq!(obj.get("version").and_then(Value::as_i64), Some(1));
    }

    #[test]
    fn getspentinfo_has_cpp_schema_keys() {
        let (chainstate, _params, _data_dir, _address, txid, vout) =
            setup_regtest_chain_with_p2pkh_utxo();

        let outpoint = OutPoint {
            hash: txid,
            index: vout,
        };
        let key = fluxd_chainstate::utxo::outpoint_key_bytes(&outpoint);
        let spent = fluxd_chainstate::spentindex::SpentIndexValue {
            txid: [0x44u8; 32],
            input_index: 7,
            block_height: 123,
            details: None,
        };
        let mut batch = WriteBatch::new();
        batch.put(Column::SpentIndex, key.as_bytes(), spent.encode());
        chainstate.commit_batch(batch).expect("insert spent index");

        let object_form = rpc_getspentinfo(
            &chainstate,
            vec![json!({"txid": hash256_to_hex(&txid), "index": vout })],
        )
        .expect("rpc");
        let obj = object_form.as_object().expect("object");
        for key in ["txid", "index", "height"] {
            assert!(obj.contains_key(key), "missing key {key}");
        }

        let positional = rpc_getspentinfo(
            &chainstate,
            vec![Value::String(hash256_to_hex(&txid)), json!(vout)],
        )
        .expect("rpc");
        assert_eq!(positional, object_form);

        let not_found =
            rpc_getspentinfo(&chainstate, vec![Value::String("00".repeat(32)), json!(0)])
                .unwrap_err();
        assert_eq!(not_found.code, RPC_INVALID_ADDRESS_OR_KEY);
    }

    #[test]
    fn getaddressutxos_has_cpp_schema_keys() {
        let (chainstate, params, _data_dir, address, _txid, _vout) =
            setup_regtest_chain_with_p2pkh_utxo();
        let value = rpc_getaddressutxos(&chainstate, vec![Value::String(address.clone())], &params)
            .expect("rpc");
        let utxos = value.as_array().expect("array");
        assert!(!utxos.is_empty());
        let first = utxos[0].as_object().expect("object");
        for key in [
            "address",
            "txid",
            "outputIndex",
            "script",
            "satoshis",
            "height",
        ] {
            assert!(first.contains_key(key), "missing key {key}");
        }
    }

    #[test]
    fn getaddressutxos_chaininfo_has_cpp_schema_keys() {
        let (chainstate, params, _data_dir, address, _txid, _vout) =
            setup_regtest_chain_with_p2pkh_utxo();
        let value = rpc_getaddressutxos(
            &chainstate,
            vec![json!({"addresses": [address], "chainInfo": true })],
            &params,
        )
        .expect("rpc");
        let obj = value.as_object().expect("object");
        for key in ["utxos", "hash", "height"] {
            assert!(obj.contains_key(key), "missing key {key}");
        }
    }

    #[test]
    fn getaddressbalance_has_cpp_schema_keys() {
        let (chainstate, params, _data_dir, address, _txid, _vout) =
            setup_regtest_chain_with_p2pkh_utxo();
        let value =
            rpc_getaddressbalance(&chainstate, vec![Value::String(address)], &params).expect("rpc");
        let obj = value.as_object().expect("object");
        for key in ["balance", "received"] {
            assert!(obj.contains_key(key), "missing key {key}");
        }
    }

    #[test]
    fn getaddressdeltas_has_cpp_schema_keys() {
        let (chainstate, params, _data_dir, address, _txid, _vout) =
            setup_regtest_chain_with_p2pkh_utxo();
        let value =
            rpc_getaddressdeltas(&chainstate, vec![Value::String(address)], &params).expect("rpc");
        let deltas = value.as_array().expect("array");
        assert!(!deltas.is_empty());
        let first = deltas[0].as_object().expect("object");
        for key in [
            "address",
            "blockindex",
            "height",
            "index",
            "satoshis",
            "txid",
        ] {
            assert!(first.contains_key(key), "missing key {key}");
        }
    }

    #[test]
    fn getaddresstxids_has_cpp_schema() {
        let (chainstate, params, _data_dir, address, txid, _vout) =
            setup_regtest_chain_with_p2pkh_utxo();
        let value =
            rpc_getaddresstxids(&chainstate, vec![Value::String(address)], &params).expect("rpc");
        let txids = value.as_array().expect("array");
        let expected = hash256_to_hex(&txid);
        assert_eq!(
            txids.get(0).and_then(Value::as_str),
            Some(expected.as_str())
        );
    }

    #[test]
    fn getaddressmempool_has_cpp_schema() {
        let (chainstate, params, _data_dir, address, _txid, _vout) =
            setup_regtest_chain_with_p2pkh_utxo();
        let mempool = Mutex::new(Mempool::new(0));
        let value =
            rpc_getaddressmempool(&chainstate, &mempool, vec![Value::String(address)], &params)
                .expect("rpc");
        assert!(value.as_array().expect("array").is_empty());
    }

    #[test]
    fn getblocksubsidy_has_cpp_schema_keys() {
        let (chainstate, params, _data_dir) = setup_regtest_chainstate();
        let value = rpc_getblocksubsidy(&chainstate, Vec::new(), &params).expect("rpc");
        let obj = value.as_object().expect("object");
        assert!(obj.contains_key("miner"));
    }

    #[test]
    fn getblockhashes_has_cpp_schema() {
        let (chainstate, _params, _data_dir) = setup_regtest_chainstate();
        let value = rpc_getblockhashes(&chainstate, vec![json!(u32::MAX), json!(0)]).expect("rpc");
        let hashes = value.as_array().expect("array");
        assert!(!hashes.is_empty());
        let first = hashes[0].as_str().expect("string");
        assert!(is_hex_64(first));
    }

    #[test]
    fn getblockdeltas_has_cpp_schema_keys() {
        let (chainstate, params, _data_dir, _address, _txid, _vout) =
            setup_regtest_chain_with_p2pkh_utxo();
        let value = rpc_getblockdeltas(&chainstate, vec![json!(1)], &params).expect("rpc");
        let obj = value.as_object().expect("object");
        for key in [
            "hash",
            "confirmations",
            "size",
            "height",
            "version",
            "merkleroot",
            "deltas",
            "time",
            "mediantime",
            "nonce",
            "bits",
            "difficulty",
            "chainwork",
        ] {
            assert!(obj.contains_key(key), "missing key {key}");
        }
        assert!(obj.get("deltas").and_then(Value::as_array).is_some());
    }

    #[test]
    fn estimatefee_has_cpp_schema() {
        let fee_estimator = Mutex::new(FeeEstimator::new(0));
        let value = rpc_estimatefee(vec![json!(1)], &fee_estimator).expect("rpc");
        assert!(value.is_number());
    }

    #[test]
    fn estimatepriority_returns_number() {
        let fee_estimator = Mutex::new(FeeEstimator::new(0));
        let value = rpc_estimatepriority(vec![json!(1)], &fee_estimator).expect("rpc");
        assert_eq!(value.as_f64(), Some(-1.0));
    }

    #[test]
    fn estimatepriority_returns_value_after_observing_blocks() {
        let mut estimator = FeeEstimator::new(0);
        for height in 1u32..=20 {
            let entry = crate::fee_estimator::BlockTxInfo {
                fee: 0,
                size: 250,
                height: height.saturating_sub(1),
                priority: 1000.0,
                was_clear_at_entry: true,
            };
            let entries = vec![entry; 10];
            estimator.process_block(height, &entries, true);
        }

        let fee_estimator = Mutex::new(estimator);
        let value = rpc_estimatepriority(vec![json!(1)], &fee_estimator).expect("rpc");
        let estimate = value.as_f64().unwrap_or(-1.0);
        assert!(estimate > 0.0);
        assert!((estimate - 1000.0).abs() < 0.01);
    }

    #[test]
    fn estimatefee_returns_value_after_observing_blocks() {
        let mut estimator = FeeEstimator::new(0);
        for height in 1u32..=20 {
            let entry = crate::fee_estimator::BlockTxInfo {
                fee: 1000,
                size: 250,
                height: height.saturating_sub(1),
                priority: 0.0,
                was_clear_at_entry: true,
            };
            let entries = vec![entry; 50];
            estimator.process_block(height, &entries, true);
        }

        let fee_estimator = Mutex::new(estimator);
        let value = rpc_estimatefee(vec![json!(1)], &fee_estimator).expect("rpc");
        let estimate = value.as_f64().unwrap_or(-1.0);
        assert!(estimate > 0.0);
    }

    #[test]
    fn prioritisetransaction_applies_fee_delta_to_mempool_entries() {
        let mut inner = Mempool::new(0);
        let txid: Hash256 = [0x11u8; 32];
        inner
            .insert(MempoolEntry {
                txid,
                tx: Transaction {
                    f_overwintered: false,
                    version: 1,
                    version_group_id: 0,
                    vin: Vec::new(),
                    vout: Vec::new(),
                    lock_time: 0,
                    expiry_height: 0,
                    value_balance: 0,
                    shielded_spends: Vec::new(),
                    shielded_outputs: Vec::new(),
                    join_splits: Vec::new(),
                    join_split_pub_key: [0u8; 32],
                    join_split_sig: [0u8; 64],
                    binding_sig: [0u8; 64],
                    fluxnode: None,
                },
                raw: vec![0u8; 10],
                time: 0,
                height: 0,
                fee: 100,
                value_in: 0,
                modified_size: 0,
                priority: 0.0,
                was_clear_at_entry: true,
                fee_delta: 0,
                priority_delta: 0.0,
                spent_outpoints: Vec::new(),
                parents: Vec::new(),
            })
            .expect("insert");
        let mempool = Mutex::new(inner);

        let txid_hex = hash256_to_hex(&txid);
        let value =
            rpc_prioritisetransaction(vec![json!(txid_hex), json!(1000.0), json!(200)], &mempool)
                .expect("rpc");
        assert_eq!(value, Value::Bool(true));

        let guard = mempool.lock().expect("mempool lock");
        let entry = guard.get(&txid).expect("entry");
        assert_eq!(entry.fee, 100);
        assert_eq!(entry.fee_delta, 200);
        assert_eq!(entry.modified_fee(), 300);
        assert_eq!(entry.priority_delta, 1000.0);
    }

    #[test]
    fn getmininginfo_has_cpp_schema_keys() {
        let (chainstate, params, _data_dir) = setup_regtest_chainstate();
        let mempool = Mutex::new(Mempool::new(0));
        let header_metrics = HeaderMetrics::default();
        let value = rpc_getmininginfo(&chainstate, &mempool, Vec::new(), &params, &header_metrics)
            .expect("rpc");
        let obj = value.as_object().expect("object");
        for key in [
            "blocks",
            "currentblocksize",
            "currentblocktx",
            "difficulty",
            "errors",
            "generate",
            "genproclimit",
            "localsolps",
            "networksolps",
            "networkhashps",
            "pooledtx",
            "testnet",
            "chain",
            "ponminter",
        ] {
            assert!(obj.contains_key(key), "missing key {key}");
        }
    }

    #[test]
    fn submitblock_duplicate_returns_duplicate() {
        let (chainstate, params, _data_dir) = setup_regtest_chainstate();
        let genesis_hash = params.consensus.hash_genesis_block;
        let location = chainstate
            .block_location(&genesis_hash)
            .expect("block location")
            .expect("genesis block location");
        let bytes = chainstate.read_block(location).expect("read block");
        let block_hex = hex_bytes(&bytes);

        let write_lock = Mutex::new(());
        let mempool = Mutex::new(Mempool::new(0));
        let fee_estimator = Mutex::new(FeeEstimator::new(0));
        let flags = ValidationFlags::default();
        let value = rpc_submitblock(
            &chainstate,
            &write_lock,
            &mempool,
            &fee_estimator,
            vec![Value::String(block_hex)],
            &params,
            &flags,
        )
        .expect("rpc");
        assert_eq!(value.as_str(), Some("duplicate"));
    }

    #[test]
    fn submitblock_header_present_returns_duplicate() {
        let (chainstate, params, _data_dir) = setup_regtest_chainstate();

        let tip = chainstate
            .best_block()
            .expect("best block")
            .expect("best block present");
        let tip_entry = chainstate
            .header_entry(&tip.hash)
            .expect("header entry")
            .expect("header entry present");
        let height = tip.height + 1;
        let spacing = params.consensus.pow_target_spacing.max(1) as u32;
        let time = tip_entry.time.saturating_add(spacing);
        let bits = chainstate
            .next_work_required_bits(&tip.hash, height, time as i64, &params.consensus)
            .expect("next bits");

        let miner_value = block_subsidy(height, &params.consensus);
        let exchange_amount = exchange_fund_amount(height, &params.funding);
        let foundation_amount = foundation_fund_amount(height, &params.funding);
        let swap_amount = swap_pool_amount(height as i64, &params.swap_pool);

        let mut vout = Vec::new();
        vout.push(TxOut {
            value: miner_value,
            script_pubkey: Vec::new(),
        });
        if exchange_amount > 0 {
            let script = address_to_script_pubkey(params.funding.exchange_address, params.network)
                .expect("exchange address script");
            vout.push(TxOut {
                value: exchange_amount,
                script_pubkey: script,
            });
        }
        if foundation_amount > 0 {
            let script =
                address_to_script_pubkey(params.funding.foundation_address, params.network)
                    .expect("foundation address script");
            vout.push(TxOut {
                value: foundation_amount,
                script_pubkey: script,
            });
        }
        if swap_amount > 0 {
            let script = address_to_script_pubkey(params.swap_pool.address, params.network)
                .expect("swap pool address script");
            vout.push(TxOut {
                value: swap_amount,
                script_pubkey: script,
            });
        }
        let coinbase = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: vec![TxIn {
                prevout: OutPoint::null(),
                script_sig: vec![0u8; 2],
                sequence: u32::MAX,
            }],
            vout,
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };

        let coinbase_txid = coinbase.txid().expect("coinbase txid");
        let final_sapling_root = chainstate.sapling_root().expect("sapling root");
        let header = BlockHeader {
            version: CURRENT_VERSION,
            prev_block: tip.hash,
            merkle_root: coinbase_txid,
            final_sapling_root,
            time,
            bits,
            nonce: [0u8; 32],
            solution: Vec::new(),
            nodes_collateral: OutPoint::null(),
            block_sig: Vec::new(),
        };

        let block = Block {
            header: header.clone(),
            transactions: vec![coinbase],
        };
        let block_hex = hex_bytes(&block.consensus_encode().expect("encode block"));

        let mut header_batch = WriteBatch::new();
        chainstate
            .insert_headers_batch_with_pow(&[header], &params.consensus, &mut header_batch, false)
            .expect("insert header");
        chainstate
            .commit_batch(header_batch)
            .expect("commit header");

        let write_lock = Mutex::new(());
        let mempool = Mutex::new(Mempool::new(0));
        let fee_estimator = Mutex::new(FeeEstimator::new(0));
        let flags = ValidationFlags::default();
        let value = rpc_submitblock(
            &chainstate,
            &write_lock,
            &mempool,
            &fee_estimator,
            vec![Value::String(block_hex)],
            &params,
            &flags,
        )
        .expect("rpc");
        assert_eq!(value.as_str(), Some("duplicate"));

        let best_after = chainstate
            .best_block()
            .expect("best block")
            .expect("best block present");
        assert_eq!(best_after.height, 1);
    }

    #[test]
    fn submitblock_invalid_header_returns_reason_string() {
        let (chainstate, params, _data_dir) = setup_regtest_chainstate();

        let tip = chainstate
            .best_block()
            .expect("best block")
            .expect("best block present");
        let tip_entry = chainstate
            .header_entry(&tip.hash)
            .expect("header entry")
            .expect("header entry present");
        let height = tip.height + 1;
        let spacing = params.consensus.pow_target_spacing.max(1) as u32;
        let time = tip_entry.time.saturating_add(spacing);
        let bits = chainstate
            .next_work_required_bits(&tip.hash, height, time as i64, &params.consensus)
            .expect("next bits");

        let coinbase = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: vec![TxIn {
                prevout: OutPoint::null(),
                script_sig: vec![0u8; 2],
                sequence: u32::MAX,
            }],
            vout: vec![TxOut {
                value: block_subsidy(height, &params.consensus),
                script_pubkey: Vec::new(),
            }],
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };

        let coinbase_txid = coinbase.txid().expect("coinbase txid");
        let final_sapling_root = chainstate.sapling_root().expect("sapling root");
        let header = BlockHeader {
            version: 0,
            prev_block: tip.hash,
            merkle_root: coinbase_txid,
            final_sapling_root,
            time,
            bits,
            nonce: [0u8; 32],
            solution: Vec::new(),
            nodes_collateral: OutPoint::null(),
            block_sig: Vec::new(),
        };

        let block = Block {
            header,
            transactions: vec![coinbase],
        };
        let block_hex = hex_bytes(&block.consensus_encode().expect("encode block"));

        let write_lock = Mutex::new(());
        let mempool = Mutex::new(Mempool::new(0));
        let fee_estimator = Mutex::new(FeeEstimator::new(0));
        let flags = ValidationFlags::default();
        let value = rpc_submitblock(
            &chainstate,
            &write_lock,
            &mempool,
            &fee_estimator,
            vec![Value::String(block_hex)],
            &params,
            &flags,
        )
        .expect("rpc");
        assert_eq!(value.as_str(), Some("block version too low"));
    }

    #[test]
    fn submitblock_marks_invalid_header_as_failed() {
        let (chainstate, params, _data_dir) = setup_regtest_chainstate();

        let tip = chainstate
            .best_block()
            .expect("best block")
            .expect("best block present");
        let tip_entry = chainstate
            .header_entry(&tip.hash)
            .expect("header entry")
            .expect("header entry present");
        let height = tip.height + 1;
        let spacing = params.consensus.pow_target_spacing.max(1) as u32;
        let time = tip_entry.time.saturating_add(spacing);
        let bits = chainstate
            .next_work_required_bits(&tip.hash, height, time as i64, &params.consensus)
            .expect("next bits");

        let miner_value = block_subsidy(height, &params.consensus);
        let exchange_amount = exchange_fund_amount(height, &params.funding);
        let foundation_amount = foundation_fund_amount(height, &params.funding);
        let swap_amount = swap_pool_amount(height as i64, &params.swap_pool);

        let mut vout = Vec::new();
        vout.push(TxOut {
            value: miner_value,
            script_pubkey: Vec::new(),
        });
        if exchange_amount > 0 {
            let script = address_to_script_pubkey(params.funding.exchange_address, params.network)
                .expect("exchange address script");
            vout.push(TxOut {
                value: exchange_amount,
                script_pubkey: script,
            });
        }
        if foundation_amount > 0 {
            let script =
                address_to_script_pubkey(params.funding.foundation_address, params.network)
                    .expect("foundation address script");
            vout.push(TxOut {
                value: foundation_amount,
                script_pubkey: script,
            });
        }
        if swap_amount > 0 {
            let script = address_to_script_pubkey(params.swap_pool.address, params.network)
                .expect("swap pool address script");
            vout.push(TxOut {
                value: swap_amount,
                script_pubkey: script,
            });
        }

        let coinbase = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: vec![TxIn {
                prevout: OutPoint::null(),
                script_sig: vec![0u8; 2],
                sequence: u32::MAX,
            }],
            vout,
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };

        let final_sapling_root = chainstate.sapling_root().expect("sapling root");
        let header = BlockHeader {
            version: CURRENT_VERSION,
            prev_block: tip.hash,
            merkle_root: [0x42u8; 32],
            final_sapling_root,
            time,
            bits,
            nonce: [0u8; 32],
            solution: Vec::new(),
            nodes_collateral: OutPoint::null(),
            block_sig: Vec::new(),
        };
        let block_hash = header.hash();
        let block = Block {
            header: header.clone(),
            transactions: vec![coinbase],
        };
        let block_hex = hex_bytes(&block.consensus_encode().expect("encode block"));

        let mut header_batch = WriteBatch::new();
        chainstate
            .insert_headers_batch_with_pow(&[header], &params.consensus, &mut header_batch, false)
            .expect("insert header");
        chainstate
            .commit_batch(header_batch)
            .expect("commit header");

        let write_lock = Mutex::new(());
        let mempool = Mutex::new(Mempool::new(0));
        let fee_estimator = Mutex::new(FeeEstimator::new(0));
        let flags = ValidationFlags::default();

        let value = rpc_submitblock(
            &chainstate,
            &write_lock,
            &mempool,
            &fee_estimator,
            vec![Value::String(block_hex.clone())],
            &params,
            &flags,
        )
        .expect("rpc");
        assert_eq!(value.as_str(), Some("duplicate"));

        let dup = rpc_submitblock(
            &chainstate,
            &write_lock,
            &mempool,
            &fee_estimator,
            vec![Value::String(block_hex)],
            &params,
            &flags,
        )
        .expect("rpc");
        assert_eq!(dup.as_str(), Some("duplicate-invalid"));

        let entry = chainstate
            .header_entry(&block_hash)
            .expect("header entry")
            .expect("header entry present");
        assert!(entry.is_failed());
    }

    #[test]
    fn submitblock_side_chain_is_accepted_and_stored() {
        let (chainstate, params, _data_dir) = setup_regtest_chainstate();
        extend_regtest_chain_to_height(&chainstate, &params, 1);

        let genesis = params.consensus.hash_genesis_block;
        let genesis_entry = chainstate
            .header_entry(&genesis)
            .expect("header entry")
            .expect("header entry present");

        let height = 1;
        let spacing = params.consensus.pow_target_spacing.max(1) as u32;
        let time = genesis_entry.time.saturating_add(spacing);
        let bits = chainstate
            .next_work_required_bits(&genesis, height, time as i64, &params.consensus)
            .expect("next bits");

        let miner_value = block_subsidy(height, &params.consensus);
        let exchange_amount = exchange_fund_amount(height, &params.funding);
        let foundation_amount = foundation_fund_amount(height, &params.funding);
        let swap_amount = swap_pool_amount(height as i64, &params.swap_pool);

        let mut vout = Vec::new();
        vout.push(TxOut {
            value: miner_value,
            script_pubkey: Vec::new(),
        });
        if exchange_amount > 0 {
            let script = address_to_script_pubkey(params.funding.exchange_address, params.network)
                .expect("exchange address script");
            vout.push(TxOut {
                value: exchange_amount,
                script_pubkey: script,
            });
        }
        if foundation_amount > 0 {
            let script =
                address_to_script_pubkey(params.funding.foundation_address, params.network)
                    .expect("foundation address script");
            vout.push(TxOut {
                value: foundation_amount,
                script_pubkey: script,
            });
        }
        if swap_amount > 0 {
            let script = address_to_script_pubkey(params.swap_pool.address, params.network)
                .expect("swap pool address script");
            vout.push(TxOut {
                value: swap_amount,
                script_pubkey: script,
            });
        }
        let coinbase = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: vec![TxIn {
                prevout: OutPoint::null(),
                script_sig: vec![1u8; 2],
                sequence: u32::MAX,
            }],
            vout,
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };

        let coinbase_txid = coinbase.txid().expect("coinbase txid");
        let final_sapling_root = chainstate.sapling_root().expect("sapling root");
        let header = BlockHeader {
            version: CURRENT_VERSION,
            prev_block: genesis,
            merkle_root: coinbase_txid,
            final_sapling_root,
            time,
            bits,
            nonce: [0u8; 32],
            solution: Vec::new(),
            nodes_collateral: OutPoint::null(),
            block_sig: Vec::new(),
        };
        let block_hash = header.hash();
        let block = Block {
            header: header.clone(),
            transactions: vec![coinbase],
        };
        let block_bytes = block.consensus_encode().expect("encode block");
        let block_hex = hex_bytes(&block_bytes);

        let mut header_batch = WriteBatch::new();
        chainstate
            .insert_headers_batch_with_pow(&[header], &params.consensus, &mut header_batch, false)
            .expect("insert header");
        chainstate
            .commit_batch(header_batch)
            .expect("commit header");

        let best_before = chainstate
            .best_block()
            .expect("best block")
            .expect("best block present");

        let write_lock = Mutex::new(());
        let mempool = Mutex::new(Mempool::new(0));
        let fee_estimator = Mutex::new(FeeEstimator::new(0));
        let flags = ValidationFlags::default();
        let value = rpc_submitblock(
            &chainstate,
            &write_lock,
            &mempool,
            &fee_estimator,
            vec![Value::String(block_hex.clone())],
            &params,
            &flags,
        )
        .expect("rpc");
        assert_eq!(value.as_str(), Some("duplicate"));

        let best_after = chainstate
            .best_block()
            .expect("best block")
            .expect("best block present");
        assert_eq!(best_after.hash, best_before.hash);

        assert!(chainstate
            .block_location(&block_hash)
            .expect("block location")
            .is_none());
        assert_eq!(
            chainstate
                .unconnected_block_bytes(&block_hash)
                .expect("unconnected block")
                .expect("stored bytes"),
            block_bytes
        );

        let dup = rpc_submitblock(
            &chainstate,
            &write_lock,
            &mempool,
            &fee_estimator,
            vec![Value::String(block_hex)],
            &params,
            &flags,
        )
        .expect("rpc");
        assert_eq!(dup.as_str(), Some("duplicate-inconclusive"));
    }

    #[test]
    fn submitblock_reorgs_to_stronger_side_chain_when_blocks_available() {
        let (chainstate, params, _data_dir) = setup_regtest_chainstate();
        extend_regtest_chain_to_height(&chainstate, &params, 1);

        let genesis = params.consensus.hash_genesis_block;
        let genesis_entry = chainstate
            .header_entry(&genesis)
            .expect("header entry")
            .expect("header entry present");

        let write_lock = Mutex::new(());
        let mempool = Mutex::new(Mempool::new(0));
        let fee_estimator = Mutex::new(FeeEstimator::new(0));
        let flags = ValidationFlags::default();

        let spacing = params.consensus.pow_target_spacing.max(1) as u32;
        let fork_height_1 = 1;
        let fork_time_1 = genesis_entry.time.saturating_add(spacing);
        let fork_bits_1 = chainstate
            .next_work_required_bits(
                &genesis,
                fork_height_1,
                fork_time_1 as i64,
                &params.consensus,
            )
            .expect("next bits");

        let miner_value_1 = block_subsidy(fork_height_1, &params.consensus);
        let exchange_amount_1 = exchange_fund_amount(fork_height_1, &params.funding);
        let foundation_amount_1 = foundation_fund_amount(fork_height_1, &params.funding);
        let swap_amount_1 = swap_pool_amount(fork_height_1 as i64, &params.swap_pool);
        let mut vout_1 = Vec::new();
        vout_1.push(TxOut {
            value: miner_value_1,
            script_pubkey: Vec::new(),
        });
        if exchange_amount_1 > 0 {
            let script = address_to_script_pubkey(params.funding.exchange_address, params.network)
                .expect("exchange address script");
            vout_1.push(TxOut {
                value: exchange_amount_1,
                script_pubkey: script,
            });
        }
        if foundation_amount_1 > 0 {
            let script =
                address_to_script_pubkey(params.funding.foundation_address, params.network)
                    .expect("foundation address script");
            vout_1.push(TxOut {
                value: foundation_amount_1,
                script_pubkey: script,
            });
        }
        if swap_amount_1 > 0 {
            let script = address_to_script_pubkey(params.swap_pool.address, params.network)
                .expect("swap pool address script");
            vout_1.push(TxOut {
                value: swap_amount_1,
                script_pubkey: script,
            });
        }
        let coinbase_1 = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: vec![TxIn {
                prevout: OutPoint::null(),
                script_sig: vec![1u8; 2],
                sequence: u32::MAX,
            }],
            vout: vout_1,
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let coinbase_txid_1 = coinbase_1.txid().expect("coinbase txid");
        let final_sapling_root_1 = chainstate.sapling_root().expect("sapling root");
        let header_1 = BlockHeader {
            version: CURRENT_VERSION,
            prev_block: genesis,
            merkle_root: coinbase_txid_1,
            final_sapling_root: final_sapling_root_1,
            time: fork_time_1,
            bits: fork_bits_1,
            nonce: [0u8; 32],
            solution: Vec::new(),
            nodes_collateral: OutPoint::null(),
            block_sig: Vec::new(),
        };
        let fork_hash_1 = header_1.hash();
        let fork_block_1 = Block {
            header: header_1,
            transactions: vec![coinbase_1],
        };
        let fork_hex_1 = hex_bytes(&fork_block_1.consensus_encode().expect("encode fork block"));

        let mut fork_header_batch_1 = WriteBatch::new();
        chainstate
            .insert_headers_batch_with_pow(
                &[fork_block_1.header.clone()],
                &params.consensus,
                &mut fork_header_batch_1,
                false,
            )
            .expect("insert fork header 1");
        chainstate
            .commit_batch(fork_header_batch_1)
            .expect("commit fork header 1");

        let submitted_1 = rpc_submitblock(
            &chainstate,
            &write_lock,
            &mempool,
            &fee_estimator,
            vec![Value::String(fork_hex_1)],
            &params,
            &flags,
        )
        .expect("rpc");
        assert_eq!(submitted_1.as_str(), Some("duplicate"));

        let best_before = chainstate
            .best_block()
            .expect("best block")
            .expect("best block present");
        assert_eq!(best_before.height, 1);

        let fork_entry_1 = chainstate
            .header_entry(&fork_hash_1)
            .expect("header entry")
            .expect("fork header entry");
        let fork_height_2 = 2;
        let fork_time_2 = fork_entry_1.time.saturating_add(spacing);
        let fork_bits_2 = chainstate
            .next_work_required_bits(
                &fork_hash_1,
                fork_height_2,
                fork_time_2 as i64,
                &params.consensus,
            )
            .expect("next bits");

        let miner_value_2 = block_subsidy(fork_height_2, &params.consensus);
        let exchange_amount_2 = exchange_fund_amount(fork_height_2, &params.funding);
        let foundation_amount_2 = foundation_fund_amount(fork_height_2, &params.funding);
        let swap_amount_2 = swap_pool_amount(fork_height_2 as i64, &params.swap_pool);
        let mut vout_2 = Vec::new();
        vout_2.push(TxOut {
            value: miner_value_2,
            script_pubkey: Vec::new(),
        });
        if exchange_amount_2 > 0 {
            let script = address_to_script_pubkey(params.funding.exchange_address, params.network)
                .expect("exchange address script");
            vout_2.push(TxOut {
                value: exchange_amount_2,
                script_pubkey: script,
            });
        }
        if foundation_amount_2 > 0 {
            let script =
                address_to_script_pubkey(params.funding.foundation_address, params.network)
                    .expect("foundation address script");
            vout_2.push(TxOut {
                value: foundation_amount_2,
                script_pubkey: script,
            });
        }
        if swap_amount_2 > 0 {
            let script = address_to_script_pubkey(params.swap_pool.address, params.network)
                .expect("swap pool address script");
            vout_2.push(TxOut {
                value: swap_amount_2,
                script_pubkey: script,
            });
        }
        let coinbase_2 = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: vec![TxIn {
                prevout: OutPoint::null(),
                script_sig: vec![1u8; 2],
                sequence: u32::MAX,
            }],
            vout: vout_2,
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let coinbase_txid_2 = coinbase_2.txid().expect("coinbase txid");
        let final_sapling_root_2 = chainstate.sapling_root().expect("sapling root");
        let header_2 = BlockHeader {
            version: CURRENT_VERSION,
            prev_block: fork_hash_1,
            merkle_root: coinbase_txid_2,
            final_sapling_root: final_sapling_root_2,
            time: fork_time_2,
            bits: fork_bits_2,
            nonce: [0u8; 32],
            solution: Vec::new(),
            nodes_collateral: OutPoint::null(),
            block_sig: Vec::new(),
        };
        let fork_hash_2 = header_2.hash();
        let fork_block_2 = Block {
            header: header_2,
            transactions: vec![coinbase_2],
        };
        let fork_hex_2 = hex_bytes(&fork_block_2.consensus_encode().expect("encode fork block"));

        let mut fork_header_batch_2 = WriteBatch::new();
        chainstate
            .insert_headers_batch_with_pow(
                &[fork_block_2.header.clone()],
                &params.consensus,
                &mut fork_header_batch_2,
                false,
            )
            .expect("insert fork header 2");
        chainstate
            .commit_batch(fork_header_batch_2)
            .expect("commit fork header 2");

        let submitted_2 = rpc_submitblock(
            &chainstate,
            &write_lock,
            &mempool,
            &fee_estimator,
            vec![Value::String(fork_hex_2)],
            &params,
            &flags,
        )
        .expect("rpc");
        assert_eq!(submitted_2.as_str(), Some("duplicate"));

        let best_after = chainstate
            .best_block()
            .expect("best block")
            .expect("best block present");
        assert_eq!(best_after.hash, fork_hash_2);
        assert_eq!(best_after.height, 2);

        assert!(chainstate
            .unconnected_block_bytes(&fork_hash_1)
            .expect("unconnected bytes")
            .is_none());
        assert!(chainstate
            .unconnected_block_bytes(&fork_hash_2)
            .expect("unconnected bytes")
            .is_none());
        assert!(chainstate
            .block_location(&fork_hash_1)
            .expect("block location")
            .is_some());
        assert!(chainstate
            .block_location(&fork_hash_2)
            .expect("block location")
            .is_some());
    }

    #[test]
    fn validateaddress_has_cpp_schema() {
        let (_chainstate, params, _data_dir, address, _txid, _vout) =
            setup_regtest_chain_with_p2pkh_utxo();
        let wallet =
            Mutex::new(Wallet::load_or_create(&_data_dir, params.network).expect("wallet"));

        let ok = rpc_validateaddress(&wallet, vec![Value::String(address.clone())], &params)
            .expect("rpc");
        let obj = ok.as_object().expect("object");
        assert_eq!(obj.get("isvalid").and_then(Value::as_bool), Some(true));
        for key in [
            "address",
            "scriptPubKey",
            "ismine",
            "iswatchonly",
            "isscript",
        ] {
            assert!(obj.contains_key(key), "missing key {key}");
        }
        assert_eq!(obj.get("ismine").and_then(Value::as_bool), Some(false));
        assert_eq!(obj.get("iswatchonly").and_then(Value::as_bool), Some(false));
        assert_eq!(obj.get("isscript").and_then(Value::as_bool), Some(false));

        let bad = rpc_validateaddress(
            &wallet,
            vec![Value::String("notanaddress".to_string())],
            &params,
        )
        .expect("rpc");
        let obj = bad.as_object().expect("object");
        assert_eq!(obj.get("isvalid").and_then(Value::as_bool), Some(false));
    }

    #[test]
    fn validateaddress_reports_ismine_for_wallet_address() {
        let (_chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let addr = rpc_getnewaddress(&wallet, Vec::new()).expect("rpc");
        let addr = addr.as_str().expect("string").to_string();

        let ok = rpc_validateaddress(&wallet, vec![Value::String(addr)], &params).expect("rpc");
        let obj = ok.as_object().expect("object");
        assert_eq!(obj.get("isvalid").and_then(Value::as_bool), Some(true));
        assert_eq!(obj.get("ismine").and_then(Value::as_bool), Some(true));
        assert_eq!(obj.get("iswatchonly").and_then(Value::as_bool), Some(false));
        assert_eq!(obj.get("isscript").and_then(Value::as_bool), Some(false));
        assert_eq!(obj.get("account").and_then(Value::as_str), Some(""));
    }

    #[test]
    fn validateaddress_returns_account_label_for_labeled_wallet_address() {
        let (_chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let addr = rpc_getnewaddress(&wallet, vec![json!("label-a")])
            .expect("rpc")
            .as_str()
            .expect("string")
            .to_string();

        let ok = rpc_validateaddress(&wallet, vec![Value::String(addr)], &params).expect("rpc");
        let obj = ok.as_object().expect("object");
        assert_eq!(obj.get("isvalid").and_then(Value::as_bool), Some(true));
        assert_eq!(obj.get("account").and_then(Value::as_str), Some("label-a"));
    }

    #[test]
    fn validateaddress_includes_pubkey_for_wallet_address() {
        let (_chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let addr = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("string")
            .to_string();

        let ok = rpc_validateaddress(&wallet, vec![Value::String(addr)], &params).expect("rpc");
        let obj = ok.as_object().expect("object");
        assert_eq!(obj.get("isvalid").and_then(Value::as_bool), Some(true));
        assert_eq!(obj.get("ismine").and_then(Value::as_bool), Some(true));
        assert!(
            obj.get("pubkey").and_then(Value::as_str).is_some(),
            "wallet-owned P2PKH should include pubkey"
        );
        assert!(
            obj.get("iscompressed").and_then(Value::as_bool).is_some(),
            "wallet-owned P2PKH should include iscompressed"
        );
    }

    #[test]
    fn validateaddress_includes_multisig_details_for_known_p2sh_script() {
        let (_chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let addr_a = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let addr_b = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();

        let p2sh_address = rpc_addmultisigaddress(
            &wallet,
            vec![json!(2), json!([addr_a.clone(), addr_b.clone()])],
            &params,
        )
        .expect("rpc")
        .as_str()
        .expect("p2sh address")
        .to_string();

        let script_pubkey =
            address_to_script_pubkey(&p2sh_address, params.network).expect("script_pubkey");
        let redeem_script = {
            let guard = wallet.lock().expect("wallet lock");
            guard
                .redeem_script_for_p2sh_script_pubkey(&script_pubkey)
                .expect("redeem script")
        };
        let redeem_script_hex = hex_bytes(&redeem_script);

        let ok =
            rpc_validateaddress(&wallet, vec![Value::String(p2sh_address)], &params).expect("rpc");
        let obj = ok.as_object().expect("object");
        assert_eq!(obj.get("isvalid").and_then(Value::as_bool), Some(true));
        assert_eq!(obj.get("isscript").and_then(Value::as_bool), Some(true));
        assert_eq!(obj.get("script").and_then(Value::as_str), Some("multisig"));
        assert_eq!(
            obj.get("hex").and_then(Value::as_str),
            Some(redeem_script_hex.as_str())
        );
        assert_eq!(obj.get("sigsrequired").and_then(Value::as_u64), Some(2));
        let got_addresses = obj
            .get("addresses")
            .and_then(Value::as_array)
            .expect("addresses array")
            .iter()
            .filter_map(Value::as_str)
            .collect::<std::collections::HashSet<_>>();
        let expected = [addr_a.as_str(), addr_b.as_str()]
            .into_iter()
            .collect::<std::collections::HashSet<_>>();
        assert_eq!(got_addresses, expected);
    }

    #[test]
    fn validateaddress_reports_account_for_labeled_multisig_script() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let addr_a = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let addr_b = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();

        let p2sh_address = rpc_addmultisigaddress(
            &wallet,
            vec![json!(2), json!([addr_a, addr_b]), json!("")],
            &params,
        )
        .expect("rpc")
        .as_str()
        .expect("p2sh address")
        .to_string();

        rpc_importaddress(
            &chainstate,
            &wallet,
            vec![
                json!(p2sh_address.clone()),
                json!("multisig-label"),
                json!(false),
            ],
            &params,
        )
        .expect("rpc");

        let ok =
            rpc_validateaddress(&wallet, vec![Value::String(p2sh_address)], &params).expect("rpc");
        let obj = ok.as_object().expect("object");
        assert_eq!(obj.get("isvalid").and_then(Value::as_bool), Some(true));
        assert_eq!(
            obj.get("account").and_then(Value::as_str),
            Some("multisig-label")
        );
    }

    #[test]
    fn validateaddress_reports_watchonly_for_imported_script() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let watch_script = p2pkh_script([0x55u8; 20]);
        let watch_address =
            script_pubkey_to_address(&watch_script, params.network).expect("watch address");
        rpc_importaddress(
            &chainstate,
            &wallet,
            vec![json!(watch_address.clone()), Value::Null, json!(false)],
            &params,
        )
        .expect("rpc");

        let ok =
            rpc_validateaddress(&wallet, vec![Value::String(watch_address)], &params).expect("rpc");
        let obj = ok.as_object().expect("object");
        assert_eq!(obj.get("isvalid").and_then(Value::as_bool), Some(true));
        assert_eq!(obj.get("ismine").and_then(Value::as_bool), Some(false));
        assert_eq!(obj.get("iswatchonly").and_then(Value::as_bool), Some(true));
        assert_eq!(obj.get("isscript").and_then(Value::as_bool), Some(false));
    }

    #[test]
    fn zvalidateaddress_reports_sprout_and_sapling_fields() {
        use bech32::{Bech32, Hrp};

        let (_chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let sprout_payingkey = [0x11u8; 32];
        let sprout_transmissionkey = [0x22u8; 32];
        let mut sprout_payload = Vec::new();
        sprout_payload.extend_from_slice(&[0x16, 0xb6]);
        sprout_payload.extend_from_slice(&sprout_payingkey);
        sprout_payload.extend_from_slice(&sprout_transmissionkey);
        let sprout_addr = base58check_encode(&sprout_payload);

        let sprout =
            rpc_zvalidateaddress(&wallet, vec![json!(sprout_addr.clone())], &params).expect("rpc");
        let obj = sprout.as_object().expect("object");
        assert_eq!(obj.get("isvalid").and_then(Value::as_bool), Some(true));
        assert_eq!(
            obj.get("address").and_then(Value::as_str),
            Some(sprout_addr.as_str())
        );
        assert_eq!(obj.get("type").and_then(Value::as_str), Some("sprout"));
        assert_eq!(obj.get("ismine").and_then(Value::as_bool), Some(false));
        assert_eq!(obj.get("iswatchonly").and_then(Value::as_bool), Some(false));
        let expected_payingkey = hex_bytes(&sprout_payingkey);
        assert_eq!(
            obj.get("payingkey").and_then(Value::as_str),
            Some(expected_payingkey.as_str())
        );
        let expected_transmissionkey = hex_bytes(&sprout_transmissionkey);
        assert_eq!(
            obj.get("transmissionkey").and_then(Value::as_str),
            Some(expected_transmissionkey.as_str())
        );

        let sapling_diversifier = [0x33u8; 11];
        let sapling_pk_d = [0x44u8; 32];
        let mut sapling_payload = Vec::new();
        sapling_payload.extend_from_slice(&sapling_diversifier);
        sapling_payload.extend_from_slice(&sapling_pk_d);
        let sapling_hrp = Hrp::parse("zregtestsapling").expect("hrp");
        let sapling_addr =
            bech32::encode::<Bech32>(sapling_hrp, &sapling_payload).expect("sapling bech32");

        let sapling =
            rpc_zvalidateaddress(&wallet, vec![json!(sapling_addr.clone())], &params).expect("rpc");
        let obj = sapling.as_object().expect("object");
        assert_eq!(obj.get("isvalid").and_then(Value::as_bool), Some(true));
        assert_eq!(
            obj.get("address").and_then(Value::as_str),
            Some(sapling_addr.as_str())
        );
        assert_eq!(obj.get("type").and_then(Value::as_str), Some("sapling"));
        assert_eq!(obj.get("ismine").and_then(Value::as_bool), Some(false));
        assert_eq!(obj.get("iswatchonly").and_then(Value::as_bool), Some(false));
        let expected_diversifier = hex_bytes(&sapling_diversifier);
        assert_eq!(
            obj.get("diversifier").and_then(Value::as_str),
            Some(expected_diversifier.as_str())
        );
        let expected_pk_d = hex_bytes(&sapling_pk_d);
        assert_eq!(
            obj.get("diversifiedtransmissionkey")
                .and_then(Value::as_str),
            Some(expected_pk_d.as_str())
        );
    }

    #[test]
    fn zvalidateaddress_rejects_other_network_prefixes() {
        use bech32::{Bech32, Hrp};

        let (_chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let mut sprout_payload = Vec::new();
        sprout_payload.extend_from_slice(&[0x16, 0x9a]);
        sprout_payload.extend_from_slice(&[0x11u8; 64]);
        let sprout_addr = base58check_encode(&sprout_payload);

        let value = rpc_zvalidateaddress(&wallet, vec![json!(sprout_addr)], &params).expect("rpc");
        let obj = value.as_object().expect("object");
        assert_eq!(obj.get("isvalid").and_then(Value::as_bool), Some(false));

        let sapling_payload = vec![0x55u8; 43];
        let sapling_hrp = Hrp::parse("za").expect("hrp");
        let sapling_addr = bech32::encode::<Bech32>(sapling_hrp, &sapling_payload).expect("bech32");

        let value = rpc_zvalidateaddress(&wallet, vec![json!(sapling_addr)], &params).expect("rpc");
        let obj = value.as_object().expect("object");
        assert_eq!(obj.get("isvalid").and_then(Value::as_bool), Some(false));
    }

    #[test]
    fn zgetnewaddress_returns_sapling_address_and_is_mine() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let addr = rpc_zgetnewaddress(&chainstate, &wallet, Vec::new(), &params).expect("rpc");
        let addr = addr.as_str().expect("string").to_string();

        let value = rpc_zvalidateaddress(&wallet, vec![json!(addr)], &params).expect("rpc");
        let obj = value.as_object().expect("object");
        assert_eq!(obj.get("isvalid").and_then(Value::as_bool), Some(true));
        assert_eq!(obj.get("type").and_then(Value::as_str), Some("sapling"));
        assert_eq!(obj.get("ismine").and_then(Value::as_bool), Some(true));
        assert_eq!(obj.get("iswatchonly").and_then(Value::as_bool), Some(false));
    }

    #[test]
    fn zvalidateaddress_sets_iswatchonly_for_imported_viewing_key() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let addr = rpc_zgetnewaddress(&chainstate, &wallet, Vec::new(), &params).expect("rpc");
        let addr = addr.as_str().expect("string").to_string();
        let vkey = rpc_zexportviewingkey(&wallet, vec![json!(addr.clone())], &params).expect("rpc");
        let vkey = vkey.as_str().expect("string").to_string();

        let data_dir2 = temp_data_dir("fluxd-zvalidateaddress-watchonly-test");
        let wallet2 =
            Mutex::new(Wallet::load_or_create(&data_dir2, params.network).expect("wallet"));
        rpc_zimportviewingkey(&wallet2, vec![json!(vkey)], &params).expect("rpc");

        let value = rpc_zvalidateaddress(&wallet2, vec![json!(addr)], &params).expect("rpc");
        let obj = value.as_object().expect("object");
        assert_eq!(obj.get("isvalid").and_then(Value::as_bool), Some(true));
        assert_eq!(obj.get("type").and_then(Value::as_str), Some("sapling"));
        assert_eq!(obj.get("ismine").and_then(Value::as_bool), Some(false));
        assert_eq!(obj.get("iswatchonly").and_then(Value::as_bool), Some(true));
    }

    #[test]
    fn zlistaddresses_includes_generated_sapling_addresses() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let value = rpc_zlistaddresses(&wallet, Vec::new(), &params).expect("rpc");
        assert_eq!(value.as_array().map(|values| values.len()), Some(0));

        let addr = rpc_zgetnewaddress(&chainstate, &wallet, Vec::new(), &params).expect("rpc");
        let addr = addr.as_str().expect("string").to_string();

        let value = rpc_zlistaddresses(&wallet, vec![json!(false)], &params).expect("rpc");
        let addrs = value.as_array().expect("array");
        assert!(addrs
            .iter()
            .any(|value| value.as_str() == Some(addr.as_str())));
    }

    #[test]
    fn zexportkey_exports_sapling_extsk_for_own_address() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let addr = rpc_zgetnewaddress(&chainstate, &wallet, Vec::new(), &params).expect("rpc");
        let addr = addr.as_str().expect("string").to_string();

        let key = rpc_zexportkey(&wallet, vec![json!(addr)], &params).expect("rpc");
        let key = key.as_str().expect("string");
        assert!(key.starts_with("secret-extended-key-regtest1"));
    }

    #[test]
    fn zexportkey_rejects_address_not_in_wallet() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));
        let addr = rpc_zgetnewaddress(&chainstate, &wallet, Vec::new(), &params).expect("rpc");
        let addr = addr.as_str().expect("string").to_string();

        let other_dir = temp_data_dir("fluxd-rpc-test-zexportkey");
        std::fs::create_dir_all(&other_dir).expect("create dir");
        let other_wallet =
            Mutex::new(Wallet::load_or_create(&other_dir, params.network).expect("wallet"));

        let err = rpc_zexportkey(&other_wallet, vec![json!(addr)], &params).unwrap_err();
        assert_eq!(err.code, RPC_WALLET_ERROR);
    }

    #[test]
    fn zimportkey_roundtrips_sapling_extsk() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let addr1 = rpc_zgetnewaddress(&chainstate, &wallet, Vec::new(), &params).expect("rpc");
        let addr1 = addr1.as_str().expect("string").to_string();
        let zkey = rpc_zexportkey(&wallet, vec![json!(addr1.clone())], &params).expect("rpc");
        let zkey = zkey.as_str().expect("string").to_string();

        let other_dir = temp_data_dir("fluxd-rpc-test-zimportkey");
        std::fs::create_dir_all(&other_dir).expect("create dir");
        let other_wallet =
            Mutex::new(Wallet::load_or_create(&other_dir, params.network).expect("wallet"));

        rpc_zimportkey(&other_wallet, vec![json!(zkey)], &params).expect("rpc");
        let addr2 =
            rpc_zgetnewaddress(&chainstate, &other_wallet, Vec::new(), &params).expect("rpc");
        let addr2 = addr2.as_str().expect("string").to_string();
        assert_eq!(addr2, addr1);
    }

    #[test]
    fn zimportkey_rejects_invalid_key() {
        let (_chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let err = rpc_zimportkey(&wallet, vec![json!("notakey")], &params).unwrap_err();
        assert_eq!(err.code, RPC_INVALID_ADDRESS_OR_KEY);
    }

    #[test]
    fn zimportwallet_imports_sapling_key_from_file() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let addr1 = rpc_zgetnewaddress(&chainstate, &wallet, Vec::new(), &params).expect("rpc");
        let addr1 = addr1.as_str().expect("string").to_string();
        let zkey = rpc_zexportkey(&wallet, vec![json!(addr1.clone())], &params).expect("rpc");
        let zkey = zkey.as_str().expect("string").to_string();

        let dump_dir = temp_data_dir("fluxd-rpc-test-zimportwallet-file");
        std::fs::create_dir_all(&dump_dir).expect("create dir");
        let dump_path = dump_dir.join("walletdump.txt");
        std::fs::write(&dump_path, format!("{zkey} 0 # zaddr={addr1}\n")).expect("write");

        let other_dir = temp_data_dir("fluxd-rpc-test-zimportwallet");
        std::fs::create_dir_all(&other_dir).expect("create dir");
        let other_wallet =
            Mutex::new(Wallet::load_or_create(&other_dir, params.network).expect("wallet"));

        rpc_zimportwallet(
            &other_wallet,
            vec![json!(dump_path.to_string_lossy().to_string())],
            &params,
        )
        .expect("rpc");
        let addr2 =
            rpc_zgetnewaddress(&chainstate, &other_wallet, Vec::new(), &params).expect("rpc");
        let addr2 = addr2.as_str().expect("string").to_string();
        assert_eq!(addr2, addr1);
    }

    #[test]
    fn zgetnewaddress_rejects_unknown_type() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let err =
            rpc_zgetnewaddress(&chainstate, &wallet, vec![json!("sprout")], &params).unwrap_err();
        assert_eq!(err.code, RPC_INVALID_PARAMETER);
    }

    #[test]
    fn zgetbalance_and_zlistunspent_track_sapling_notes() {
        let (chainstate, params, data_dir, _taddr, coinbase_txid, coinbase_vout) =
            setup_regtest_chain_with_p2pkh_utxo();
        extend_regtest_chain_to_height(&chainstate, &params, COINBASE_MATURITY);

        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));
        let zaddr = rpc_zgetnewaddress(&chainstate, &wallet, Vec::new(), &params).expect("rpc");
        let zaddr = zaddr.as_str().expect("string").to_string();

        let addr_bytes = parse_sapling_zaddr_bytes(&zaddr, &params).expect("sapling bytes");
        let to = PaymentAddress::from_bytes(&addr_bytes).expect("payment address");

        let value = block_subsidy(1, &params.consensus);
        let note_value = NoteValue::from_raw(u64::try_from(value).expect("note value"));
        let mut rng = rand::rngs::OsRng;
        let mut rseed = [0u8; 32];
        rng.fill_bytes(&mut rseed);
        let note = to.create_note(note_value, Rseed::AfterZip212(rseed));

        let enc = sapling_note_encryption(None, note.clone(), [0u8; 512], &mut rng);
        let epk_bytes = <SaplingDomain as Domain>::epk_bytes(enc.epk()).0;

        let output = fluxd_primitives::transaction::OutputDescription {
            cv: [0u8; 32],
            cm: note.cmu().to_bytes(),
            ephemeral_key: epk_bytes,
            enc_ciphertext: enc.encrypt_note_plaintext(),
            out_ciphertext: [0u8; fluxd_primitives::transaction::SAPLING_OUT_CIPHERTEXT_SIZE],
            zkproof: [0u8; fluxd_primitives::transaction::GROTH_PROOF_SIZE],
        };

        let shield_tx = Transaction {
            f_overwintered: true,
            version: 4,
            version_group_id: fluxd_primitives::transaction::SAPLING_VERSION_GROUP_ID,
            vin: vec![TxIn {
                prevout: OutPoint {
                    hash: coinbase_txid,
                    index: coinbase_vout,
                },
                script_sig: Vec::new(),
                sequence: u32::MAX,
            }],
            vout: Vec::new(),
            lock_time: 0,
            expiry_height: 0,
            value_balance: -value,
            shielded_spends: Vec::new(),
            shielded_outputs: vec![output.clone()],
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let shield_txid = shield_tx.txid().expect("txid");

        let tip = chainstate
            .best_block()
            .expect("best block")
            .expect("best block present");
        let tip_entry = chainstate
            .header_entry(&tip.hash)
            .expect("header entry")
            .expect("header entry present");
        let height = tip.height + 1;
        let spacing = params.consensus.pow_target_spacing.max(1) as u32;
        let time = tip_entry.time.saturating_add(spacing);
        let bits = chainstate
            .next_work_required_bits(&tip.hash, height, time as i64, &params.consensus)
            .expect("next bits");

        let miner_value = block_subsidy(height, &params.consensus);
        let exchange_amount = exchange_fund_amount(height, &params.funding);
        let foundation_amount = foundation_fund_amount(height, &params.funding);
        let swap_amount = swap_pool_amount(height as i64, &params.swap_pool);

        let mut vout = Vec::new();
        vout.push(TxOut {
            value: miner_value,
            script_pubkey: Vec::new(),
        });
        if exchange_amount > 0 {
            let script = address_to_script_pubkey(params.funding.exchange_address, params.network)
                .expect("exchange address script");
            vout.push(TxOut {
                value: exchange_amount,
                script_pubkey: script,
            });
        }
        if foundation_amount > 0 {
            let script =
                address_to_script_pubkey(params.funding.foundation_address, params.network)
                    .expect("foundation address script");
            vout.push(TxOut {
                value: foundation_amount,
                script_pubkey: script,
            });
        }
        if swap_amount > 0 {
            let script = address_to_script_pubkey(params.swap_pool.address, params.network)
                .expect("swap pool address script");
            vout.push(TxOut {
                value: swap_amount,
                script_pubkey: script,
            });
        }
        let coinbase = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: vec![TxIn {
                prevout: OutPoint::null(),
                script_sig: Vec::new(),
                sequence: u32::MAX,
            }],
            vout,
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let coinbase_txid = coinbase.txid().expect("coinbase txid");
        let final_sapling_root = chainstate
            .sapling_root_after_commitments(&[output.cm])
            .expect("sapling root");

        let header = BlockHeader {
            version: CURRENT_VERSION,
            prev_block: tip.hash,
            merkle_root: coinbase_txid,
            final_sapling_root,
            time,
            bits,
            nonce: [0u8; 32],
            solution: Vec::new(),
            nodes_collateral: OutPoint::null(),
            block_sig: Vec::new(),
        };

        let mut header_batch = WriteBatch::new();
        chainstate
            .insert_headers_batch_with_pow(
                &[header.clone()],
                &params.consensus,
                &mut header_batch,
                false,
            )
            .expect("insert header");
        chainstate
            .commit_batch(header_batch)
            .expect("commit header");

        let block = Block {
            header,
            transactions: vec![coinbase, shield_tx],
        };
        let block_bytes = block.consensus_encode().expect("encode block");
        let flags = ValidationFlags::default();
        let batch = chainstate
            .connect_block(
                &block,
                height,
                &params,
                &flags,
                true,
                None,
                None,
                Some(block_bytes.as_slice()),
                None,
            )
            .expect("connect block");
        chainstate.commit_batch(batch).expect("commit block");

        let mempool = Mutex::new(Mempool::new(0));
        let balance = rpc_zgetbalance(&chainstate, &mempool, &wallet, vec![json!(zaddr)], &params)
            .expect("rpc");
        assert_eq!(balance, amount_to_value(value));

        let total =
            rpc_zgettotalbalance(&chainstate, &mempool, &wallet, Vec::new(), &params).expect("rpc");
        let obj = total.as_object().expect("object");
        assert_eq!(obj.get("private").cloned(), Some(amount_to_value(value)));

        let unspent =
            rpc_zlistunspent(&chainstate, &mempool, &wallet, Vec::new(), &params).expect("rpc");
        let list = unspent.as_array().expect("array");
        assert_eq!(list.len(), 1);
        let entry = list[0].as_object().expect("object");
        let shield_txid_hex = hash256_to_hex(&shield_txid);
        let memo_hex = "00".repeat(512);
        assert_eq!(
            entry.get("txid").and_then(Value::as_str),
            Some(shield_txid_hex.as_str())
        );
        assert_eq!(entry.get("amountZat").and_then(Value::as_i64), Some(value));
        assert_eq!(
            entry.get("memo").and_then(Value::as_str),
            Some(memo_hex.as_str())
        );
        assert_eq!(entry.get("spendable").and_then(Value::as_bool), Some(true));
        assert_eq!(entry.get("change").and_then(Value::as_bool), Some(false));

        let received =
            rpc_zlistreceivedbyaddress(&chainstate, &wallet, vec![json!(zaddr)], &params)
                .expect("rpc");
        let list = received.as_array().expect("array");
        assert_eq!(list.len(), 1);
        let entry = list[0].as_object().expect("object");
        assert_eq!(
            entry.get("txid").and_then(Value::as_str),
            Some(shield_txid_hex.as_str())
        );
        assert_eq!(entry.get("outindex").and_then(Value::as_u64), Some(0));
        assert_eq!(entry.get("amountZat").and_then(Value::as_i64), Some(value));
        assert_eq!(
            entry.get("memo").and_then(Value::as_str),
            Some(memo_hex.as_str())
        );
        assert_eq!(entry.get("spent").and_then(Value::as_bool), Some(false));
        assert_eq!(entry.get("spendable").and_then(Value::as_bool), Some(true));
        assert_eq!(entry.get("change").and_then(Value::as_bool), Some(false));

        rpc_encryptwallet(&wallet, vec![json!("passphrase")]).expect("encryptwallet");
        rpc_walletlock(&wallet, Vec::new()).expect("walletlock");

        let balance_locked =
            rpc_zgetbalance(&chainstate, &mempool, &wallet, vec![json!(zaddr)], &params)
                .expect("rpc");
        assert_eq!(balance_locked, amount_to_value(value));

        let total_locked =
            rpc_zgettotalbalance(&chainstate, &mempool, &wallet, Vec::new(), &params).expect("rpc");
        let obj = total_locked.as_object().expect("object");
        assert_eq!(obj.get("private").cloned(), Some(amount_to_value(value)));

        let unspent_locked =
            rpc_zlistunspent(&chainstate, &mempool, &wallet, Vec::new(), &params).expect("rpc");
        let list = unspent_locked.as_array().expect("array");
        assert_eq!(list.len(), 1);

        let received_locked =
            rpc_zlistreceivedbyaddress(&chainstate, &wallet, vec![json!(zaddr)], &params)
                .expect("rpc");
        let list = received_locked.as_array().expect("array");
        assert_eq!(list.len(), 1);

        {
            let guard = wallet.lock().expect("wallet lock");
            let note = guard
                .sapling_note_map()
                .get(&(shield_txid, 0))
                .expect("sapling note record");
            assert_eq!(
                note.rseed,
                Some(crate::wallet::SaplingRseedBytes::AfterZip212(rseed))
            );
        }

        drop(wallet);
        let wallet_reload = Wallet::load_or_create(&data_dir, params.network).expect("wallet");
        let note = wallet_reload
            .sapling_note_map()
            .get(&(shield_txid, 0))
            .expect("sapling note record");
        assert_eq!(
            note.rseed,
            Some(crate::wallet::SaplingRseedBytes::AfterZip212(rseed))
        );
    }

    #[test]
    fn zlistunspent_and_zlistreceivedbyaddress_mark_sapling_change_by_nullifier_group() {
        let (chainstate, params, data_dir, _taddr, coinbase_txid, coinbase_vout) =
            setup_regtest_chain_with_p2pkh_utxo();
        extend_regtest_chain_to_height(&chainstate, &params, COINBASE_MATURITY);

        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let zaddr1 = rpc_zgetnewaddress(&chainstate, &wallet, Vec::new(), &params)
            .expect("rpc")
            .as_str()
            .expect("zaddr string")
            .to_string();

        let (zaddr2, addr2_bytes) = {
            let seed = [42u8; 32];
            let extsk = sapling_crypto::zip32::ExtendedSpendingKey::master(&seed);
            let extsk_bytes = extsk.to_bytes();
            {
                let mut guard = wallet.lock().expect("wallet lock");
                let imported = guard
                    .import_sapling_extsk(extsk_bytes)
                    .expect("import extsk");
                assert!(imported, "sapling spending key already in wallet");
            }

            #[allow(deprecated)]
            let extfvk = extsk.to_extended_full_viewing_key();
            let dfvk = extfvk.to_diversifiable_full_viewing_key();
            let (_default_index, address) = dfvk.default_address();
            let address_bytes = address.to_bytes();
            let hrp = bech32::Hrp::parse("zregtestsapling").expect("hrp");
            let encoded =
                bech32::encode::<bech32::Bech32>(hrp, address_bytes.as_slice()).expect("encode");
            {
                let guard = wallet.lock().expect("wallet lock");
                assert!(
                    guard
                        .sapling_address_is_mine(&address_bytes)
                        .expect("sapling is mine"),
                    "sapling address derived from imported key should belong to wallet"
                );
            }
            (encoded, address_bytes)
        };

        let addr1_bytes = parse_sapling_zaddr_bytes(&zaddr1, &params).expect("sapling bytes");
        let to1 = PaymentAddress::from_bytes(&addr1_bytes).expect("payment address");
        let to2 = PaymentAddress::from_bytes(&addr2_bytes).expect("payment address");

        let value = block_subsidy(1, &params.consensus);
        let note_value = NoteValue::from_raw(u64::try_from(value).expect("note value"));
        let mut rng = rand::rngs::OsRng;
        let mut rseed = [0u8; 32];
        rng.fill_bytes(&mut rseed);
        let note = to1.create_note(note_value, Rseed::AfterZip212(rseed));

        let enc = sapling_note_encryption(None, note.clone(), [0u8; 512], &mut rng);
        let epk_bytes = <SaplingDomain as Domain>::epk_bytes(enc.epk()).0;

        let output = fluxd_primitives::transaction::OutputDescription {
            cv: [0u8; 32],
            cm: note.cmu().to_bytes(),
            ephemeral_key: epk_bytes,
            enc_ciphertext: enc.encrypt_note_plaintext(),
            out_ciphertext: [0u8; fluxd_primitives::transaction::SAPLING_OUT_CIPHERTEXT_SIZE],
            zkproof: [0u8; fluxd_primitives::transaction::GROTH_PROOF_SIZE],
        };

        let shield_tx = Transaction {
            f_overwintered: true,
            version: 4,
            version_group_id: fluxd_primitives::transaction::SAPLING_VERSION_GROUP_ID,
            vin: vec![TxIn {
                prevout: OutPoint {
                    hash: coinbase_txid,
                    index: coinbase_vout,
                },
                script_sig: Vec::new(),
                sequence: u32::MAX,
            }],
            vout: Vec::new(),
            lock_time: 0,
            expiry_height: 0,
            value_balance: -value,
            shielded_spends: Vec::new(),
            shielded_outputs: vec![output.clone()],
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let shield_txid = shield_tx.txid().expect("txid");

        let flags = ValidationFlags::default();

        let tip = chainstate
            .best_block()
            .expect("best block")
            .expect("best block present");
        let tip_entry = chainstate
            .header_entry(&tip.hash)
            .expect("header entry")
            .expect("header entry present");
        let height = tip.height + 1;
        let spacing = params.consensus.pow_target_spacing.max(1) as u32;
        let time = tip_entry.time.saturating_add(spacing);
        let bits = chainstate
            .next_work_required_bits(&tip.hash, height, time as i64, &params.consensus)
            .expect("next bits");

        let miner_value = block_subsidy(height, &params.consensus);
        let exchange_amount = exchange_fund_amount(height, &params.funding);
        let foundation_amount = foundation_fund_amount(height, &params.funding);
        let swap_amount = swap_pool_amount(height as i64, &params.swap_pool);

        let mut vout = Vec::new();
        vout.push(TxOut {
            value: miner_value,
            script_pubkey: Vec::new(),
        });
        if exchange_amount > 0 {
            let script = address_to_script_pubkey(params.funding.exchange_address, params.network)
                .expect("exchange address script");
            vout.push(TxOut {
                value: exchange_amount,
                script_pubkey: script,
            });
        }
        if foundation_amount > 0 {
            let script =
                address_to_script_pubkey(params.funding.foundation_address, params.network)
                    .expect("foundation address script");
            vout.push(TxOut {
                value: foundation_amount,
                script_pubkey: script,
            });
        }
        if swap_amount > 0 {
            let script = address_to_script_pubkey(params.swap_pool.address, params.network)
                .expect("swap pool address script");
            vout.push(TxOut {
                value: swap_amount,
                script_pubkey: script,
            });
        }
        let coinbase = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: vec![TxIn {
                prevout: OutPoint::null(),
                script_sig: Vec::new(),
                sequence: u32::MAX,
            }],
            vout,
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let coinbase_txid = coinbase.txid().expect("coinbase txid");
        let final_sapling_root = chainstate
            .sapling_root_after_commitments(&[output.cm])
            .expect("sapling root");

        let header = BlockHeader {
            version: CURRENT_VERSION,
            prev_block: tip.hash,
            merkle_root: coinbase_txid,
            final_sapling_root,
            time,
            bits,
            nonce: [0u8; 32],
            solution: Vec::new(),
            nodes_collateral: OutPoint::null(),
            block_sig: Vec::new(),
        };

        let mut header_batch = WriteBatch::new();
        chainstate
            .insert_headers_batch_with_pow(
                &[header.clone()],
                &params.consensus,
                &mut header_batch,
                false,
            )
            .expect("insert header");
        chainstate
            .commit_batch(header_batch)
            .expect("commit header");

        let block = Block {
            header,
            transactions: vec![coinbase, shield_tx],
        };
        let block_bytes = block.consensus_encode().expect("encode block");
        let batch = chainstate
            .connect_block(
                &block,
                height,
                &params,
                &flags,
                true,
                None,
                None,
                Some(block_bytes.as_slice()),
                None,
            )
            .expect("connect block");
        chainstate.commit_batch(batch).expect("commit block");

        let (spend_anchor, spent_nullifier) = {
            let mut guard = wallet.lock().expect("wallet lock");
            guard
                .sync_sapling_notes(&chainstate)
                .expect("sync sapling notes");
            let note = guard
                .sapling_note_map()
                .get(&(shield_txid, 0))
                .expect("sapling note record");
            (
                chainstate.sapling_root().expect("sapling root"),
                note.nullifier,
            )
        };

        let change_amount = 100_000;
        assert!(
            value > change_amount,
            "shielded note value should exceed change amount"
        );
        let send_amount = value - change_amount;

        let send_value = NoteValue::from_raw(u64::try_from(send_amount).expect("send note value"));
        let change_value =
            NoteValue::from_raw(u64::try_from(change_amount).expect("change note value"));

        let mut send_rseed = [0u8; 32];
        rng.fill_bytes(&mut send_rseed);
        let send_note = to2.create_note(send_value, Rseed::AfterZip212(send_rseed));
        let send_enc = sapling_note_encryption(None, send_note.clone(), [0u8; 512], &mut rng);
        let send_epk_bytes = <SaplingDomain as Domain>::epk_bytes(send_enc.epk()).0;
        let send_output = fluxd_primitives::transaction::OutputDescription {
            cv: [0u8; 32],
            cm: send_note.cmu().to_bytes(),
            ephemeral_key: send_epk_bytes,
            enc_ciphertext: send_enc.encrypt_note_plaintext(),
            out_ciphertext: [0u8; fluxd_primitives::transaction::SAPLING_OUT_CIPHERTEXT_SIZE],
            zkproof: [0u8; fluxd_primitives::transaction::GROTH_PROOF_SIZE],
        };

        let mut change_rseed = [0u8; 32];
        rng.fill_bytes(&mut change_rseed);
        let change_note = to1.create_note(change_value, Rseed::AfterZip212(change_rseed));
        let change_enc = sapling_note_encryption(None, change_note.clone(), [0u8; 512], &mut rng);
        let change_epk_bytes = <SaplingDomain as Domain>::epk_bytes(change_enc.epk()).0;
        let change_output = fluxd_primitives::transaction::OutputDescription {
            cv: [0u8; 32],
            cm: change_note.cmu().to_bytes(),
            ephemeral_key: change_epk_bytes,
            enc_ciphertext: change_enc.encrypt_note_plaintext(),
            out_ciphertext: [0u8; fluxd_primitives::transaction::SAPLING_OUT_CIPHERTEXT_SIZE],
            zkproof: [0u8; fluxd_primitives::transaction::GROTH_PROOF_SIZE],
        };

        let spend_desc = fluxd_primitives::transaction::SpendDescription {
            cv: [0u8; 32],
            anchor: spend_anchor,
            nullifier: spent_nullifier,
            rk: [0u8; 32],
            zkproof: [0u8; fluxd_primitives::transaction::GROTH_PROOF_SIZE],
            spend_auth_sig: [0u8; 64],
        };

        let spend_tx = Transaction {
            f_overwintered: true,
            version: 4,
            version_group_id: fluxd_primitives::transaction::SAPLING_VERSION_GROUP_ID,
            vin: Vec::new(),
            vout: Vec::new(),
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: vec![spend_desc],
            shielded_outputs: vec![send_output.clone(), change_output.clone()],
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let spend_txid = spend_tx.txid().expect("spend txid");

        let tip = chainstate
            .best_block()
            .expect("best block")
            .expect("best block present");
        let tip_entry = chainstate
            .header_entry(&tip.hash)
            .expect("header entry")
            .expect("header entry present");
        let height = tip.height + 1;
        let time = tip_entry.time.saturating_add(spacing);
        let bits = chainstate
            .next_work_required_bits(&tip.hash, height, time as i64, &params.consensus)
            .expect("next bits");

        let miner_value = block_subsidy(height, &params.consensus);
        let exchange_amount = exchange_fund_amount(height, &params.funding);
        let foundation_amount = foundation_fund_amount(height, &params.funding);
        let swap_amount = swap_pool_amount(height as i64, &params.swap_pool);

        let mut vout = Vec::new();
        vout.push(TxOut {
            value: miner_value,
            script_pubkey: Vec::new(),
        });
        if exchange_amount > 0 {
            let script = address_to_script_pubkey(params.funding.exchange_address, params.network)
                .expect("exchange address script");
            vout.push(TxOut {
                value: exchange_amount,
                script_pubkey: script,
            });
        }
        if foundation_amount > 0 {
            let script =
                address_to_script_pubkey(params.funding.foundation_address, params.network)
                    .expect("foundation address script");
            vout.push(TxOut {
                value: foundation_amount,
                script_pubkey: script,
            });
        }
        if swap_amount > 0 {
            let script = address_to_script_pubkey(params.swap_pool.address, params.network)
                .expect("swap pool address script");
            vout.push(TxOut {
                value: swap_amount,
                script_pubkey: script,
            });
        }
        let coinbase = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: vec![TxIn {
                prevout: OutPoint::null(),
                script_sig: Vec::new(),
                sequence: u32::MAX,
            }],
            vout,
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let coinbase_txid = coinbase.txid().expect("coinbase txid");
        let final_sapling_root = chainstate
            .sapling_root_after_commitments(&[send_output.cm, change_output.cm])
            .expect("sapling root");

        let header = BlockHeader {
            version: CURRENT_VERSION,
            prev_block: tip.hash,
            merkle_root: coinbase_txid,
            final_sapling_root,
            time,
            bits,
            nonce: [0u8; 32],
            solution: Vec::new(),
            nodes_collateral: OutPoint::null(),
            block_sig: Vec::new(),
        };

        let mut header_batch = WriteBatch::new();
        chainstate
            .insert_headers_batch_with_pow(
                &[header.clone()],
                &params.consensus,
                &mut header_batch,
                false,
            )
            .expect("insert header");
        chainstate
            .commit_batch(header_batch)
            .expect("commit header");

        let block = Block {
            header,
            transactions: vec![coinbase, spend_tx],
        };
        let block_bytes = block.consensus_encode().expect("encode block");
        let batch = chainstate
            .connect_block(
                &block,
                height,
                &params,
                &flags,
                true,
                None,
                None,
                Some(block_bytes.as_slice()),
                None,
            )
            .expect("connect block");
        chainstate.commit_batch(batch).expect("commit block");

        let mempool = Mutex::new(Mempool::new(0));
        let unspent = rpc_zlistunspent(
            &chainstate,
            &mempool,
            &wallet,
            vec![
                Value::Null,
                Value::Null,
                Value::Null,
                json!([zaddr1.clone(), zaddr2.clone()]),
            ],
            &params,
        )
        .expect("rpc");
        let list = unspent.as_array().expect("array");

        let addr1_entry = list
            .iter()
            .find(|entry| entry.get("address").and_then(Value::as_str) == Some(zaddr1.as_str()))
            .and_then(Value::as_object)
            .expect("zaddr1 entry");
        assert_eq!(
            addr1_entry.get("amountZat").and_then(Value::as_i64),
            Some(change_amount)
        );
        assert_eq!(
            addr1_entry.get("change").and_then(Value::as_bool),
            Some(true)
        );

        let addr2_entry = list
            .iter()
            .find(|entry| entry.get("address").and_then(Value::as_str) == Some(zaddr2.as_str()))
            .and_then(Value::as_object)
            .expect("zaddr2 entry");
        assert_eq!(
            addr2_entry.get("amountZat").and_then(Value::as_i64),
            Some(send_amount)
        );
        assert_eq!(
            addr2_entry.get("change").and_then(Value::as_bool),
            Some(false)
        );
        assert_eq!(list.len(), 2);

        let received =
            rpc_zlistreceivedbyaddress(&chainstate, &wallet, vec![json!(zaddr1.clone())], &params)
                .expect("rpc");
        let list = received.as_array().expect("array");
        assert_eq!(list.len(), 2);

        let shield_txid_hex = hash256_to_hex(&shield_txid);
        let spend_txid_hex = hash256_to_hex(&spend_txid);
        let original_entry = list
            .iter()
            .find(|entry| {
                entry.get("txid").and_then(Value::as_str) == Some(shield_txid_hex.as_str())
                    && entry.get("outindex").and_then(Value::as_u64) == Some(0)
            })
            .and_then(Value::as_object)
            .expect("original note entry");
        assert_eq!(
            original_entry.get("change").and_then(Value::as_bool),
            Some(false)
        );
        assert_eq!(
            original_entry.get("spent").and_then(Value::as_bool),
            Some(true)
        );

        let change_entry = list
            .iter()
            .find(|entry| {
                entry.get("txid").and_then(Value::as_str) == Some(spend_txid_hex.as_str())
                    && entry.get("outindex").and_then(Value::as_u64) == Some(1)
            })
            .and_then(Value::as_object)
            .expect("change note entry");
        assert_eq!(
            change_entry.get("amountZat").and_then(Value::as_i64),
            Some(change_amount)
        );
        assert_eq!(
            change_entry.get("change").and_then(Value::as_bool),
            Some(true)
        );
        assert_eq!(
            change_entry.get("spent").and_then(Value::as_bool),
            Some(false)
        );

        let received =
            rpc_zlistreceivedbyaddress(&chainstate, &wallet, vec![json!(zaddr2.clone())], &params)
                .expect("rpc");
        let list = received.as_array().expect("array");
        assert_eq!(list.len(), 1);
        let entry = list[0].as_object().expect("object");
        assert_eq!(
            entry.get("txid").and_then(Value::as_str),
            Some(spend_txid_hex.as_str())
        );
        assert_eq!(entry.get("outindex").and_then(Value::as_u64), Some(0));
        assert_eq!(
            entry.get("amountZat").and_then(Value::as_i64),
            Some(send_amount)
        );
        assert_eq!(entry.get("change").and_then(Value::as_bool), Some(false));
        assert_eq!(entry.get("spent").and_then(Value::as_bool), Some(false));
    }

    #[test]
    fn zgetbalance_supports_watchonly_transparent_addresses() {
        let (chainstate, params, data_dir, taddr, _coinbase_txid, _coinbase_vout) =
            setup_regtest_chain_with_p2pkh_utxo();
        extend_regtest_chain_to_height(&chainstate, &params, COINBASE_MATURITY);

        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));
        rpc_importaddress(
            &chainstate,
            &wallet,
            vec![json!(taddr), Value::Null, json!(false)],
            &params,
        )
        .expect("importaddress");

        let mempool = Mutex::new(Mempool::new(0));
        let balance = rpc_zgetbalance(&chainstate, &mempool, &wallet, vec![json!(taddr)], &params)
            .expect("rpc");
        assert_eq!(
            balance,
            amount_to_value(block_subsidy(1, &params.consensus))
        );
    }

    #[test]
    fn zsendmany_recipients_rejects_memo_for_transparent_address() {
        let (_chainstate, params, _data_dir) = setup_regtest_chainstate();
        let taddr = script_pubkey_to_address(&p2pkh_script([0x11u8; 20]), params.network)
            .expect("p2pkh address");
        let recipients = json!([{
            "address": taddr,
            "amount": "0.01",
            "memo": "00",
        }]);
        let err = match parse_zsendmany_recipients(&recipients, &params) {
            Ok(_) => panic!("expected error"),
            Err(err) => err,
        };
        assert_eq!(err.code, RPC_INVALID_PARAMETER);
        assert!(err.message.contains("memo is only supported"));
    }

    #[test]
    fn zsendmany_recipients_rejects_duplicate_addresses() {
        let (_chainstate, params, _data_dir) = setup_regtest_chainstate();
        let taddr = script_pubkey_to_address(&p2pkh_script([0x22u8; 20]), params.network)
            .expect("p2pkh address");
        let recipients = json!([
            {"address": taddr, "amount": "0.01"},
            {"address": taddr, "amount": "0.02"},
        ]);
        let err = match parse_zsendmany_recipients(&recipients, &params) {
            Ok(_) => panic!("expected error"),
            Err(err) => err,
        };
        assert_eq!(err.code, RPC_INVALID_PARAMETER);
        assert!(err.message.contains("duplicated address"));
    }

    #[test]
    fn zsendmany_recipients_accepts_sapling_memo_hex() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));
        let zaddr = rpc_zgetnewaddress(&chainstate, &wallet, Vec::new(), &params)
            .expect("rpc")
            .as_str()
            .expect("zaddr")
            .to_string();

        let recipients = json!([{
            "address": zaddr,
            "amount": "0.01",
            "memo": "00",
        }]);
        parse_zsendmany_recipients(&recipients, &params).expect("recipients");
    }

    #[test]
    fn zsendmany_recipients_rejects_memo_larger_than_512_bytes() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));
        let zaddr = rpc_zgetnewaddress(&chainstate, &wallet, Vec::new(), &params)
            .expect("rpc")
            .as_str()
            .expect("zaddr")
            .to_string();

        let memo = "00".repeat(513);
        let recipients = json!([{
            "address": zaddr,
            "amount": "0.01",
            "memo": memo,
        }]);
        let err = match parse_zsendmany_recipients(&recipients, &params) {
            Ok(_) => panic!("expected error"),
            Err(err) => err,
        };
        assert_eq!(err.code, RPC_INVALID_PARAMETER);
        assert!(err.message.contains("Memo size is larger"));
    }

    #[test]
    fn zsendmany_execute_rejects_insufficient_funds_after_sapling_activation() {
        let (chainstate, params, data_dir, _taddr, _coinbase_txid, _coinbase_vout) =
            setup_testnet_chain_with_p2pkh_utxo();
        let sapling_height =
            params.consensus.upgrades[UpgradeIndex::Acadia.as_usize()].activation_height;
        extend_regtest_chain_to_height(&chainstate, &params, sapling_height.max(1));

        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));
        let from_bytes = {
            let mut guard = wallet.lock().expect("wallet lock");
            guard
                .generate_new_sapling_address_bytes()
                .expect("sapling address bytes")
        };

        let recipients = vec![ZSendRecipient {
            dest: ZSendDest::Transparent(TransparentAddress::PublicKeyHash([0x22u8; 20])),
            amount: 1_000_000,
        }];
        let mempool = Mutex::new(Mempool::new(0));
        let mempool_policy = MempoolPolicy::standard(0, false);
        let mempool_metrics = MempoolMetrics::default();
        let fee_estimator = Mutex::new(FeeEstimator::new(1024));
        let flags = ValidationFlags::default();
        let (tx_announce, _rx) = tokio::sync::broadcast::channel(16);
        let params_dir = fluxd_shielded::default_params_dir();

        let err = zsendmany_execute(
            &chainstate,
            &mempool,
            &mempool_policy,
            &mempool_metrics,
            &fee_estimator,
            &flags,
            &params,
            &params_dir,
            &tx_announce,
            &wallet,
            from_bytes,
            &recipients,
            1,
            10_000,
        )
        .expect_err("err");
        assert_eq!(err.code, RPC_WALLET_ERROR);
        assert!(err.message.contains("insufficient funds"));
    }

    #[test]
    #[ignore]
    fn zsendmany_spends_sapling_note_to_transparent_output() {
        let (chainstate, params, data_dir, _taddr, coinbase_txid, coinbase_vout) =
            setup_testnet_chain_with_p2pkh_utxo();
        let sapling_height =
            params.consensus.upgrades[UpgradeIndex::Acadia.as_usize()].activation_height;
        extend_regtest_chain_to_height(&chainstate, &params, sapling_height.max(COINBASE_MATURITY));

        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));
        let from_bytes = {
            let mut guard = wallet.lock().expect("wallet lock");
            guard
                .generate_new_sapling_address_bytes()
                .expect("sapling address bytes")
        };
        let to = PaymentAddress::from_bytes(&from_bytes).expect("payment address");

        let value = block_subsidy(1, &params.consensus);
        let note_value = NoteValue::from_raw(u64::try_from(value).expect("note value"));
        let mut rng = rand::rngs::OsRng;
        let mut rseed = [0u8; 32];
        rng.fill_bytes(&mut rseed);
        let note = to.create_note(note_value, Rseed::AfterZip212(rseed));

        let enc = sapling_note_encryption(None, note.clone(), [0u8; 512], &mut rng);
        let epk_bytes = <SaplingDomain as Domain>::epk_bytes(enc.epk()).0;

        let output = fluxd_primitives::transaction::OutputDescription {
            cv: [0u8; 32],
            cm: note.cmu().to_bytes(),
            ephemeral_key: epk_bytes,
            enc_ciphertext: enc.encrypt_note_plaintext(),
            out_ciphertext: [0u8; fluxd_primitives::transaction::SAPLING_OUT_CIPHERTEXT_SIZE],
            zkproof: [0u8; fluxd_primitives::transaction::GROTH_PROOF_SIZE],
        };

        let shield_tx = Transaction {
            f_overwintered: true,
            version: 4,
            version_group_id: fluxd_primitives::transaction::SAPLING_VERSION_GROUP_ID,
            vin: vec![TxIn {
                prevout: OutPoint {
                    hash: coinbase_txid,
                    index: coinbase_vout,
                },
                script_sig: Vec::new(),
                sequence: u32::MAX,
            }],
            vout: Vec::new(),
            lock_time: 0,
            expiry_height: 0,
            value_balance: -value,
            shielded_spends: Vec::new(),
            shielded_outputs: vec![output.clone()],
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let shield_txid = shield_tx.txid().expect("txid");

        let tip = chainstate
            .best_block()
            .expect("best block")
            .expect("best block present");
        let tip_entry = chainstate
            .header_entry(&tip.hash)
            .expect("header entry")
            .expect("header entry present");
        let height = tip.height + 1;
        let spacing = params.consensus.pow_target_spacing.max(1) as u32;
        let time = tip_entry.time.saturating_add(spacing);
        let bits = chainstate
            .next_work_required_bits(&tip.hash, height, time as i64, &params.consensus)
            .expect("next bits");

        let miner_value = block_subsidy(height, &params.consensus);
        let exchange_amount = exchange_fund_amount(height, &params.funding);
        let foundation_amount = foundation_fund_amount(height, &params.funding);
        let swap_amount = swap_pool_amount(height as i64, &params.swap_pool);

        let mut vout = Vec::new();
        vout.push(TxOut {
            value: miner_value,
            script_pubkey: Vec::new(),
        });
        if exchange_amount > 0 {
            let script = address_to_script_pubkey(params.funding.exchange_address, params.network)
                .expect("exchange address script");
            vout.push(TxOut {
                value: exchange_amount,
                script_pubkey: script,
            });
        }
        if foundation_amount > 0 {
            let script =
                address_to_script_pubkey(params.funding.foundation_address, params.network)
                    .expect("foundation address script");
            vout.push(TxOut {
                value: foundation_amount,
                script_pubkey: script,
            });
        }
        if swap_amount > 0 {
            let script = address_to_script_pubkey(params.swap_pool.address, params.network)
                .expect("swap pool address script");
            vout.push(TxOut {
                value: swap_amount,
                script_pubkey: script,
            });
        }
        let coinbase = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: vec![TxIn {
                prevout: OutPoint::null(),
                script_sig: Vec::new(),
                sequence: u32::MAX,
            }],
            vout,
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let coinbase_txid = coinbase.txid().expect("coinbase txid");
        let final_sapling_root = chainstate
            .sapling_root_after_commitments(&[output.cm])
            .expect("sapling root");

        let header = BlockHeader {
            version: CURRENT_VERSION,
            prev_block: tip.hash,
            merkle_root: coinbase_txid,
            final_sapling_root,
            time,
            bits,
            nonce: [0u8; 32],
            solution: Vec::new(),
            nodes_collateral: OutPoint::null(),
            block_sig: Vec::new(),
        };

        let mut header_batch = WriteBatch::new();
        chainstate
            .insert_headers_batch_with_pow(
                &[header.clone()],
                &params.consensus,
                &mut header_batch,
                false,
            )
            .expect("insert header");
        chainstate
            .commit_batch(header_batch)
            .expect("commit header");

        let block = Block {
            header,
            transactions: vec![coinbase, shield_tx],
        };
        let block_bytes = block.consensus_encode().expect("encode block");
        let flags = ValidationFlags::default();
        let batch = chainstate
            .connect_block(
                &block,
                height,
                &params,
                &flags,
                true,
                None,
                None,
                Some(block_bytes.as_slice()),
                None,
            )
            .expect("connect block");
        chainstate.commit_batch(batch).expect("commit block");

        let mempool = Mutex::new(Mempool::new(0));
        let mempool_policy = MempoolPolicy::standard(0, false);
        let mempool_metrics = MempoolMetrics::default();
        let fee_estimator = Mutex::new(FeeEstimator::new(1024));
        let (tx_announce, _rx) = tokio::sync::broadcast::channel(16);
        let params_dir = fluxd_shielded::default_params_dir();

        let script_pubkey = p2pkh_script([0x22u8; 20]);
        let address =
            script_pubkey_to_address(&script_pubkey, params.network).expect("p2pkh address");
        let dest = transparent_address_from_flux_address(&address, params.network)
            .expect("transparent addr");

        let fee = 10_000;
        let recipients = vec![ZSendRecipient {
            dest: ZSendDest::Transparent(dest),
            amount: value - fee,
        }];

        let txid = zsendmany_execute(
            &chainstate,
            &mempool,
            &mempool_policy,
            &mempool_metrics,
            &fee_estimator,
            &flags,
            &params,
            &params_dir,
            &tx_announce,
            &wallet,
            from_bytes,
            &recipients,
            1,
            fee,
        )
        .expect("zsendmany execute");

        assert!(mempool.lock().expect("mempool lock").contains(&txid));
        assert!(chainstate
            .tx_location(&shield_txid)
            .expect("tx index read")
            .is_some());
    }

    #[test]
    fn shielded_operation_rpcs_return_empty_lists() {
        let value = rpc_zlistoperationids(Vec::new()).expect("rpc");
        assert_eq!(value.as_array().map(Vec::len), Some(0));

        let value = rpc_zlistoperationids(vec![json!("all")]).expect("rpc");
        assert_eq!(value.as_array().map(Vec::len), Some(0));

        let value = rpc_zgetoperationstatus(Vec::new()).expect("rpc");
        assert_eq!(value.as_array().map(Vec::len), Some(0));

        let value = rpc_zgetoperationstatus(vec![json!(["opid1", "opid2"])]).expect("rpc");
        assert_eq!(value.as_array().map(Vec::len), Some(0));

        let err = rpc_zgetoperationstatus(vec![json!("opid")]).expect_err("err");
        assert_eq!(err.code, RPC_INVALID_PARAMETER);

        let value = rpc_zgetoperationresult(Vec::new()).expect("rpc");
        assert_eq!(value.as_array().map(Vec::len), Some(0));

        let value = rpc_zgetoperationresult(vec![json!(["opid1"])]).expect("rpc");
        assert_eq!(value.as_array().map(Vec::len), Some(0));

        let err = rpc_zgetoperationresult(vec![json!("opid")]).expect_err("err");
        assert_eq!(err.code, RPC_INVALID_PARAMETER);
    }

    #[test]
    fn migration_rpcs_are_structured_and_deprecated() {
        let status = rpc_zgetmigrationstatus(Vec::new()).expect("rpc");
        let obj = status.as_object().expect("object");
        assert_eq!(obj.get("enabled").and_then(Value::as_bool), Some(false));
        for key in [
            "unmigrated_amount",
            "unfinalized_migrated_amount",
            "finalized_migrated_amount",
        ] {
            assert_eq!(obj.get(key).and_then(Value::as_str), Some("0.00000000"));
        }
        assert_eq!(
            obj.get("finalized_migration_transactions")
                .and_then(Value::as_i64),
            Some(0)
        );
        let txids = obj
            .get("migration_txids")
            .and_then(Value::as_array)
            .expect("migration_txids array");
        assert!(txids.is_empty());

        let err = rpc_zsetmigration(vec![json!(true)]).expect_err("err");
        assert_eq!(err.code, RPC_MISC_ERROR);

        let err = rpc_zshieldcoinbase(Vec::new()).expect_err("err");
        assert_eq!(err.code, RPC_MISC_ERROR);
    }

    #[test]
    fn decodescript_has_cpp_schema_keys() {
        let (_chainstate, params, _data_dir) = setup_regtest_chainstate();
        let script = p2pkh_script([0x55u8; 20]);
        let hex = hex_bytes(&script);
        let value = rpc_decodescript(vec![Value::String(hex)], &params).expect("rpc");
        let obj = value.as_object().expect("object");
        for key in ["asm", "hex", "type", "p2sh"] {
            assert!(obj.contains_key(key), "missing key {key}");
        }
    }

    #[test]
    fn createrawtransaction_and_decoderawtransaction_have_cpp_schema() {
        let (chainstate, params, _data_dir) = setup_regtest_chainstate();
        let address =
            script_pubkey_to_address(&p2pkh_script([0x44u8; 20]), params.network).expect("address");

        let mut outputs = serde_json::Map::new();
        outputs.insert(address, json!("1.0"));

        let raw_hex = rpc_createrawtransaction(
            &chainstate,
            vec![Value::Array(Vec::new()), Value::Object(outputs)],
            &params,
        )
        .expect("rpc")
        .as_str()
        .expect("hex string")
        .to_string();
        assert!(bytes_from_hex(&raw_hex).is_some(), "invalid hex");

        let decoded = rpc_decoderawtransaction(vec![Value::String(raw_hex)], &params).expect("rpc");
        let obj = decoded.as_object().expect("object");
        for key in [
            "txid",
            "version",
            "size",
            "overwintered",
            "locktime",
            "vin",
            "vout",
        ] {
            assert!(obj.contains_key(key), "missing key {key}");
        }
        let txid = obj.get("txid").and_then(Value::as_str).unwrap_or("");
        assert!(is_hex_64(txid));
    }

    #[test]
    fn sendrawtransaction_rejects_invalid_hex() {
        let (chainstate, params, _data_dir) = setup_regtest_chainstate();
        let mempool = Mutex::new(Mempool::new(0));
        let mempool_policy = MempoolPolicy::standard(0, false);
        let mempool_metrics = MempoolMetrics::default();
        let fee_estimator = Mutex::new(FeeEstimator::new(128));
        let mempool_flags = ValidationFlags::default();
        let (tx_announce, _rx) = broadcast::channel(16);

        let err = rpc_sendrawtransaction(
            &chainstate,
            &mempool,
            &mempool_policy,
            &mempool_metrics,
            &fee_estimator,
            &mempool_flags,
            vec![Value::String("zz".to_string())],
            &params,
            &tx_announce,
        )
        .unwrap_err();
        assert_eq!(err.code, RPC_DESERIALIZATION_ERROR);
    }

    #[test]
    fn sendrawtransaction_rejects_missing_inputs() {
        let (chainstate, params, _data_dir) = setup_regtest_chainstate();
        let mempool = Mutex::new(Mempool::new(0));
        let mempool_policy = MempoolPolicy::standard(0, false);
        let mempool_metrics = MempoolMetrics::default();
        let fee_estimator = Mutex::new(FeeEstimator::new(128));
        let mempool_flags = ValidationFlags::default();
        let (tx_announce, _rx) = broadcast::channel(16);

        let tx = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: vec![TxIn {
                prevout: OutPoint {
                    hash: [0x33u8; 32],
                    index: 0,
                },
                script_sig: Vec::new(),
                sequence: u32::MAX,
            }],
            vout: vec![TxOut {
                value: 1_000,
                script_pubkey: vec![0x51],
            }],
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let raw_hex = hex_bytes(&tx.consensus_encode().expect("encode tx"));

        let err = rpc_sendrawtransaction(
            &chainstate,
            &mempool,
            &mempool_policy,
            &mempool_metrics,
            &fee_estimator,
            &mempool_flags,
            vec![Value::String(raw_hex)],
            &params,
            &tx_announce,
        )
        .unwrap_err();
        assert_eq!(err.code, RPC_TRANSACTION_ERROR);
    }

    #[test]
    fn sendrawtransaction_accepts_tx_with_injected_utxo() {
        let (chainstate, params, _data_dir) = setup_regtest_chainstate();
        let mempool = Mutex::new(Mempool::new(0));
        let mempool_policy = MempoolPolicy::standard(0, false);
        let mempool_metrics = MempoolMetrics::default();
        let fee_estimator = Mutex::new(FeeEstimator::new(128));
        let mempool_flags = ValidationFlags::default();
        let (tx_announce, _rx) = broadcast::channel(16);

        let prevout = OutPoint {
            hash: [0x55u8; 32],
            index: 0,
        };
        let prev_entry = fluxd_chainstate::utxo::UtxoEntry {
            value: 10_000,
            script_pubkey: vec![0x51],
            height: 0,
            is_coinbase: false,
        };
        let key = fluxd_chainstate::utxo::outpoint_key_bytes(&prevout);
        let mut batch = WriteBatch::new();
        batch.put(Column::Utxo, key.as_bytes(), prev_entry.encode());
        chainstate.commit_batch(batch).expect("commit utxo");

        let tx = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: vec![TxIn {
                prevout: prevout.clone(),
                script_sig: Vec::new(),
                sequence: u32::MAX,
            }],
            vout: vec![TxOut {
                value: 10_000,
                script_pubkey: vec![0x51],
            }],
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let raw_hex = hex_bytes(&tx.consensus_encode().expect("encode tx"));

        let value = rpc_sendrawtransaction(
            &chainstate,
            &mempool,
            &mempool_policy,
            &mempool_metrics,
            &fee_estimator,
            &mempool_flags,
            vec![Value::String(raw_hex)],
            &params,
            &tx_announce,
        )
        .expect("rpc");

        let txid = value.as_str().expect("txid string");
        assert!(is_hex_64(txid));
    }

    #[test]
    fn sendrawtransaction_accepts_zero_fee_with_minrelaytxfee() {
        let (chainstate, params, _data_dir) = setup_regtest_chainstate();
        let mempool = Mutex::new(Mempool::new(0));
        let mempool_policy = MempoolPolicy::standard(100, false);
        let mempool_metrics = MempoolMetrics::default();
        let fee_estimator = Mutex::new(FeeEstimator::new(128));
        let mempool_flags = ValidationFlags::default();
        let (tx_announce, _rx) = broadcast::channel(16);

        let prevout = OutPoint {
            hash: [0x5au8; 32],
            index: 0,
        };
        let prev_entry = fluxd_chainstate::utxo::UtxoEntry {
            value: 10_000,
            script_pubkey: vec![0x51],
            height: 0,
            is_coinbase: false,
        };
        let key = fluxd_chainstate::utxo::outpoint_key_bytes(&prevout);
        let mut batch = WriteBatch::new();
        batch.put(Column::Utxo, key.as_bytes(), prev_entry.encode());
        chainstate.commit_batch(batch).expect("commit utxo");

        let tx = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: vec![TxIn {
                prevout: prevout.clone(),
                script_sig: Vec::new(),
                sequence: u32::MAX,
            }],
            vout: vec![TxOut {
                value: 10_000,
                script_pubkey: vec![0x51],
            }],
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let raw_hex = hex_bytes(&tx.consensus_encode().expect("encode tx"));

        let value = rpc_sendrawtransaction(
            &chainstate,
            &mempool,
            &mempool_policy,
            &mempool_metrics,
            &fee_estimator,
            &mempool_flags,
            vec![Value::String(raw_hex)],
            &params,
            &tx_announce,
        )
        .expect("rpc");

        let txid = value.as_str().expect("txid string");
        assert!(is_hex_64(txid));
    }

    #[test]
    fn mempool_reprocesses_orphan_after_parent_accept() {
        let (chainstate, params, _data_dir) = setup_regtest_chainstate();
        let mempool = Mutex::new(Mempool::new(0));
        let mempool_policy = MempoolPolicy::standard(0, false);
        let flags = ValidationFlags::default();

        let funding_prevout = OutPoint {
            hash: [0x11u8; 32],
            index: 0,
        };
        let funding_entry = fluxd_chainstate::utxo::UtxoEntry {
            value: 10_000,
            script_pubkey: vec![0x51],
            height: 0,
            is_coinbase: false,
        };
        let key = fluxd_chainstate::utxo::outpoint_key_bytes(&funding_prevout);
        let mut batch = WriteBatch::new();
        batch.put(Column::Utxo, key.as_bytes(), funding_entry.encode());
        chainstate.commit_batch(batch).expect("commit utxo");

        let parent_tx = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: vec![TxIn {
                prevout: funding_prevout.clone(),
                script_sig: Vec::new(),
                sequence: u32::MAX,
            }],
            vout: vec![TxOut {
                value: 9_000,
                script_pubkey: vec![0x51],
            }],
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let parent_raw = parent_tx.consensus_encode().expect("encode tx");
        let parent_txid = parent_tx.txid().expect("txid");

        let child_prevout = OutPoint {
            hash: parent_txid,
            index: 0,
        };
        let child_tx = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: vec![TxIn {
                prevout: child_prevout,
                script_sig: Vec::new(),
                sequence: u32::MAX,
            }],
            vout: vec![TxOut {
                value: 8_000,
                script_pubkey: vec![0x51],
            }],
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let child_raw = child_tx.consensus_encode().expect("encode tx");
        let child_txid = child_tx.txid().expect("txid");

        let child_prevouts = mempool
            .lock()
            .expect("mempool lock")
            .prevouts_for_tx(&child_tx);
        let err = match build_mempool_entry(
            &chainstate,
            &child_prevouts,
            &params,
            &flags,
            &mempool_policy,
            child_tx,
            child_raw.clone(),
            true,
        ) {
            Ok(_) => panic!("expected missing input"),
            Err(err) => err,
        };
        assert_eq!(err.kind, MempoolErrorKind::MissingInput);
        mempool.lock().expect("mempool lock").store_orphan(
            child_txid,
            child_raw,
            err.missing_inputs,
            true,
        );
        assert_eq!(
            mempool.lock().expect("mempool lock").orphan_count(),
            1,
            "orphan not stored"
        );

        let parent_prevouts = mempool
            .lock()
            .expect("mempool lock")
            .prevouts_for_tx(&parent_tx);
        let parent_entry = build_mempool_entry(
            &chainstate,
            &parent_prevouts,
            &params,
            &flags,
            &mempool_policy,
            parent_tx,
            parent_raw,
            true,
        )
        .expect("parent entry");
        mempool
            .lock()
            .expect("mempool lock")
            .insert(parent_entry)
            .expect("insert parent");

        let outcome = crate::mempool::process_orphans_after_accept(
            &chainstate,
            &params,
            &mempool,
            &mempool_policy,
            &flags,
            parent_txid,
        );
        assert_eq!(outcome.accepted.len(), 1);
        assert_eq!(outcome.accepted[0].txid, child_txid);

        let guard = mempool.lock().expect("mempool lock");
        assert!(guard.contains(&child_txid));
        assert_eq!(guard.orphan_count(), 0);
    }

    #[test]
    fn sendrawtransaction_allowhighfees_toggles_absurd_fee_rejection() {
        let (chainstate, params, _data_dir) = setup_regtest_chainstate();
        let mempool = Mutex::new(Mempool::new(0));
        let mempool_policy = MempoolPolicy::standard(100, false);
        let mempool_metrics = MempoolMetrics::default();
        let fee_estimator = Mutex::new(FeeEstimator::new(128));
        let mempool_flags = ValidationFlags::default();
        let (tx_announce, _rx) = broadcast::channel(16);

        let prevout = OutPoint {
            hash: [0x5bu8; 32],
            index: 0,
        };
        let prev_entry = fluxd_chainstate::utxo::UtxoEntry {
            value: 2_000_000,
            script_pubkey: vec![0x51],
            height: 0,
            is_coinbase: false,
        };
        let key = fluxd_chainstate::utxo::outpoint_key_bytes(&prevout);
        let mut batch = WriteBatch::new();
        batch.put(Column::Utxo, key.as_bytes(), prev_entry.encode());
        chainstate.commit_batch(batch).expect("commit utxo");

        let tx = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: vec![TxIn {
                prevout: prevout.clone(),
                script_sig: Vec::new(),
                sequence: u32::MAX,
            }],
            vout: vec![TxOut {
                value: 1,
                script_pubkey: vec![0x51],
            }],
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let raw_hex = hex_bytes(&tx.consensus_encode().expect("encode tx"));

        let err = rpc_sendrawtransaction(
            &chainstate,
            &mempool,
            &mempool_policy,
            &mempool_metrics,
            &fee_estimator,
            &mempool_flags,
            vec![Value::String(raw_hex.clone())],
            &params,
            &tx_announce,
        )
        .unwrap_err();
        assert_eq!(err.code, RPC_TRANSACTION_ERROR);
        assert!(
            err.message
                .starts_with("AcceptToMemoryPool: absurdly high fees"),
            "unexpected message: {}",
            err.message
        );

        let value = rpc_sendrawtransaction(
            &chainstate,
            &mempool,
            &mempool_policy,
            &mempool_metrics,
            &fee_estimator,
            &mempool_flags,
            vec![Value::String(raw_hex), Value::Bool(true)],
            &params,
            &tx_announce,
        )
        .expect("rpc");

        let txid = value.as_str().expect("txid string");
        assert!(is_hex_64(txid));
    }

    #[test]
    fn sendrawtransaction_conflicting_input_returns_cpp_reject_reason() {
        let (chainstate, params, _data_dir) = setup_regtest_chainstate();
        let mempool = Mutex::new(Mempool::new(0));
        let mempool_policy = MempoolPolicy::standard(0, false);
        let mempool_metrics = MempoolMetrics::default();
        let fee_estimator = Mutex::new(FeeEstimator::new(128));
        let mempool_flags = ValidationFlags::default();
        let (tx_announce, _rx) = broadcast::channel(16);

        let prevout = OutPoint {
            hash: [0x66u8; 32],
            index: 0,
        };
        let prev_entry = fluxd_chainstate::utxo::UtxoEntry {
            value: 10_000,
            script_pubkey: vec![0x51],
            height: 0,
            is_coinbase: false,
        };
        let key = fluxd_chainstate::utxo::outpoint_key_bytes(&prevout);
        let mut batch = WriteBatch::new();
        batch.put(Column::Utxo, key.as_bytes(), prev_entry.encode());
        chainstate.commit_batch(batch).expect("commit utxo");

        let tx1 = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: vec![TxIn {
                prevout: prevout.clone(),
                script_sig: Vec::new(),
                sequence: u32::MAX,
            }],
            vout: vec![TxOut {
                value: 10_000,
                script_pubkey: vec![0x51],
            }],
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let raw_hex1 = hex_bytes(&tx1.consensus_encode().expect("encode tx"));
        rpc_sendrawtransaction(
            &chainstate,
            &mempool,
            &mempool_policy,
            &mempool_metrics,
            &fee_estimator,
            &mempool_flags,
            vec![Value::String(raw_hex1)],
            &params,
            &tx_announce,
        )
        .expect("tx1 accepted");

        let tx2 = Transaction {
            vout: vec![TxOut {
                value: 9_999,
                script_pubkey: vec![0x51],
            }],
            ..tx1
        };
        let raw_hex2 = hex_bytes(&tx2.consensus_encode().expect("encode tx"));
        let err = rpc_sendrawtransaction(
            &chainstate,
            &mempool,
            &mempool_policy,
            &mempool_metrics,
            &fee_estimator,
            &mempool_flags,
            vec![Value::String(raw_hex2)],
            &params,
            &tx_announce,
        )
        .unwrap_err();
        assert_eq!(err.code, RPC_TRANSACTION_REJECTED);
        assert_eq!(err.message, "18: bad-txns-inputs-spent");
    }

    #[test]
    fn sendrawtransaction_rejects_expiring_soon_after_acadia() {
        let (chainstate, mut params, _data_dir) = setup_regtest_chainstate();
        params.consensus.upgrades[UpgradeIndex::Acadia.as_usize()].activation_height = 1;

        let mempool = Mutex::new(Mempool::new(0));
        let mempool_policy = MempoolPolicy::standard(0, false);
        let mempool_metrics = MempoolMetrics::default();
        let fee_estimator = Mutex::new(FeeEstimator::new(128));
        let mempool_flags = ValidationFlags::default();
        let (tx_announce, _rx) = broadcast::channel(16);

        let prevout = OutPoint {
            hash: [0x56u8; 32],
            index: 0,
        };
        let prev_entry = fluxd_chainstate::utxo::UtxoEntry {
            value: 10_000,
            script_pubkey: vec![0x51],
            height: 0,
            is_coinbase: false,
        };
        let key = fluxd_chainstate::utxo::outpoint_key_bytes(&prevout);
        let mut batch = WriteBatch::new();
        batch.put(Column::Utxo, key.as_bytes(), prev_entry.encode());
        chainstate.commit_batch(batch).expect("commit utxo");

        let tx = Transaction {
            f_overwintered: true,
            version: 3,
            version_group_id: OVERWINTER_VERSION_GROUP_ID,
            vin: vec![TxIn {
                prevout: prevout.clone(),
                script_sig: Vec::new(),
                sequence: u32::MAX,
            }],
            vout: vec![TxOut {
                value: 9_000,
                script_pubkey: vec![0x51],
            }],
            lock_time: 0,
            expiry_height: 3,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let raw_hex = hex_bytes(&tx.consensus_encode().expect("encode tx"));

        let err = rpc_sendrawtransaction(
            &chainstate,
            &mempool,
            &mempool_policy,
            &mempool_metrics,
            &fee_estimator,
            &mempool_flags,
            vec![Value::String(raw_hex)],
            &params,
            &tx_announce,
        )
        .unwrap_err();
        assert_eq!(err.code, RPC_TRANSACTION_REJECTED);
        assert!(
            err.message.starts_with("tx-expiring-soon:"),
            "unexpected message: {}",
            err.message
        );
    }

    #[test]
    fn sendrawtransaction_reports_already_in_chain() {
        let (chainstate, params, _data_dir) = setup_regtest_chainstate();
        let mempool = Mutex::new(Mempool::new(0));
        let mempool_policy = MempoolPolicy::standard(0, false);
        let mempool_metrics = MempoolMetrics::default();
        let fee_estimator = Mutex::new(FeeEstimator::new(128));
        let mempool_flags = ValidationFlags::default();
        let (tx_announce, _rx) = broadcast::channel(16);

        let genesis_hash = params.consensus.hash_genesis_block;
        let location = chainstate
            .block_location(&genesis_hash)
            .expect("block location")
            .expect("genesis location");
        let bytes = chainstate.read_block(location).expect("read block");
        let block = Block::consensus_decode(&bytes).expect("decode block");
        let coinbase = block.transactions.first().expect("coinbase tx");
        let raw_hex = hex_bytes(&coinbase.consensus_encode().expect("encode tx"));

        let err = rpc_sendrawtransaction(
            &chainstate,
            &mempool,
            &mempool_policy,
            &mempool_metrics,
            &fee_estimator,
            &mempool_flags,
            vec![Value::String(raw_hex)],
            &params,
            &tx_announce,
        )
        .unwrap_err();
        assert_eq!(err.code, RPC_TRANSACTION_ALREADY_IN_CHAIN);
    }

    #[test]
    fn getrawtransaction_mempool_verbose_has_cpp_schema() {
        let (chainstate, params, _data_dir) = setup_regtest_chainstate();

        let script_pubkey = p2pkh_script([0x22u8; 20]);
        let tx = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: vec![TxIn {
                prevout: OutPoint {
                    hash: [0x33u8; 32],
                    index: 0,
                },
                script_sig: Vec::new(),
                sequence: 0,
            }],
            vout: vec![TxOut {
                value: 123,
                script_pubkey,
            }],
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let txid = tx.txid().expect("txid");
        let raw = tx.consensus_encode().expect("encode tx");

        let entry = MempoolEntry {
            txid,
            tx,
            raw: raw.clone(),
            time: 0,
            height: 0,
            fee: 0,
            value_in: 0,
            modified_size: 0,
            priority: 0.0,
            was_clear_at_entry: true,
            fee_delta: 0,
            priority_delta: 0.0,
            spent_outpoints: Vec::new(),
            parents: Vec::new(),
        };
        let mut inner = Mempool::new(0);
        inner.insert(entry).expect("insert mempool tx");
        let mempool = Mutex::new(inner);

        let raw_value = rpc_getrawtransaction(
            &chainstate,
            &mempool,
            vec![Value::String(hash256_to_hex(&txid))],
            &params,
        )
        .expect("rpc");
        assert_eq!(raw_value.as_str(), Some(hex_bytes(&raw).as_str()));

        let verbose_value = rpc_getrawtransaction(
            &chainstate,
            &mempool,
            vec![Value::String(hash256_to_hex(&txid)), json!(1)],
            &params,
        )
        .expect("rpc");
        let obj = verbose_value.as_object().expect("object");
        for key in [
            "txid",
            "version",
            "size",
            "overwintered",
            "locktime",
            "vin",
            "vout",
            "hex",
        ] {
            assert!(obj.contains_key(key), "missing key {key}");
        }
    }

    #[test]
    fn verifymessage_accepts_valid_signature() {
        let (_chainstate, params, _data_dir) = setup_regtest_chainstate();

        let secret = SecretKey::from_slice(&[1u8; 32]).expect("secret key");
        let pubkey = secret_key_pubkey_bytes(&secret, true);
        let key_hash = hash160(&pubkey);
        let script = p2pkh_script(key_hash);
        let address = script_pubkey_to_address(&script, params.network).expect("address");

        let message = "hello";
        let sig = sign_compact_message(&secret, true, message.as_bytes()).expect("sig");
        let signature = base64::engine::general_purpose::STANDARD.encode(sig);

        let ok = rpc_verifymessage(
            vec![
                Value::String(address.clone()),
                Value::String(signature.clone()),
                Value::String(message.to_string()),
            ],
            &params,
        )
        .expect("rpc");
        assert_eq!(ok, Value::Bool(true));

        let bad = rpc_verifymessage(
            vec![
                Value::String(address),
                Value::String(signature),
                Value::String("not-hello".to_string()),
            ],
            &params,
        )
        .expect("rpc");
        assert_eq!(bad, Value::Bool(false));
    }

    #[test]
    fn createmultisig_has_cpp_schema_keys() {
        let (_chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));
        let secret_a = SecretKey::from_slice(&[2u8; 32]).expect("secret key");
        let secret_b = SecretKey::from_slice(&[3u8; 32]).expect("secret key");
        let pub_a = secret_key_pubkey_bytes(&secret_a, true);
        let pub_b = secret_key_pubkey_bytes(&secret_b, true);

        let value = rpc_createmultisig(
            &wallet,
            vec![
                json!(1),
                Value::Array(vec![
                    Value::String(hex_bytes(&pub_a)),
                    Value::String(hex_bytes(&pub_b)),
                ]),
            ],
            &params,
        )
        .expect("rpc");
        let obj = value.as_object().expect("object");
        for key in ["address", "redeemScript"] {
            assert!(obj.contains_key(key), "missing key {key}");
        }
    }

    #[test]
    fn createmultisig_accepts_wallet_addresses_when_locked() {
        let (_chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let addr_a = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let addr_b = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();

        {
            let mut guard = wallet.lock().expect("wallet lock");
            guard
                .encryptwallet("test-passphrase")
                .expect("encryptwallet");
        }

        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));
        let value = rpc_createmultisig(&wallet, vec![json!(2), json!([addr_a, addr_b])], &params)
            .expect("rpc");
        let obj = value.as_object().expect("object");
        assert!(obj.get("address").and_then(Value::as_str).is_some());
        assert!(obj.get("redeemScript").and_then(Value::as_str).is_some());
    }

    #[test]
    fn addmultisigaddress_adds_spendable_p2sh_script_when_keys_present() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let addr_a = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let addr_b = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();

        let value = rpc_addmultisigaddress(
            &wallet,
            vec![
                json!(2),
                Value::Array(vec![Value::String(addr_a), Value::String(addr_b)]),
            ],
            &params,
        )
        .expect("rpc");
        let p2sh_address = value.as_str().expect("p2sh address").to_string();

        let script_pubkey =
            address_to_script_pubkey(&p2sh_address, params.network).expect("script_pubkey");

        let outpoint = OutPoint {
            hash: [0x99u8; 32],
            index: 0,
        };
        let utxo_entry = fluxd_chainstate::utxo::UtxoEntry {
            value: 2 * COIN,
            script_pubkey: script_pubkey.clone(),
            height: 0,
            is_coinbase: false,
        };
        let utxo_key = fluxd_chainstate::utxo::outpoint_key_bytes(&outpoint);
        let addr_key =
            fluxd_chainstate::address_index::address_outpoint_key(&script_pubkey, &outpoint)
                .expect("address outpoint key");
        let mut batch = WriteBatch::new();
        batch.put(Column::Utxo, utxo_key.as_bytes(), utxo_entry.encode());
        batch.put(Column::AddressOutpoint, addr_key, []);
        chainstate.commit_batch(batch).expect("commit utxo");

        let mempool = Mutex::new(Mempool::new(0));
        let value = rpc_listunspent(
            &chainstate,
            &mempool,
            &wallet,
            vec![json!(1), json!(9_999_999), json!([p2sh_address.clone()])],
            &params,
        )
        .expect("rpc");
        let arr = value.as_array().expect("array");
        assert_eq!(arr.len(), 1);
        let row = arr[0].as_object().expect("object");
        assert_eq!(
            row.get("address").and_then(Value::as_str),
            Some(p2sh_address.as_str())
        );
        assert_eq!(
            row.get("spendable").and_then(Value::as_bool),
            Some(true),
            "p2sh multisig output should be spendable when wallet has enough keys"
        );
        assert!(
            row.get("redeemScript").and_then(Value::as_str).is_some(),
            "P2SH outputs should include redeemScript when known"
        );
    }

    #[test]
    fn addmultisigaddress_rejects_nonempty_account_param() {
        let (_chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let addr_a = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let addr_b = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();

        let err = rpc_addmultisigaddress(
            &wallet,
            vec![
                json!(2),
                Value::Array(vec![Value::String(addr_a), Value::String(addr_b)]),
                json!("label"),
            ],
            &params,
        )
        .unwrap_err();
        assert_eq!(err.code, RPC_INVALID_PARAMETER);
        assert_eq!(err.message, "account must be \"\"");
    }

    #[test]
    fn listunspent_includes_account_for_labeled_address() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let address = rpc_getnewaddress(&wallet, vec![json!("example")])
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let script_pubkey =
            address_to_script_pubkey(&address, params.network).expect("address script");

        let outpoint = OutPoint {
            hash: [0x1au8; 32],
            index: 0,
        };
        let utxo_entry = fluxd_chainstate::utxo::UtxoEntry {
            value: 2 * COIN,
            script_pubkey: script_pubkey.clone(),
            height: 0,
            is_coinbase: false,
        };
        let utxo_key = fluxd_chainstate::utxo::outpoint_key_bytes(&outpoint);
        let addr_key =
            fluxd_chainstate::address_index::address_outpoint_key(&script_pubkey, &outpoint)
                .expect("address outpoint key");
        let mut batch = WriteBatch::new();
        batch.put(Column::Utxo, utxo_key.as_bytes(), utxo_entry.encode());
        batch.put(Column::AddressOutpoint, addr_key, []);
        chainstate.commit_batch(batch).expect("commit utxo");

        let mempool = Mutex::new(Mempool::new(0));
        let value =
            rpc_listunspent(&chainstate, &mempool, &wallet, Vec::new(), &params).expect("rpc");
        let arr = value.as_array().expect("array");
        assert_eq!(arr.len(), 1);
        let row = arr[0].as_object().expect("object");
        assert_eq!(
            row.get("account").and_then(Value::as_str),
            Some("example"),
            "listunspent should include account label for labeled wallet addresses"
        );
    }

    #[test]
    fn listunspent_rejects_duplicate_address_filters() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let address = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let err = rpc_listunspent(
            &chainstate,
            &Mutex::new(Mempool::new(0)),
            &wallet,
            vec![
                json!(1),
                json!(9_999_999),
                json!([address.clone(), address]),
            ],
            &params,
        )
        .unwrap_err();
        assert_eq!(err.code, RPC_INVALID_PARAMETER);
        assert!(err.message.contains("duplicated address"));
    }

    #[test]
    fn signrawtransaction_signs_p2sh_multisig_inputs() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let addr_a = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let addr_b = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();

        let p2sh_address =
            rpc_addmultisigaddress(&wallet, vec![json!(2), json!([addr_a, addr_b])], &params)
                .expect("rpc")
                .as_str()
                .expect("p2sh address")
                .to_string();

        let script_pubkey =
            address_to_script_pubkey(&p2sh_address, params.network).expect("script_pubkey");

        let outpoint = OutPoint {
            hash: [0x42u8; 32],
            index: 0,
        };
        let prev_value = 2 * COIN;

        let recipient = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let recipient_script =
            address_to_script_pubkey(&recipient, params.network).expect("recipient spk");

        let tx = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: vec![TxIn {
                prevout: outpoint.clone(),
                script_sig: Vec::new(),
                sequence: u32::MAX,
            }],
            vout: vec![TxOut {
                value: COIN,
                script_pubkey: recipient_script,
            }],
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let raw_hex = hex_bytes(&tx.consensus_encode().expect("encode tx"));

        let mempool = Mutex::new(Mempool::new(0));
        let signed = rpc_signrawtransaction(
            &chainstate,
            &mempool,
            &wallet,
            vec![
                json!(raw_hex),
                json!([{
                    "txid": hash256_to_hex(&outpoint.hash),
                    "vout": outpoint.index,
                    "scriptPubKey": hex_bytes(&script_pubkey),
                    "amount": amount_to_value(prev_value),
                }]),
            ],
            &params,
        )
        .expect("rpc");

        let obj = signed.as_object().expect("object");
        assert_eq!(obj.get("complete").and_then(Value::as_bool), Some(true));

        let signed_hex = obj.get("hex").and_then(Value::as_str).expect("hex string");
        let signed_bytes = bytes_from_hex(signed_hex).expect("hex decode");
        let signed_tx =
            Transaction::consensus_decode(&signed_bytes).expect("decode signed transaction");
        assert_eq!(signed_tx.vin.len(), 1);
        assert!(!signed_tx.vin[0].script_sig.is_empty());
        assert_eq!(signed_tx.vin[0].script_sig[0], 0x00);
    }

    #[test]
    fn signrawtransaction_accepts_prevtx_without_amount() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let from_addr = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let from_script =
            address_to_script_pubkey(&from_addr, params.network).expect("from script_pubkey");

        let recipient = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let recipient_script =
            address_to_script_pubkey(&recipient, params.network).expect("recipient script_pubkey");

        let outpoint = OutPoint {
            hash: [0x24u8; 32],
            index: 0,
        };

        let tx = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: vec![TxIn {
                prevout: outpoint.clone(),
                script_sig: Vec::new(),
                sequence: u32::MAX,
            }],
            vout: vec![TxOut {
                value: COIN,
                script_pubkey: recipient_script,
            }],
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let raw_hex = hex_bytes(&tx.consensus_encode().expect("encode tx"));

        let mempool = Mutex::new(Mempool::new(0));
        let signed = rpc_signrawtransaction(
            &chainstate,
            &mempool,
            &wallet,
            vec![
                json!(raw_hex),
                json!([{
                    "txid": hash256_to_hex(&outpoint.hash),
                    "vout": outpoint.index,
                    "scriptPubKey": hex_bytes(&from_script),
                }]),
            ],
            &params,
        )
        .expect("rpc");

        let obj = signed.as_object().expect("object");
        assert_eq!(obj.get("complete").and_then(Value::as_bool), Some(true));
    }

    #[test]
    fn signrawtransaction_privkeys_use_wallet_fallback() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let addr_a = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let addr_b = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();

        let wif_a = rpc_dumpprivkey(&wallet, vec![json!(addr_a.clone())], &params)
            .expect("rpc")
            .as_str()
            .expect("wif")
            .to_string();

        let script_a = address_to_script_pubkey(&addr_a, params.network).expect("script a");
        let script_b = address_to_script_pubkey(&addr_b, params.network).expect("script b");

        let outpoint_a = OutPoint {
            hash: [0x11u8; 32],
            index: 0,
        };
        let outpoint_b = OutPoint {
            hash: [0x12u8; 32],
            index: 1,
        };
        let prev_value = 2 * COIN;

        let recipient = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let recipient_script =
            address_to_script_pubkey(&recipient, params.network).expect("recipient script");

        let tx = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: vec![
                TxIn {
                    prevout: outpoint_a.clone(),
                    script_sig: Vec::new(),
                    sequence: u32::MAX,
                },
                TxIn {
                    prevout: outpoint_b.clone(),
                    script_sig: Vec::new(),
                    sequence: u32::MAX,
                },
            ],
            vout: vec![TxOut {
                value: COIN,
                script_pubkey: recipient_script,
            }],
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let raw_hex = hex_bytes(&tx.consensus_encode().expect("encode tx"));

        let mempool = Mutex::new(Mempool::new(0));
        let signed = rpc_signrawtransaction(
            &chainstate,
            &mempool,
            &wallet,
            vec![
                json!(raw_hex),
                json!([
                    {
                        "txid": hash256_to_hex(&outpoint_a.hash),
                        "vout": outpoint_a.index,
                        "scriptPubKey": hex_bytes(&script_a),
                        "amount": amount_to_value(prev_value),
                    },
                    {
                        "txid": hash256_to_hex(&outpoint_b.hash),
                        "vout": outpoint_b.index,
                        "scriptPubKey": hex_bytes(&script_b),
                        "amount": amount_to_value(prev_value),
                    }
                ]),
                json!([wif_a]),
            ],
            &params,
        )
        .expect("rpc");

        let obj = signed.as_object().expect("object");
        assert_eq!(obj.get("complete").and_then(Value::as_bool), Some(true));
        assert!(
            obj.get("errors").is_none(),
            "expected no errors when wallet can sign remaining inputs"
        );

        let signed_hex = obj.get("hex").and_then(Value::as_str).expect("hex");
        let signed_bytes = bytes_from_hex(signed_hex).expect("hex decode");
        let signed_tx =
            Transaction::consensus_decode(&signed_bytes).expect("decode signed transaction");
        assert_eq!(signed_tx.vin.len(), 2);
        assert!(!signed_tx.vin[0].script_sig.is_empty());
        assert!(!signed_tx.vin[1].script_sig.is_empty());
    }

    #[test]
    fn signrawtransaction_rejects_invalid_branchid() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let from_addr = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let from_script =
            address_to_script_pubkey(&from_addr, params.network).expect("from script_pubkey");

        let recipient = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let recipient_script =
            address_to_script_pubkey(&recipient, params.network).expect("recipient script_pubkey");

        let outpoint = OutPoint {
            hash: [0x33u8; 32],
            index: 0,
        };
        let prev_value = COIN;

        let tx = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: vec![TxIn {
                prevout: outpoint.clone(),
                script_sig: Vec::new(),
                sequence: u32::MAX,
            }],
            vout: vec![TxOut {
                value: COIN,
                script_pubkey: recipient_script,
            }],
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let raw_hex = hex_bytes(&tx.consensus_encode().expect("encode tx"));

        let mempool = Mutex::new(Mempool::new(0));
        let err = rpc_signrawtransaction(
            &chainstate,
            &mempool,
            &wallet,
            vec![
                json!(raw_hex),
                json!([{
                    "txid": hash256_to_hex(&outpoint.hash),
                    "vout": outpoint.index,
                    "scriptPubKey": hex_bytes(&from_script),
                    "amount": amount_to_value(prev_value),
                }]),
                Value::Null,
                json!("ALL"),
                json!("deadbeef"),
            ],
            &params,
        )
        .unwrap_err();
        assert_eq!(err.code, RPC_INVALID_PARAMETER);
        assert!(err.message.contains("not a valid consensus branch id"));
    }

    #[test]
    fn fluxnode_rpcs_have_cpp_schema_keys() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        extend_regtest_chain_to_height(&chainstate, &params, 69);

        let mut batch = WriteBatch::new();
        add_fluxnode_record_to_batch(
            &mut batch,
            OutPoint {
                hash: [0x13u8; 32],
                index: 0,
            },
            1,
            2,
            2,
            vec![0x02u8; 33],
            vec![0x03u8; 33],
            100_000,
        );
        let record_cumulus = add_fluxnode_record_to_batch(
            &mut batch,
            OutPoint {
                hash: [0x10u8; 32],
                index: 0,
            },
            1,
            1,
            0,
            vec![0x02u8; 33],
            vec![0x03u8; 33],
            100_000,
        );
        add_fluxnode_record_to_batch(
            &mut batch,
            OutPoint {
                hash: [0x11u8; 32],
                index: 1,
            },
            2,
            69,
            0,
            vec![0x02u8; 33],
            vec![0x03u8; 33],
            100_000,
        );
        add_fluxnode_record_to_batch(
            &mut batch,
            OutPoint {
                hash: [0x12u8; 32],
                index: 2,
            },
            3,
            69,
            0,
            vec![0x02u8; 33],
            vec![0x03u8; 33],
            100_000,
        );
        chainstate.commit_batch(batch).expect("insert fluxnodes");

        let value = rpc_getfluxnodecount(&chainstate, Vec::new()).expect("rpc");
        let obj = value.as_object().expect("object");
        for key in [
            "total",
            "stable",
            "basic-enabled",
            "super-enabled",
            "bamf-enabled",
            "cumulus-enabled",
            "nimbus-enabled",
            "stratus-enabled",
            "ipv4",
            "ipv6",
            "onion",
        ] {
            assert!(obj.contains_key(key), "missing key {key}");
        }

        let value =
            rpc_viewdeterministicfluxnodelist(&chainstate, Vec::new(), &params).expect("rpc");
        let list = value.as_array().expect("array");
        assert!(!list.is_empty());
        let first = list[0].as_object().expect("object");
        for key in [
            "collateral",
            "txhash",
            "outidx",
            "ip",
            "network",
            "added_height",
            "confirmed_height",
            "last_confirmed_height",
            "last_paid_height",
            "tier",
            "payment_address",
            "pubkey",
            "activesince",
            "lastpaid",
            "rank",
        ] {
            assert!(first.contains_key(key), "missing key {key}");
        }

        let value = rpc_fluxnodecurrentwinner(&chainstate, Vec::new(), &params).expect("rpc");
        let winners = value.as_object().expect("object");
        for (tier_key, winner) in winners {
            assert!(
                tier_key.ends_with(" Winner"),
                "unexpected winner key {tier_key}"
            );
            let obj = winner.as_object().expect("object");
            for key in [
                "collateral",
                "ip",
                "added_height",
                "confirmed_height",
                "last_confirmed_height",
                "last_paid_height",
                "tier",
                "payment_address",
            ] {
                assert!(obj.contains_key(key), "missing key {key}");
            }
        }

        let value = rpc_getfluxnodestatus(
            &chainstate,
            vec![Value::String(format_outpoint(&record_cumulus.collateral))],
            &params,
            &data_dir,
        )
        .expect("rpc");
        let status = value.as_object().expect("object");
        for key in [
            "status",
            "collateral",
            "txhash",
            "outidx",
            "ip",
            "network",
            "added_height",
            "confirmed_height",
            "last_confirmed_height",
            "last_paid_height",
            "tier",
            "payment_address",
            "pubkey",
            "activesince",
            "lastpaid",
        ] {
            assert!(status.contains_key(key), "missing key {key}");
        }

        let starts = rpc_getstartlist(&chainstate, Vec::new(), &params).expect("rpc");
        let starts = starts.as_array().expect("array");
        assert_eq!(starts.len(), 2);
        let first = starts[0].as_object().expect("object");
        for key in [
            "collateral",
            "added_height",
            "payment_address",
            "expires_in",
        ] {
            assert!(first.contains_key(key), "missing key {key}");
        }

        let dos = rpc_getdoslist(&chainstate, Vec::new(), &params).expect("rpc");
        let dos = dos.as_array().expect("array");
        assert_eq!(dos.len(), 1);
        let first = dos[0].as_object().expect("object");
        for key in [
            "collateral",
            "added_height",
            "payment_address",
            "eligible_in",
        ] {
            assert!(first.contains_key(key), "missing key {key}");
        }
    }

    #[test]
    fn getfluxnodecount_counts_confirmed_nodes_by_tier() {
        let (chainstate, params, _data_dir) = setup_regtest_chainstate();
        extend_regtest_chain_to_height(&chainstate, &params, 100);

        let mut batch = WriteBatch::new();
        add_fluxnode_record_to_batch(
            &mut batch,
            OutPoint {
                hash: [0x21u8; 32],
                index: 0,
            },
            1,
            1,
            1,
            vec![0x02u8; 33],
            vec![0x03u8; 33],
            100_000,
        );
        add_fluxnode_record_to_batch(
            &mut batch,
            OutPoint {
                hash: [0x22u8; 32],
                index: 0,
            },
            2,
            10,
            10,
            vec![0x02u8; 33],
            vec![0x03u8; 33],
            100_000,
        );
        add_fluxnode_record_to_batch(
            &mut batch,
            OutPoint {
                hash: [0x23u8; 32],
                index: 0,
            },
            3,
            20,
            20,
            vec![0x02u8; 33],
            vec![0x03u8; 33],
            100_000,
        );
        add_fluxnode_record_to_batch(
            &mut batch,
            OutPoint {
                hash: [0x24u8; 32],
                index: 0,
            },
            3,
            21,
            21,
            vec![0x02u8; 33],
            vec![0x03u8; 33],
            100_000,
        );
        chainstate.commit_batch(batch).expect("insert fluxnodes");

        let value = rpc_getfluxnodecount(&chainstate, Vec::new()).expect("rpc");
        let obj = value.as_object().expect("object");

        assert_eq!(obj.get("total").and_then(Value::as_i64), Some(4));
        assert_eq!(obj.get("stable").and_then(Value::as_i64), Some(4));
        assert_eq!(obj.get("basic-enabled").and_then(Value::as_i64), Some(1));
        assert_eq!(obj.get("super-enabled").and_then(Value::as_i64), Some(1));
        assert_eq!(obj.get("bamf-enabled").and_then(Value::as_i64), Some(2));
        assert_eq!(obj.get("cumulus-enabled").and_then(Value::as_i64), Some(1));
        assert_eq!(obj.get("nimbus-enabled").and_then(Value::as_i64), Some(1));
        assert_eq!(obj.get("stratus-enabled").and_then(Value::as_i64), Some(2));
        assert_eq!(obj.get("ipv4").and_then(Value::as_i64), Some(0));
        assert_eq!(obj.get("ipv6").and_then(Value::as_i64), Some(0));
        assert_eq!(obj.get("onion").and_then(Value::as_i64), Some(0));
    }

    #[test]
    fn createfluxnodekey_returns_string() {
        let (_chainstate, params, _data_dir) = setup_regtest_chainstate();
        let value = rpc_createfluxnodekey(Vec::new(), &params).expect("rpc");
        let key = value.as_str().expect("string");
        assert!(!key.is_empty());
    }

    #[test]
    fn createdelegatekeypair_matches_private_key() {
        let (_chainstate, params, _data_dir) = setup_regtest_chainstate();
        let value = rpc_createdelegatekeypair(Vec::new(), &params).expect("rpc");
        let obj = value.as_object().expect("object");

        let wif = obj.get("private_key").and_then(Value::as_str).expect("wif");
        assert!(!wif.is_empty());
        let pubkey_compressed = obj
            .get("public_key_compressed")
            .and_then(Value::as_str)
            .expect("compressed pubkey");
        let pubkey_uncompressed = obj
            .get("public_key_uncompressed")
            .and_then(Value::as_str)
            .expect("uncompressed pubkey");

        assert_eq!(pubkey_compressed.len(), 66);
        assert_eq!(pubkey_uncompressed.len(), 130);
        assert!(bytes_from_hex(pubkey_compressed).is_some());
        assert!(bytes_from_hex(pubkey_uncompressed).is_some());

        let (secret, compressed) = wif_to_secret_key(wif, params.network).expect("decode wif");
        assert!(compressed, "expected a compressed WIF");

        let secp = Secp256k1::new();
        let secret = SecretKey::from_slice(&secret).expect("secret key");
        let pubkey = PublicKey::from_secret_key(&secp, &secret);
        assert_eq!(pubkey_compressed, hex_bytes(&pubkey.serialize()));
        assert_eq!(
            pubkey_uncompressed,
            hex_bytes(&pubkey.serialize_uncompressed())
        );
    }

    #[test]
    fn createp2shstarttx_and_signp2shstarttx_roundtrip() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let secp = Secp256k1::new();
        let signing_secret = SecretKey::from_slice(&[0x11u8; 32]).expect("secret");
        let signing_pubkey = PublicKey::from_secret_key(&secp, &signing_secret)
            .serialize()
            .to_vec();

        let redeem_script = {
            let mut script = Vec::with_capacity(1 + 1 + signing_pubkey.len() + 2);
            script.push(0x51);
            script.push(signing_pubkey.len() as u8);
            script.extend_from_slice(&signing_pubkey);
            script.push(0x51);
            script.push(0xae);
            script
        };

        let vps_secret = SecretKey::from_slice(&[0x22u8; 32]).expect("secret");
        let vps_pubkey = PublicKey::from_secret_key(&secp, &vps_secret)
            .serialize()
            .to_vec();

        let collateral = OutPoint {
            hash: [0x42u8; 32],
            index: 0,
        };

        let mut script_pubkey = Vec::with_capacity(23);
        script_pubkey.extend_from_slice(&[0xa9, 0x14]);
        script_pubkey.extend_from_slice(&hash160(&redeem_script));
        script_pubkey.push(0x87);

        let utxo = fluxd_chainstate::utxo::UtxoEntry {
            value: 1_000 * COIN,
            script_pubkey,
            height: 0,
            is_coinbase: false,
        };
        let key = fluxd_chainstate::utxo::outpoint_key_bytes(&collateral);
        let mut batch = WriteBatch::new();
        batch.put(Column::Utxo, key.as_bytes(), utxo.encode());
        chainstate.commit_batch(batch).expect("commit utxo");

        let raw_tx = rpc_createp2shstarttx(
            &chainstate,
            vec![
                json!(hex_bytes(&redeem_script)),
                json!(hex_bytes(&vps_pubkey)),
                json!(hash256_to_hex(&collateral.hash)),
                json!(collateral.index),
            ],
            &params,
        )
        .expect("rpc");
        let raw_tx = raw_tx.as_str().expect("rawtx string");
        let raw = bytes_from_hex(raw_tx).expect("raw tx bytes");
        let tx = Transaction::consensus_decode(&raw).expect("decode tx");

        let start = match tx.fluxnode.as_ref().expect("fluxnode") {
            FluxnodeTx::V6(FluxnodeTxV6::Start(start)) => start,
            other => panic!("expected v6 start tx, got {other:?}"),
        };
        assert_eq!(tx.version, FLUXNODE_TX_UPGRADEABLE_VERSION);
        assert_eq!(start.flux_tx_version, FLUXNODE_INTERNAL_P2SH_TX_VERSION);
        assert!(!start.using_delegates);
        assert!(start.delegates.is_none());

        match &start.variant {
            FluxnodeStartVariantV6::P2sh {
                collateral: tx_collateral,
                pubkey,
                redeem_script: tx_redeem,
                sig_time,
                sig,
            } => {
                assert_eq!(tx_collateral, &collateral);
                assert_eq!(pubkey, &vps_pubkey);
                assert_eq!(tx_redeem, &redeem_script);
                assert_eq!(*sig_time, 0);
                assert!(sig.is_empty());
            }
            other => panic!("expected p2sh variant, got {other:?}"),
        }

        let signing_secret_bytes = signing_secret.secret_bytes();
        let signing_wif = secret_key_to_wif(&signing_secret_bytes, params.network, true);
        let signed = rpc_signp2shstarttx(&wallet, vec![json!(raw_tx), json!(signing_wif)], &params)
            .expect("rpc");
        let signed = signed.as_str().expect("signed tx string");
        let signed_bytes = bytes_from_hex(signed).expect("signed tx bytes");
        let signed_tx = Transaction::consensus_decode(&signed_bytes).expect("decode signed tx");

        let signed_start = match signed_tx.fluxnode.as_ref().expect("fluxnode") {
            FluxnodeTx::V6(FluxnodeTxV6::Start(start)) => start,
            other => panic!("expected v6 start tx, got {other:?}"),
        };
        let (sig_time, sig) = match &signed_start.variant {
            FluxnodeStartVariantV6::P2sh { sig_time, sig, .. } => (sig_time, sig),
            other => panic!("expected p2sh variant, got {other:?}"),
        };
        assert!(*sig_time > 0);
        assert_eq!(sig.len(), 65);

        let txid = signed_tx.txid().expect("txid");
        let message = hash256_to_hex(&txid).into_bytes();
        fluxd_script::message::verify_signed_message(&signing_pubkey, sig, &message)
            .expect("signature verify");
    }

    #[test]
    fn createp2shstarttx_sets_delegate_feature_after_pon() {
        let (chainstate, mut params, _data_dir) = setup_regtest_chainstate();
        params.consensus.upgrades[UpgradeIndex::Pon.as_usize()].activation_height = 1;

        let secp = Secp256k1::new();
        let signing_secret = SecretKey::from_slice(&[0x33u8; 32]).expect("secret");
        let signing_pubkey = PublicKey::from_secret_key(&secp, &signing_secret)
            .serialize()
            .to_vec();

        let redeem_script = {
            let mut script = Vec::with_capacity(1 + 1 + signing_pubkey.len() + 2);
            script.push(0x51);
            script.push(signing_pubkey.len() as u8);
            script.extend_from_slice(&signing_pubkey);
            script.push(0x51);
            script.push(0xae);
            script
        };

        let vps_secret = SecretKey::from_slice(&[0x44u8; 32]).expect("secret");
        let vps_pubkey = PublicKey::from_secret_key(&secp, &vps_secret)
            .serialize()
            .to_vec();

        let delegate_a = PublicKey::from_secret_key(
            &secp,
            &SecretKey::from_slice(&[0x55u8; 32]).expect("secret"),
        )
        .serialize()
        .to_vec();
        let delegate_b = PublicKey::from_secret_key(
            &secp,
            &SecretKey::from_slice(&[0x66u8; 32]).expect("secret"),
        )
        .serialize()
        .to_vec();

        let collateral = OutPoint {
            hash: [0x77u8; 32],
            index: 0,
        };

        let mut script_pubkey = Vec::with_capacity(23);
        script_pubkey.extend_from_slice(&[0xa9, 0x14]);
        script_pubkey.extend_from_slice(&hash160(&redeem_script));
        script_pubkey.push(0x87);

        let utxo = fluxd_chainstate::utxo::UtxoEntry {
            value: 1_000 * COIN,
            script_pubkey,
            height: 0,
            is_coinbase: false,
        };
        let key = fluxd_chainstate::utxo::outpoint_key_bytes(&collateral);
        let mut batch = WriteBatch::new();
        batch.put(Column::Utxo, key.as_bytes(), utxo.encode());
        chainstate.commit_batch(batch).expect("commit utxo");

        let raw_tx = rpc_createp2shstarttx(
            &chainstate,
            vec![
                json!(hex_bytes(&redeem_script)),
                json!(hex_bytes(&vps_pubkey)),
                json!(hash256_to_hex(&collateral.hash)),
                json!(collateral.index),
                json!([hex_bytes(&delegate_a), hex_bytes(&delegate_b)]),
            ],
            &params,
        )
        .expect("rpc");
        let raw_tx = raw_tx.as_str().expect("rawtx string");
        let raw = bytes_from_hex(raw_tx).expect("raw tx bytes");
        let tx = Transaction::consensus_decode(&raw).expect("decode tx");

        let start = match tx.fluxnode.as_ref().expect("fluxnode") {
            FluxnodeTx::V6(FluxnodeTxV6::Start(start)) => start,
            other => panic!("expected v6 start tx, got {other:?}"),
        };
        assert_eq!(
            start.flux_tx_version,
            FLUXNODE_TX_TYPE_P2SH_BIT | FLUXNODE_TX_FEATURE_DELEGATES_BIT
        );
        assert!(start.using_delegates);
        let delegates = start.delegates.as_ref().expect("delegates payload");
        assert_eq!(delegates.version, FluxnodeDelegates::INITIAL_VERSION);
        assert_eq!(delegates.kind, FluxnodeDelegates::UPDATE);
        assert_eq!(
            delegates.delegate_starting_keys,
            vec![delegate_a, delegate_b]
        );
    }

    #[test]
    fn createp2shstarttx_ignores_empty_delegates_array_after_pon() {
        let (chainstate, mut params, _data_dir) = setup_regtest_chainstate();
        params.consensus.upgrades[UpgradeIndex::Pon.as_usize()].activation_height = 1;

        let secp = Secp256k1::new();
        let signing_secret = SecretKey::from_slice(&[0x33u8; 32]).expect("secret");
        let signing_pubkey = PublicKey::from_secret_key(&secp, &signing_secret)
            .serialize()
            .to_vec();

        let redeem_script = {
            let mut script = Vec::with_capacity(1 + 1 + signing_pubkey.len() + 2);
            script.push(0x51);
            script.push(signing_pubkey.len() as u8);
            script.extend_from_slice(&signing_pubkey);
            script.push(0x51);
            script.push(0xae);
            script
        };

        let vps_secret = SecretKey::from_slice(&[0x44u8; 32]).expect("secret");
        let vps_pubkey = PublicKey::from_secret_key(&secp, &vps_secret)
            .serialize()
            .to_vec();

        let collateral = OutPoint {
            hash: [0x77u8; 32],
            index: 0,
        };

        let mut script_pubkey = Vec::with_capacity(23);
        script_pubkey.extend_from_slice(&[0xa9, 0x14]);
        script_pubkey.extend_from_slice(&hash160(&redeem_script));
        script_pubkey.push(0x87);

        let utxo = fluxd_chainstate::utxo::UtxoEntry {
            value: 1_000 * COIN,
            script_pubkey,
            height: 0,
            is_coinbase: false,
        };
        let key = fluxd_chainstate::utxo::outpoint_key_bytes(&collateral);
        let mut batch = WriteBatch::new();
        batch.put(Column::Utxo, key.as_bytes(), utxo.encode());
        chainstate.commit_batch(batch).expect("commit utxo");

        let raw_tx = rpc_createp2shstarttx(
            &chainstate,
            vec![
                json!(hex_bytes(&redeem_script)),
                json!(hex_bytes(&vps_pubkey)),
                json!(hash256_to_hex(&collateral.hash)),
                json!(collateral.index),
                json!([]),
            ],
            &params,
        )
        .expect("rpc");
        let raw_tx = raw_tx.as_str().expect("rawtx string");
        let raw = bytes_from_hex(raw_tx).expect("raw tx bytes");
        let tx = Transaction::consensus_decode(&raw).expect("decode tx");

        let start = match tx.fluxnode.as_ref().expect("fluxnode") {
            FluxnodeTx::V6(FluxnodeTxV6::Start(start)) => start,
            other => panic!("expected v6 start tx, got {other:?}"),
        };
        assert_eq!(start.flux_tx_version, FLUXNODE_TX_TYPE_P2SH_BIT);
        assert!(!start.using_delegates);
        assert!(start.delegates.is_none());
    }

    #[test]
    fn listfluxnodeconf_has_cpp_schema_keys() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();

        let collateral_hash = [0x42u8; 32];
        let txhash_hex = hash256_to_hex(&collateral_hash);
        std::fs::write(
            data_dir.join("fluxnode.conf"),
            format!("fn1 127.0.0.1:16125 operatorkey {txhash_hex} 0\n"),
        )
        .expect("write fluxnode.conf");

        let value = rpc_listfluxnodeconf(&chainstate, Vec::new(), &params, &data_dir).expect("rpc");
        let list = value.as_array().expect("array");
        assert_eq!(list.len(), 1);

        let obj = list[0].as_object().expect("object");
        for key in [
            "alias",
            "status",
            "collateral",
            "txHash",
            "outputIndex",
            "privateKey",
            "address",
            "ip",
            "network",
            "added_height",
            "confirmed_height",
            "last_confirmed_height",
            "last_paid_height",
            "tier",
            "payment_address",
            "activesince",
            "lastpaid",
        ] {
            assert!(obj.contains_key(key), "missing key {key}");
        }

        let txhash = obj.get("txHash").and_then(Value::as_str).unwrap();
        assert!(is_hex_64(txhash));
    }

    #[test]
    fn getfluxnodeoutputs_has_cpp_schema_keys() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();

        let collateral = OutPoint {
            hash: [0x43u8; 32],
            index: 0,
        };
        let txhash_hex = hash256_to_hex(&collateral.hash);
        std::fs::write(
            data_dir.join("fluxnode.conf"),
            format!("fn1 127.0.0.1:16125 operatorkey {txhash_hex} 0\n"),
        )
        .expect("write fluxnode.conf");

        let utxo = fluxd_chainstate::utxo::UtxoEntry {
            value: 1_000 * COIN,
            script_pubkey: vec![0x51],
            height: 0,
            is_coinbase: false,
        };
        let key = fluxd_chainstate::utxo::outpoint_key_bytes(&collateral);
        let mut batch = WriteBatch::new();
        batch.put(Column::Utxo, key.as_bytes(), utxo.encode());
        chainstate.commit_batch(batch).expect("commit utxo");

        let value =
            rpc_getfluxnodeoutputs(&chainstate, Vec::new(), &params, &data_dir).expect("rpc");
        let list = value.as_array().expect("array");
        assert_eq!(list.len(), 1);
        let obj = list[0].as_object().expect("object");
        for key in ["txhash", "outputidx", "Flux Amount", "Confirmations"] {
            assert!(obj.contains_key(key), "missing key {key}");
        }
        let txhash = obj.get("txhash").and_then(Value::as_str).unwrap();
        assert!(is_hex_64(txhash));
    }

    #[test]
    fn startfluxnode_has_cpp_schema_keys() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let txhash_hex = hash256_to_hex(&[0x44u8; 32]);
        std::fs::write(
            data_dir.join("fluxnode.conf"),
            format!("fn1 127.0.0.1:16125 operatorkey {txhash_hex} 0\n"),
        )
        .expect("write fluxnode.conf");

        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));
        let mempool = Mutex::new(Mempool::new(0));
        let mempool_policy = MempoolPolicy::standard(0, false);
        let mempool_metrics = MempoolMetrics::default();
        let fee_estimator = Mutex::new(FeeEstimator::new(128));
        let mempool_flags = ValidationFlags::default();
        let (tx_announce, _rx) = broadcast::channel(16);

        let value = rpc_startfluxnode(
            &chainstate,
            &wallet,
            &mempool,
            &mempool_policy,
            &mempool_metrics,
            &fee_estimator,
            &mempool_flags,
            vec![json!("all"), json!(false)],
            &params,
            &tx_announce,
            &data_dir,
        )
        .expect("rpc");

        let obj = value.as_object().expect("object");
        assert!(obj.contains_key("overall"));
        let detail = obj
            .get("detail")
            .and_then(Value::as_array)
            .expect("detail array");
        assert_eq!(detail.len(), 1);
        let entry = detail[0].as_object().expect("detail entry");
        for key in [
            "alias",
            "outpoint",
            "result",
            "transaction_built",
            "transaction_signed",
            "transaction_commited",
            "errorMessage",
        ] {
            assert!(entry.contains_key(key), "missing key {key}");
        }
    }

    #[test]
    fn getbenchmarks_requires_fluxnode_conf() {
        let (_chainstate, params, data_dir) = setup_regtest_chainstate();
        let err = rpc_getbenchmarks(Vec::new(), &data_dir, &params).expect_err("expected error");
        assert_eq!(err.code, RPC_INTERNAL_ERROR);
        assert_eq!(
            err.message,
            "This is not a Flux Node (no fluxnode.conf entry found)"
        );
    }

    #[test]
    fn getbenchmarks_returns_benchmark_not_running() {
        let (_chainstate, params, data_dir) = setup_regtest_chainstate();
        let txhash_hex = hash256_to_hex(&[0x55u8; 32]);
        std::fs::write(
            data_dir.join("fluxnode.conf"),
            format!("fn1 127.0.0.1:16125 operatorkey {txhash_hex} 0\n"),
        )
        .expect("write fluxnode.conf");

        let value = rpc_getbenchmarks(Vec::new(), &data_dir, &params).expect("rpc");
        assert_eq!(value, Value::String("Benchmark not running".to_string()));
    }

    #[test]
    fn getbenchstatus_returns_benchmark_not_running() {
        let (_chainstate, params, data_dir) = setup_regtest_chainstate();
        let txhash_hex = hash256_to_hex(&[0x56u8; 32]);
        std::fs::write(
            data_dir.join("fluxnode.conf"),
            format!("fn1 127.0.0.1:16125 operatorkey {txhash_hex} 0\n"),
        )
        .expect("write fluxnode.conf");

        let value = rpc_getbenchstatus(Vec::new(), &data_dir, &params).expect("rpc");
        assert_eq!(value, Value::String("Benchmark not running".to_string()));
    }

    #[test]
    fn startbenchmark_rejects_missing_bench_binary() {
        let (_chainstate, params, data_dir) = setup_regtest_chainstate();
        let txhash_hex = hash256_to_hex(&[0x57u8; 32]);
        std::fs::write(
            data_dir.join("fluxnode.conf"),
            format!("fn1 127.0.0.1:16125 operatorkey {txhash_hex} 0\n"),
        )
        .expect("write fluxnode.conf");

        let err = rpc_startbenchmark(Vec::new(), &data_dir, &params).expect_err("expected error");
        assert_eq!(err.code, RPC_INTERNAL_ERROR);
        assert_eq!(err.message, "Failed to find benchmark application");
    }

    #[test]
    fn stopbenchmark_returns_not_running_when_bench_absent() {
        let (_chainstate, params, data_dir) = setup_regtest_chainstate();
        let txhash_hex = hash256_to_hex(&[0x58u8; 32]);
        std::fs::write(
            data_dir.join("fluxnode.conf"),
            format!("fn1 127.0.0.1:16125 operatorkey {txhash_hex} 0\n"),
        )
        .expect("write fluxnode.conf");

        let value = rpc_stopbenchmark(Vec::new(), &data_dir, &params).expect("rpc");
        assert_eq!(value, Value::String("Not running".to_string()));
    }

    #[test]
    fn zcbenchmark_sleep_returns_samples() {
        let value = rpc_zcbenchmark(vec![json!("sleep"), json!(1)]).expect("rpc");
        let samples = value.as_array().expect("array");
        assert_eq!(samples.len(), 1);
        let sample = samples[0].as_object().expect("object");
        assert!(sample.contains_key("runningtime"));
        assert!(sample.get("runningtime").and_then(Value::as_f64).is_some());
    }

    #[test]
    fn zcbenchmark_rejects_invalid_samplecount() {
        let err = rpc_zcbenchmark(vec![json!("sleep"), json!(0)]).expect_err("expected error");
        assert_eq!(err.code, RPC_TYPE_ERROR);
        assert_eq!(err.message, "Invalid samplecount");
    }

    #[test]
    fn zcbenchmark_rejects_unknown_type() {
        let err =
            rpc_zcbenchmark(vec![json!("not-a-benchmark"), json!(1)]).expect_err("expected error");
        assert_eq!(err.code, RPC_TYPE_ERROR);
        assert_eq!(err.message, "Invalid benchmarktype");
    }

    #[test]
    fn zcbenchmark_parameterloading_is_removed() {
        let err =
            rpc_zcbenchmark(vec![json!("parameterloading"), json!(1)]).expect_err("expected error");
        assert_eq!(err.code, RPC_TYPE_ERROR);
        assert_eq!(
            err.message,
            "Pre-Sapling Sprout parameters have been removed"
        );
    }

    #[test]
    fn startdeterministicfluxnode_has_cpp_schema_keys() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();

        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));
        let mempool = Mutex::new(Mempool::new(0));
        let mempool_policy = MempoolPolicy::standard(0, false);
        let mempool_metrics = MempoolMetrics::default();
        let fee_estimator = Mutex::new(FeeEstimator::new(128));
        let mempool_flags = ValidationFlags::default();
        let (tx_announce, _rx) = broadcast::channel(16);

        let value = rpc_startdeterministicfluxnode(
            &chainstate,
            &wallet,
            &mempool,
            &mempool_policy,
            &mempool_metrics,
            &fee_estimator,
            &mempool_flags,
            vec![json!("missing-alias"), json!(false)],
            &params,
            &tx_announce,
            &data_dir,
        )
        .expect("rpc");

        let obj = value.as_object().expect("object");
        assert!(obj.contains_key("overall"));
        let detail = obj
            .get("detail")
            .and_then(Value::as_array)
            .expect("detail array");
        assert_eq!(detail.len(), 1);
        let entry = detail[0].as_object().expect("detail entry");
        for key in [
            "alias",
            "outpoint",
            "transaction_built",
            "transaction_signed",
            "transaction_commited",
            "result",
            "errorMessage",
            "error",
        ] {
            assert!(entry.contains_key(key), "missing key {key}");
        }
    }

    #[test]
    fn startdeterministicfluxnode_uses_wallet_collateral_key_for_p2pkh() {
        use fluxd_consensus::upgrades::UpgradeIndex;

        let (chainstate, mut params, data_dir) = setup_regtest_chainstate();
        params.consensus.upgrades[UpgradeIndex::Kamata.as_usize()].activation_height = 0;

        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));
        let address = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let operator_wif = rpc_dumpprivkey(&wallet, vec![json!(address.clone())], &params)
            .expect("rpc")
            .as_str()
            .expect("wif string")
            .to_string();
        let script_pubkey = address_to_script_pubkey(&address, params.network).expect("script");

        let collateral = OutPoint {
            hash: [0x44u8; 32],
            index: 0,
        };
        let txhash_hex = hash256_to_hex(&collateral.hash);
        std::fs::write(
            data_dir.join("fluxnode.conf"),
            format!("fn1 127.0.0.1:16125 {operator_wif} {txhash_hex} 0\n"),
        )
        .expect("write fluxnode.conf");

        let utxo = fluxd_chainstate::utxo::UtxoEntry {
            value: 1_000 * COIN,
            script_pubkey,
            height: 0,
            is_coinbase: false,
        };
        let key = fluxd_chainstate::utxo::outpoint_key_bytes(&collateral);
        let mut batch = WriteBatch::new();
        batch.put(Column::Utxo, key.as_bytes(), utxo.encode());
        chainstate.commit_batch(batch).expect("commit utxo");

        extend_regtest_chain_to_height(
            &chainstate,
            &params,
            fluxd_consensus::constants::FLUXNODE_MIN_CONFIRMATION_DETERMINISTIC,
        );
        let best_height = best_block_height(&chainstate).expect("best height");
        assert!(
            best_height >= fluxd_consensus::constants::FLUXNODE_MIN_CONFIRMATION_DETERMINISTIC,
            "best_height={best_height}"
        );

        let mempool = Mutex::new(Mempool::new(0));
        let mempool_policy = MempoolPolicy::standard(0, false);
        let mempool_metrics = MempoolMetrics::default();
        let fee_estimator = Mutex::new(FeeEstimator::new(128));
        let mempool_flags = ValidationFlags::default();
        let (tx_announce, _rx) = broadcast::channel(16);

        let value = rpc_startdeterministicfluxnode(
            &chainstate,
            &wallet,
            &mempool,
            &mempool_policy,
            &mempool_metrics,
            &fee_estimator,
            &mempool_flags,
            vec![json!("fn1"), json!(false)],
            &params,
            &tx_announce,
            &data_dir,
        )
        .expect("rpc");

        let detail = value
            .get("detail")
            .and_then(Value::as_array)
            .expect("detail array");
        assert_eq!(detail.len(), 1);
        let entry = detail[0].as_object().expect("detail entry");
        let result = entry.get("result").and_then(Value::as_str);
        assert_eq!(result, Some("successful"), "entry={entry:?}");
        assert!(
            entry
                .get("txid")
                .and_then(Value::as_str)
                .map(is_hex_64)
                .unwrap_or(false),
            "entry={entry:?}"
        );
    }

    #[test]
    fn getblockhash_rejects_wrong_param_count() {
        let (chainstate, _params, _data_dir) = setup_regtest_chainstate();
        let err = rpc_getblockhash(&chainstate, Vec::new()).unwrap_err();
        assert_eq!(err.code, RPC_INVALID_PARAMETER);
    }

    #[test]
    fn getblockhash_rejects_out_of_range_height() {
        let (chainstate, _params, _data_dir) = setup_regtest_chainstate();
        let err = rpc_getblockhash(&chainstate, vec![json!(1)]).unwrap_err();
        assert_eq!(err.code, RPC_INVALID_PARAMETER);
    }

    #[test]
    fn getblockheader_returns_not_found_code() {
        let (chainstate, params, _data_dir) = setup_regtest_chainstate();
        let missing_hash = Value::String("00".repeat(32));
        let err = rpc_getblockheader(&chainstate, vec![missing_hash], &params).unwrap_err();
        assert_eq!(err.code, RPC_INVALID_ADDRESS_OR_KEY);
    }

    #[test]
    fn help_lists_supported_methods() {
        let value = rpc_help(Vec::new()).expect("rpc");
        let methods = value.as_array().expect("array");
        assert!(methods.iter().any(|val| val.as_str() == Some("getinfo")));
        assert!(methods
            .iter()
            .any(|val| val.as_str() == Some("getblockcount")));
    }

    #[test]
    fn help_reports_supported_method() {
        let value = rpc_help(vec![json!("getinfo")]).expect("rpc");
        assert_eq!(value.as_str(), Some("getinfo is supported"));
    }

    #[test]
    fn help_unknown_method_returns_not_found() {
        let err = rpc_help(vec![json!("notarealmethod")]).unwrap_err();
        assert_eq!(err.code, RPC_METHOD_NOT_FOUND);
    }

    #[test]
    fn wallet_getnewaddress_and_dumpprivkey_roundtrip() {
        let (_chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let address = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let wif = rpc_dumpprivkey(&wallet, vec![json!(address.clone())], &params)
            .expect("rpc")
            .as_str()
            .expect("wif string")
            .to_string();

        let decoded = wif_to_secret_key(&wif, params.network);
        assert!(decoded.is_ok(), "wif should decode");

        let err = rpc_dumpprivkey(&wallet, vec![json!("t1invalidaddress")], &params).unwrap_err();
        assert_eq!(err.code, RPC_INVALID_ADDRESS_OR_KEY);
    }

    #[test]
    fn wallet_getnewaddress_errors_when_keypool_empty_and_wallet_locked() {
        let (_chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));
        rpc_encryptwallet(&wallet, vec![json!("passphrase")]).expect("encryptwallet");

        let err = rpc_getnewaddress(&wallet, Vec::new()).unwrap_err();
        assert_eq!(err.code, RPC_WALLET_KEYPOOL_RAN_OUT);
        assert!(err.message.contains("Keypool ran out"));
    }

    #[test]
    fn wallet_getrawchangeaddress_and_dumpprivkey_roundtrip() {
        let (_chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let address = rpc_getrawchangeaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let wif = rpc_dumpprivkey(&wallet, vec![json!(address)], &params)
            .expect("rpc")
            .as_str()
            .expect("wif string")
            .to_string();

        let decoded = wif_to_secret_key(&wif, params.network);
        assert!(decoded.is_ok(), "wif should decode");
    }

    #[test]
    fn wallet_getrawchangeaddress_errors_when_keypool_empty_and_wallet_locked() {
        let (_chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));
        rpc_encryptwallet(&wallet, vec![json!("passphrase")]).expect("encryptwallet");

        let err = rpc_getrawchangeaddress(&wallet, Vec::new()).unwrap_err();
        assert_eq!(err.code, RPC_WALLET_KEYPOOL_RAN_OUT);
        assert!(err.message.contains("Keypool ran out"));
    }

    #[test]
    fn wallet_getrawchangeaddress_ignores_optional_param() {
        let (_chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let address = rpc_getrawchangeaddress(&wallet, vec![json!(123)])
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let wif = rpc_dumpprivkey(&wallet, vec![json!(address)], &params)
            .expect("rpc")
            .as_str()
            .expect("wif string")
            .to_string();

        let decoded = wif_to_secret_key(&wif, params.network);
        assert!(decoded.is_ok(), "wif should decode");
    }

    #[test]
    fn backupwallet_writes_copy_of_wallet_dat() {
        let (_chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let _ = rpc_getnewaddress(&wallet, Vec::new()).expect("rpc");

        let backup_path = temp_data_dir("fluxd-wallet-backup").join("wallet.bak");
        let backup_string = backup_path.to_string_lossy().to_string();
        rpc_backupwallet(&wallet, vec![json!(backup_string)]).expect("rpc");

        let original =
            std::fs::read(data_dir.join(crate::wallet::WALLET_FILE_NAME)).expect("read wallet.dat");
        let backup = std::fs::read(&backup_path).expect("read backup");
        assert_eq!(backup, original);
    }

    #[test]
    fn dumpwallet_exports_keypool_and_roundtrips_importwallet() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        rpc_keypoolrefill(&wallet, vec![json!(2)]).expect("rpc");

        let dump_dir = temp_data_dir("fluxd-rpc-test-dumpwallet");
        std::fs::create_dir_all(&dump_dir).expect("create dump dir");
        let dump_path = dump_dir.join("dumpwallet.txt");
        let dump_string = dump_path.to_string_lossy().to_string();

        let value = rpc_dumpwallet(&wallet, vec![json!(dump_string.clone())], &data_dir)
            .expect("rpc")
            .as_str()
            .expect("path string")
            .to_string();
        assert_eq!(value, dump_string);

        let contents = std::fs::read_to_string(&dump_path).expect("read dump");
        let key_lines: Vec<&str> = contents
            .lines()
            .filter(|line| {
                let trimmed = line.trim();
                !(trimmed.is_empty() || trimmed.starts_with('#'))
            })
            .collect();
        assert_eq!(key_lines.len(), 2);
        assert!(key_lines.iter().all(|line| line.contains("reserve=1")));

        let other_dir = temp_data_dir("fluxd-rpc-test-dumpwallet-import");
        std::fs::create_dir_all(&other_dir).expect("create import dir");
        let wallet_b =
            Mutex::new(Wallet::load_or_create(&other_dir, params.network).expect("wallet"));
        rpc_importwallet(&chainstate, &wallet_b, vec![json!(dump_string)]).expect("rpc");
        assert_eq!(wallet_b.lock().expect("wallet lock").key_count(), 2);

        let err = rpc_dumpwallet(&wallet, vec![json!(dump_path.to_string_lossy())], &data_dir)
            .unwrap_err();
        assert_eq!(err.code, RPC_INVALID_PARAMETER);
        assert!(err.message.contains("Cannot overwrite existing file"));
    }

    #[test]
    fn dumpwallet_exports_labels_and_importwallet_restores_them() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        rpc_keypoolrefill(&wallet, vec![json!(2)]).expect("rpc");
        rpc_encryptwallet(&wallet, vec![json!("test-passphrase")]).expect("rpc");

        let address = rpc_getnewaddress(&wallet, vec![json!("hello world")])
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();

        {
            let mut guard = wallet.lock().expect("wallet lock");
            guard
                .walletpassphrase("test-passphrase", 60)
                .expect("unlock wallet");
        }

        let dump_dir = temp_data_dir("fluxd-rpc-test-dumpwallet-labels");
        std::fs::create_dir_all(&dump_dir).expect("create dump dir");
        let dump_path = dump_dir.join("dumpwallet.txt");
        let dump_string = dump_path.to_string_lossy().to_string();

        let value = rpc_dumpwallet(&wallet, vec![json!(dump_string.clone())], &data_dir)
            .expect("rpc")
            .as_str()
            .expect("path string")
            .to_string();
        assert_eq!(value, dump_string);

        let contents = std::fs::read_to_string(&dump_path).expect("read dump");
        let addr_marker = format!("# addr={address}");
        let line = contents
            .lines()
            .find(|line| line.contains(addr_marker.as_str()))
            .expect("wallet dump line for address");
        assert!(
            line.contains("label=hello%20world"),
            "expected percent-encoded label in dumpwallet line: {line}"
        );

        let other_dir = temp_data_dir("fluxd-rpc-test-dumpwallet-labels-import");
        std::fs::create_dir_all(&other_dir).expect("create import dir");
        let wallet_b =
            Mutex::new(Wallet::load_or_create(&other_dir, params.network).expect("wallet"));
        rpc_importwallet(&chainstate, &wallet_b, vec![json!(dump_string)]).expect("rpc");

        let ok =
            rpc_validateaddress(&wallet_b, vec![Value::String(address)], &params).expect("rpc");
        let obj = ok.as_object().expect("object");
        assert_eq!(obj.get("isvalid").and_then(Value::as_bool), Some(true));
        assert_eq!(obj.get("ismine").and_then(Value::as_bool), Some(true));
        assert_eq!(
            obj.get("account").and_then(Value::as_str),
            Some("hello world")
        );
    }

    #[test]
    fn z_exportwallet_exports_sapling_spending_key_and_disallows_overwrite() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let zaddr = rpc_zgetnewaddress(&chainstate, &wallet, Vec::new(), &params)
            .expect("rpc")
            .as_str()
            .expect("zaddr")
            .to_string();

        let dump_dir = temp_data_dir("fluxd-rpc-test-zexportwallet");
        std::fs::create_dir_all(&dump_dir).expect("create dump dir");
        let dump_path = dump_dir.join("z_exportwallet.txt");
        let dump_string = dump_path.to_string_lossy().to_string();

        let value = rpc_zexportwallet(&wallet, vec![json!(dump_string.clone())], &data_dir)
            .expect("rpc")
            .as_str()
            .expect("path string")
            .to_string();
        assert_eq!(value, dump_string);

        let contents = std::fs::read_to_string(&dump_path).expect("read dump");
        assert!(contents.contains("secret-extended-key-regtest1"));
        assert!(contents.contains(&zaddr));

        let err = rpc_zexportwallet(&wallet, vec![json!(dump_string)], &data_dir).unwrap_err();
        assert_eq!(err.code, RPC_INVALID_PARAMETER);
        assert!(err.message.contains("Cannot overwrite existing file"));
    }

    #[test]
    fn keypoolrefill_fills_keypool() {
        let (_chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));
        assert_eq!(wallet.lock().expect("wallet lock").key_count(), 0);

        rpc_keypoolrefill(&wallet, vec![json!(2)]).expect("rpc");
        let guard = wallet.lock().expect("wallet lock");
        assert_eq!(guard.key_count(), 0);
        assert_eq!(guard.keypool_size(), 2);
        assert!(guard.keypool_oldest() > 0);
    }

    #[test]
    fn settxfee_increases_fundrawtransaction_fee() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let from_address = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let from_script =
            address_to_script_pubkey(&from_address, params.network).expect("address script");

        let outpoint = OutPoint {
            hash: [0x11u8; 32],
            index: 0,
        };
        let utxo_entry = fluxd_chainstate::utxo::UtxoEntry {
            value: 5 * COIN,
            script_pubkey: from_script.clone(),
            height: 0,
            is_coinbase: false,
        };
        let utxo_key = fluxd_chainstate::utxo::outpoint_key_bytes(&outpoint);
        let addr_key =
            fluxd_chainstate::address_index::address_outpoint_key(&from_script, &outpoint)
                .expect("address outpoint key");
        let mut batch = WriteBatch::new();
        batch.put(Column::Utxo, utxo_key.as_bytes(), utxo_entry.encode());
        batch.put(Column::AddressOutpoint, addr_key, []);
        chainstate.commit_batch(batch).expect("commit utxo");

        let mempool = Mutex::new(Mempool::new(0));
        let mempool_policy = MempoolPolicy::standard(1000, true);
        let fee_estimator = Mutex::new(FeeEstimator::new(mempool_policy.min_relay_fee_per_kb));

        let to_script = p2pkh_script([0x22u8; 20]);
        let tx = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: Vec::new(),
            vout: vec![TxOut {
                value: 1 * COIN,
                script_pubkey: to_script,
            }],
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let raw_hex = hex_bytes(&tx.consensus_encode().expect("encode tx"));

        let before = rpc_fundrawtransaction(
            &chainstate,
            &mempool,
            &mempool_policy,
            &fee_estimator,
            2,
            &wallet,
            vec![json!(raw_hex.clone())],
            &params,
            FundTransactionControl::default(),
        )
        .expect("rpc");
        let before_fee = before
            .get("fee_zat")
            .and_then(Value::as_i64)
            .expect("fee_zat");

        rpc_settxfee(&wallet, vec![json!("0.01")]).expect("rpc");
        let info = rpc_getwalletinfo(&chainstate, &mempool, &wallet, Vec::new()).expect("rpc");
        assert_eq!(
            info.get("paytxfee_zat").and_then(Value::as_i64),
            Some(1_000_000)
        );

        let after = rpc_fundrawtransaction(
            &chainstate,
            &mempool,
            &mempool_policy,
            &fee_estimator,
            2,
            &wallet,
            vec![json!(raw_hex)],
            &params,
            FundTransactionControl::default(),
        )
        .expect("rpc");
        let after_fee = after
            .get("fee_zat")
            .and_then(Value::as_i64)
            .expect("fee_zat");
        assert!(after_fee > before_fee, "fee should increase after settxfee");
    }

    #[test]
    fn settxfee_persists_across_restart() {
        let (_chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        rpc_settxfee(&wallet, vec![json!("0.01")]).expect("rpc");
        drop(wallet);

        let wallet_reload = Wallet::load_or_create(&data_dir, params.network).expect("wallet");
        assert_eq!(wallet_reload.pay_tx_fee_per_kb(), 1_000_000);
    }

    #[test]
    fn fundrawtransaction_can_select_spendable_p2sh_multisig_utxo() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let addr_a = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address")
            .to_string();
        let addr_b = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address")
            .to_string();

        let multisig_address =
            rpc_addmultisigaddress(&wallet, vec![json!(2), json!([addr_a, addr_b])], &params)
                .expect("rpc")
                .as_str()
                .expect("multisig address")
                .to_string();

        let multisig_script =
            address_to_script_pubkey(&multisig_address, params.network).expect("multisig script");
        assert_eq!(classify_script_pubkey(&multisig_script), ScriptType::P2Sh);

        let validate =
            rpc_validateaddress(&wallet, vec![json!(multisig_address)], &params).expect("rpc");
        assert_eq!(validate.get("ismine").and_then(Value::as_bool), Some(true));
        assert_eq!(
            validate.get("iswatchonly").and_then(Value::as_bool),
            Some(false)
        );

        let outpoint = OutPoint {
            hash: [0x33u8; 32],
            index: 0,
        };
        let utxo_entry = fluxd_chainstate::utxo::UtxoEntry {
            value: 5 * COIN,
            script_pubkey: multisig_script.clone(),
            height: 0,
            is_coinbase: false,
        };
        let utxo_key = fluxd_chainstate::utxo::outpoint_key_bytes(&outpoint);
        let addr_key =
            fluxd_chainstate::address_index::address_outpoint_key(&multisig_script, &outpoint)
                .expect("address outpoint key");
        let mut batch = WriteBatch::new();
        batch.put(Column::Utxo, utxo_key.as_bytes(), utxo_entry.encode());
        batch.put(Column::AddressOutpoint, addr_key, []);
        chainstate.commit_batch(batch).expect("commit utxo");

        let mempool = Mutex::new(Mempool::new(0));
        let mempool_policy = MempoolPolicy::standard(1000, true);
        let fee_estimator = Mutex::new(FeeEstimator::new(mempool_policy.min_relay_fee_per_kb));

        let value =
            rpc_listunspent(&chainstate, &mempool, &wallet, Vec::new(), &params).expect("rpc");
        let arr = value.as_array().expect("array");
        assert_eq!(arr.len(), 1);
        assert_eq!(arr[0].get("spendable").and_then(Value::as_bool), Some(true));

        let to_script = p2pkh_script([0x22u8; 20]);
        let tx = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: Vec::new(),
            vout: vec![TxOut {
                value: 1 * COIN,
                script_pubkey: to_script,
            }],
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let raw_hex = hex_bytes(&tx.consensus_encode().expect("encode tx"));

        let funded = rpc_fundrawtransaction(
            &chainstate,
            &mempool,
            &mempool_policy,
            &fee_estimator,
            2,
            &wallet,
            vec![json!(raw_hex)],
            &params,
            FundTransactionControl::default(),
        )
        .expect("rpc");
        let funded_hex = funded
            .get("hex")
            .and_then(Value::as_str)
            .expect("hex")
            .to_string();
        let funded_bytes = bytes_from_hex(&funded_hex).expect("decode hex");
        let funded_tx =
            Transaction::consensus_decode(&funded_bytes).expect("decode funded transaction");
        assert!(
            funded_tx.vin.iter().any(|input| input.prevout == outpoint),
            "funded tx should select multisig outpoint"
        );
    }

    #[test]
    fn lockunspent_excludes_utxo_from_coin_selection() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let from_address = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let from_script =
            address_to_script_pubkey(&from_address, params.network).expect("address script");

        let outpoint = OutPoint {
            hash: [0x44u8; 32],
            index: 0,
        };
        let utxo_entry = fluxd_chainstate::utxo::UtxoEntry {
            value: 2 * COIN,
            script_pubkey: from_script.clone(),
            height: 0,
            is_coinbase: false,
        };
        let utxo_key = fluxd_chainstate::utxo::outpoint_key_bytes(&outpoint);
        let addr_key =
            fluxd_chainstate::address_index::address_outpoint_key(&from_script, &outpoint)
                .expect("address outpoint key");
        let mut batch = WriteBatch::new();
        batch.put(Column::Utxo, utxo_key.as_bytes(), utxo_entry.encode());
        batch.put(Column::AddressOutpoint, addr_key, []);
        chainstate.commit_batch(batch).expect("commit utxo");

        let mempool = Mutex::new(Mempool::new(0));
        let value =
            rpc_listunspent(&chainstate, &mempool, &wallet, Vec::new(), &params).expect("rpc");
        let arr = value.as_array().expect("array");
        assert_eq!(arr.len(), 1);
        assert_eq!(arr[0].get("spendable").and_then(Value::as_bool), Some(true));

        let outputs = json!([{
            "txid": hash256_to_hex(&outpoint.hash),
            "vout": outpoint.index,
        }]);
        rpc_lockunspent(&wallet, vec![json!(false), outputs]).expect("rpc");

        let value = rpc_listlockunspent(&wallet, Vec::new()).expect("rpc");
        let locked = value.as_array().expect("array");
        assert_eq!(locked.len(), 1);

        let value =
            rpc_listunspent(&chainstate, &mempool, &wallet, Vec::new(), &params).expect("rpc");
        let arr = value.as_array().expect("array");
        assert_eq!(arr.len(), 0, "locked coins are excluded from listunspent");

        let mempool_policy = MempoolPolicy::standard(1000, true);
        let fee_estimator = Mutex::new(FeeEstimator::new(mempool_policy.min_relay_fee_per_kb));
        let to_script = p2pkh_script([0x22u8; 20]);
        let tx = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: Vec::new(),
            vout: vec![TxOut {
                value: 1 * COIN,
                script_pubkey: to_script,
            }],
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let raw_hex = hex_bytes(&tx.consensus_encode().expect("encode tx"));

        let err = rpc_fundrawtransaction(
            &chainstate,
            &mempool,
            &mempool_policy,
            &fee_estimator,
            2,
            &wallet,
            vec![json!(raw_hex.clone())],
            &params,
            FundTransactionControl::default(),
        )
        .unwrap_err();
        assert_eq!(err.code, RPC_WALLET_ERROR);

        rpc_lockunspent(&wallet, vec![json!(true)]).expect("rpc unlockall");

        let value = rpc_fundrawtransaction(
            &chainstate,
            &mempool,
            &mempool_policy,
            &fee_estimator,
            2,
            &wallet,
            vec![json!(raw_hex)],
            &params,
            FundTransactionControl::default(),
        )
        .expect("rpc");
        assert!(value.get("hex").and_then(Value::as_str).is_some());
    }

    #[test]
    fn fundrawtransaction_accepts_unsigned_p2sh_inputs_when_wallet_has_redeem_script() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let addr_a = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address")
            .to_string();
        let addr_b = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address")
            .to_string();

        let multisig_address =
            rpc_addmultisigaddress(&wallet, vec![json!(2), json!([addr_a, addr_b])], &params)
                .expect("rpc")
                .as_str()
                .expect("multisig address")
                .to_string();
        let multisig_script =
            address_to_script_pubkey(&multisig_address, params.network).expect("multisig script");

        let outpoint = OutPoint {
            hash: [0x41u8; 32],
            index: 0,
        };
        let utxo_entry = fluxd_chainstate::utxo::UtxoEntry {
            value: 5 * COIN,
            script_pubkey: multisig_script.clone(),
            height: 0,
            is_coinbase: false,
        };
        let utxo_key = fluxd_chainstate::utxo::outpoint_key_bytes(&outpoint);
        let addr_key =
            fluxd_chainstate::address_index::address_outpoint_key(&multisig_script, &outpoint)
                .expect("address outpoint key");
        let mut batch = WriteBatch::new();
        batch.put(Column::Utxo, utxo_key.as_bytes(), utxo_entry.encode());
        batch.put(Column::AddressOutpoint, addr_key, []);
        chainstate.commit_batch(batch).expect("commit utxo");

        let mempool = Mutex::new(Mempool::new(0));
        let mempool_policy = MempoolPolicy::standard(1000, true);
        let fee_estimator = Mutex::new(FeeEstimator::new(mempool_policy.min_relay_fee_per_kb));

        let to_script = p2pkh_script([0x22u8; 20]);
        let tx = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: vec![TxIn {
                prevout: outpoint,
                script_sig: Vec::new(),
                sequence: u32::MAX,
            }],
            vout: vec![TxOut {
                value: 1 * COIN,
                script_pubkey: to_script,
            }],
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let raw_hex = hex_bytes(&tx.consensus_encode().expect("encode tx"));

        let value = rpc_fundrawtransaction(
            &chainstate,
            &mempool,
            &mempool_policy,
            &fee_estimator,
            2,
            &wallet,
            vec![json!(raw_hex)],
            &params,
            FundTransactionControl::default(),
        )
        .expect("rpc");
        assert!(value.get("hex").and_then(Value::as_str).is_some());
    }

    #[test]
    fn fundrawtransaction_options_minconf_filters_utxos() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let from_address = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let from_script =
            address_to_script_pubkey(&from_address, params.network).expect("address script");

        let outpoint = OutPoint {
            hash: [0x11u8; 32],
            index: 0,
        };
        let utxo_entry = fluxd_chainstate::utxo::UtxoEntry {
            value: 5 * COIN,
            script_pubkey: from_script.clone(),
            height: 0,
            is_coinbase: false,
        };
        let utxo_key = fluxd_chainstate::utxo::outpoint_key_bytes(&outpoint);
        let addr_key =
            fluxd_chainstate::address_index::address_outpoint_key(&from_script, &outpoint)
                .expect("address outpoint key");
        let mut batch = WriteBatch::new();
        batch.put(Column::Utxo, utxo_key.as_bytes(), utxo_entry.encode());
        batch.put(Column::AddressOutpoint, addr_key, []);
        chainstate.commit_batch(batch).expect("commit utxo");

        let mempool = Mutex::new(Mempool::new(0));
        let mempool_policy = MempoolPolicy::standard(1000, true);
        let fee_estimator = Mutex::new(FeeEstimator::new(mempool_policy.min_relay_fee_per_kb));

        let tx = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: Vec::new(),
            vout: vec![TxOut {
                value: 1 * COIN,
                script_pubkey: p2pkh_script([0x22u8; 20]),
            }],
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let raw_hex = hex_bytes(&tx.consensus_encode().expect("encode tx"));

        let err = rpc_fundrawtransaction(
            &chainstate,
            &mempool,
            &mempool_policy,
            &fee_estimator,
            2,
            &wallet,
            vec![json!(raw_hex), json!({"minconf": 2})],
            &params,
            FundTransactionControl::default(),
        )
        .unwrap_err();
        assert_eq!(err.code, RPC_WALLET_ERROR);
        assert!(err.message.contains("insufficient funds"));
    }

    #[test]
    fn fundrawtransaction_options_subtract_fee_from_outputs_adjusts_recipient_value() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let from_address = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let from_script =
            address_to_script_pubkey(&from_address, params.network).expect("address script");

        let outpoint = OutPoint {
            hash: [0x11u8; 32],
            index: 0,
        };
        let utxo_entry = fluxd_chainstate::utxo::UtxoEntry {
            value: 5 * COIN,
            script_pubkey: from_script.clone(),
            height: 0,
            is_coinbase: false,
        };
        let utxo_key = fluxd_chainstate::utxo::outpoint_key_bytes(&outpoint);
        let addr_key =
            fluxd_chainstate::address_index::address_outpoint_key(&from_script, &outpoint)
                .expect("address outpoint key");
        let mut batch = WriteBatch::new();
        batch.put(Column::Utxo, utxo_key.as_bytes(), utxo_entry.encode());
        batch.put(Column::AddressOutpoint, addr_key, []);
        chainstate.commit_batch(batch).expect("commit utxo");

        let mempool = Mutex::new(Mempool::new(0));
        let mempool_policy = MempoolPolicy::standard(1000, true);
        let fee_estimator = Mutex::new(FeeEstimator::new(mempool_policy.min_relay_fee_per_kb));

        let tx = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: Vec::new(),
            vout: vec![TxOut {
                value: 1 * COIN,
                script_pubkey: p2pkh_script([0x22u8; 20]),
            }],
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let raw_hex = hex_bytes(&tx.consensus_encode().expect("encode tx"));

        let value = rpc_fundrawtransaction(
            &chainstate,
            &mempool,
            &mempool_policy,
            &fee_estimator,
            2,
            &wallet,
            vec![json!(raw_hex), json!({"subtractFeeFromOutputs": [0]})],
            &params,
            FundTransactionControl::default(),
        )
        .expect("rpc");

        assert_eq!(
            value.get("changepos").and_then(Value::as_i64),
            Some(1),
            "subtractFeeFromOutputs disables change randomization"
        );
        let fee_zat = value
            .get("fee_zat")
            .and_then(Value::as_i64)
            .expect("fee_zat");
        assert!(fee_zat > 0, "expected non-zero fee");

        let funded_hex = value.get("hex").and_then(Value::as_str).expect("hex");
        let funded_bytes = bytes_from_hex(funded_hex).expect("hex decode");
        let funded_tx = Transaction::consensus_decode(&funded_bytes).expect("decode funded tx");
        assert_eq!(funded_tx.vout.len(), 2);
        assert_eq!(funded_tx.vout[0].value, COIN - fee_zat);
        assert_eq!(funded_tx.vout[1].value, 4 * COIN);
    }

    #[test]
    fn fundrawtransaction_options_change_position_places_change_output_at_requested_index() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let from_address = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let from_script =
            address_to_script_pubkey(&from_address, params.network).expect("address script");

        let outpoint = OutPoint {
            hash: [0x11u8; 32],
            index: 0,
        };
        let utxo_entry = fluxd_chainstate::utxo::UtxoEntry {
            value: 5 * COIN,
            script_pubkey: from_script.clone(),
            height: 0,
            is_coinbase: false,
        };
        let utxo_key = fluxd_chainstate::utxo::outpoint_key_bytes(&outpoint);
        let addr_key =
            fluxd_chainstate::address_index::address_outpoint_key(&from_script, &outpoint)
                .expect("address outpoint key");
        let mut batch = WriteBatch::new();
        batch.put(Column::Utxo, utxo_key.as_bytes(), utxo_entry.encode());
        batch.put(Column::AddressOutpoint, addr_key, []);
        chainstate.commit_batch(batch).expect("commit utxo");

        let mempool = Mutex::new(Mempool::new(0));
        let mempool_policy = MempoolPolicy::standard(1000, true);
        let fee_estimator = Mutex::new(FeeEstimator::new(mempool_policy.min_relay_fee_per_kb));

        let tx = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: Vec::new(),
            vout: vec![TxOut {
                value: 1 * COIN,
                script_pubkey: p2pkh_script([0x22u8; 20]),
            }],
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let raw_hex = hex_bytes(&tx.consensus_encode().expect("encode tx"));

        let value = rpc_fundrawtransaction(
            &chainstate,
            &mempool,
            &mempool_policy,
            &fee_estimator,
            2,
            &wallet,
            vec![json!(raw_hex), json!({"changePosition": 0})],
            &params,
            FundTransactionControl::default(),
        )
        .expect("rpc");

        assert_eq!(value.get("changepos").and_then(Value::as_i64), Some(0));
        let fee_zat = value
            .get("fee_zat")
            .and_then(Value::as_i64)
            .expect("fee_zat");
        assert!(fee_zat > 0, "expected non-zero fee");

        let funded_hex = value.get("hex").and_then(Value::as_str).expect("hex");
        let funded_bytes = bytes_from_hex(funded_hex).expect("hex decode");
        let funded_tx = Transaction::consensus_decode(&funded_bytes).expect("decode funded tx");
        assert_eq!(funded_tx.vout.len(), 2);
        assert_eq!(funded_tx.vout[0].value, 4 * COIN - fee_zat);
        assert_eq!(funded_tx.vout[1].value, 1 * COIN);
    }

    #[test]
    fn fundrawtransaction_options_change_address_overrides_change_destination() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let from_address = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let from_script =
            address_to_script_pubkey(&from_address, params.network).expect("address script");

        let outpoint = OutPoint {
            hash: [0x11u8; 32],
            index: 0,
        };
        let utxo_entry = fluxd_chainstate::utxo::UtxoEntry {
            value: 5 * COIN,
            script_pubkey: from_script.clone(),
            height: 0,
            is_coinbase: false,
        };
        let utxo_key = fluxd_chainstate::utxo::outpoint_key_bytes(&outpoint);
        let addr_key =
            fluxd_chainstate::address_index::address_outpoint_key(&from_script, &outpoint)
                .expect("address outpoint key");
        let mut batch = WriteBatch::new();
        batch.put(Column::Utxo, utxo_key.as_bytes(), utxo_entry.encode());
        batch.put(Column::AddressOutpoint, addr_key, []);
        chainstate.commit_batch(batch).expect("commit utxo");

        let mempool = Mutex::new(Mempool::new(0));
        let mempool_policy = MempoolPolicy::standard(1000, true);
        let fee_estimator = Mutex::new(FeeEstimator::new(mempool_policy.min_relay_fee_per_kb));

        let change_script = p2pkh_script([0x33u8; 20]);
        let change_address =
            script_pubkey_to_address(&change_script, params.network).expect("change address");

        let tx = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: Vec::new(),
            vout: vec![TxOut {
                value: 1 * COIN,
                script_pubkey: p2pkh_script([0x22u8; 20]),
            }],
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let raw_hex = hex_bytes(&tx.consensus_encode().expect("encode tx"));

        let value = rpc_fundrawtransaction(
            &chainstate,
            &mempool,
            &mempool_policy,
            &fee_estimator,
            2,
            &wallet,
            vec![json!(raw_hex), json!({"changeAddress": change_address})],
            &params,
            FundTransactionControl::default(),
        )
        .expect("rpc");

        let changepos = value
            .get("changepos")
            .and_then(Value::as_i64)
            .expect("changepos");
        assert!(changepos >= 0);
        let change_index = usize::try_from(changepos).expect("changepos usize");
        let fee_zat = value
            .get("fee_zat")
            .and_then(Value::as_i64)
            .expect("fee_zat");
        assert!(fee_zat > 0, "expected non-zero fee");

        let funded_hex = value.get("hex").and_then(Value::as_str).expect("hex");
        let funded_bytes = bytes_from_hex(funded_hex).expect("hex decode");
        let funded_tx = Transaction::consensus_decode(&funded_bytes).expect("decode funded tx");
        assert_eq!(funded_tx.vout.len(), 2);
        let change_out = funded_tx.vout.get(change_index).expect("change vout");
        assert_eq!(change_out.script_pubkey, change_script);
        assert_eq!(change_out.value, 4 * COIN - fee_zat);
    }

    #[test]
    fn fundrawtransaction_options_include_watching_allows_funding_from_watchonly_utxo() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let watch_script = p2pkh_script([0x55u8; 20]);
        let watch_address =
            script_pubkey_to_address(&watch_script, params.network).expect("watch address");

        let outpoint = OutPoint {
            hash: [0x55u8; 32],
            index: 0,
        };
        let utxo_entry = fluxd_chainstate::utxo::UtxoEntry {
            value: 3 * COIN,
            script_pubkey: watch_script.clone(),
            height: 0,
            is_coinbase: false,
        };
        let utxo_key = fluxd_chainstate::utxo::outpoint_key_bytes(&outpoint);
        let addr_key =
            fluxd_chainstate::address_index::address_outpoint_key(&watch_script, &outpoint)
                .expect("address outpoint key");
        let mut batch = WriteBatch::new();
        batch.put(Column::Utxo, utxo_key.as_bytes(), utxo_entry.encode());
        batch.put(Column::AddressOutpoint, addr_key, []);
        chainstate.commit_batch(batch).expect("commit utxo");

        rpc_importaddress(
            &chainstate,
            &wallet,
            vec![json!(watch_address), Value::Null, json!(false)],
            &params,
        )
        .expect("rpc");

        let mempool = Mutex::new(Mempool::new(0));
        let mempool_policy = MempoolPolicy::standard(1000, true);
        let fee_estimator = Mutex::new(FeeEstimator::new(mempool_policy.min_relay_fee_per_kb));

        let tx = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: Vec::new(),
            vout: vec![TxOut {
                value: 1 * COIN,
                script_pubkey: p2pkh_script([0x22u8; 20]),
            }],
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let raw_hex = hex_bytes(&tx.consensus_encode().expect("encode tx"));

        let err = rpc_fundrawtransaction(
            &chainstate,
            &mempool,
            &mempool_policy,
            &fee_estimator,
            2,
            &wallet,
            vec![json!(raw_hex.clone())],
            &params,
            FundTransactionControl::default(),
        )
        .unwrap_err();
        assert_eq!(err.code, RPC_WALLET_ERROR);
        assert!(err.message.contains("insufficient funds"));

        let value = rpc_fundrawtransaction(
            &chainstate,
            &mempool,
            &mempool_policy,
            &fee_estimator,
            2,
            &wallet,
            vec![json!(raw_hex), json!({"includeWatching": true})],
            &params,
            FundTransactionControl::default(),
        )
        .expect("rpc");

        let funded_hex = value.get("hex").and_then(Value::as_str).expect("hex");
        let funded_bytes = bytes_from_hex(funded_hex).expect("hex decode");
        let funded_tx = Transaction::consensus_decode(&funded_bytes).expect("decode funded tx");
        assert_eq!(funded_tx.vin.len(), 1);
        assert_eq!(funded_tx.vin[0].prevout.hash, [0x55u8; 32]);
        assert_eq!(funded_tx.vin[0].prevout.index, 0);
    }

    #[test]
    fn fundrawtransaction_options_lock_unspents_locks_selected_inputs() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let from_address = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let from_script =
            address_to_script_pubkey(&from_address, params.network).expect("address script");

        let outpoint = OutPoint {
            hash: [0x11u8; 32],
            index: 0,
        };
        let utxo_entry = fluxd_chainstate::utxo::UtxoEntry {
            value: 5 * COIN,
            script_pubkey: from_script.clone(),
            height: 0,
            is_coinbase: false,
        };
        let utxo_key = fluxd_chainstate::utxo::outpoint_key_bytes(&outpoint);
        let addr_key =
            fluxd_chainstate::address_index::address_outpoint_key(&from_script, &outpoint)
                .expect("address outpoint key");
        let mut batch = WriteBatch::new();
        batch.put(Column::Utxo, utxo_key.as_bytes(), utxo_entry.encode());
        batch.put(Column::AddressOutpoint, addr_key, []);
        chainstate.commit_batch(batch).expect("commit utxo");

        let mempool = Mutex::new(Mempool::new(0));
        let mempool_policy = MempoolPolicy::standard(1000, true);
        let fee_estimator = Mutex::new(FeeEstimator::new(mempool_policy.min_relay_fee_per_kb));

        let tx = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: Vec::new(),
            vout: vec![TxOut {
                value: 1 * COIN,
                script_pubkey: p2pkh_script([0x22u8; 20]),
            }],
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let raw_hex = hex_bytes(&tx.consensus_encode().expect("encode tx"));

        rpc_fundrawtransaction(
            &chainstate,
            &mempool,
            &mempool_policy,
            &fee_estimator,
            2,
            &wallet,
            vec![json!(raw_hex), json!({"lockUnspents": true})],
            &params,
            FundTransactionControl::default(),
        )
        .expect("rpc");

        let locked = wallet.lock().expect("wallet lock").locked_outpoints();
        assert_eq!(locked, vec![outpoint]);
    }

    #[test]
    fn importaddress_enables_watchonly_listunspent_and_getbalance() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let watch_script = p2pkh_script([0x55u8; 20]);
        let watch_address =
            script_pubkey_to_address(&watch_script, params.network).expect("watch address");
        let outpoint = OutPoint {
            hash: [0x55u8; 32],
            index: 0,
        };
        let utxo_entry = fluxd_chainstate::utxo::UtxoEntry {
            value: 3 * COIN,
            script_pubkey: watch_script.clone(),
            height: 0,
            is_coinbase: false,
        };
        let utxo_key = fluxd_chainstate::utxo::outpoint_key_bytes(&outpoint);
        let addr_key =
            fluxd_chainstate::address_index::address_outpoint_key(&watch_script, &outpoint)
                .expect("address outpoint key");
        let mut batch = WriteBatch::new();
        batch.put(Column::Utxo, utxo_key.as_bytes(), utxo_entry.encode());
        batch.put(Column::AddressOutpoint, addr_key, []);
        chainstate.commit_batch(batch).expect("commit utxo");

        let mempool = Mutex::new(Mempool::new(0));
        let value = rpc_listunspent(
            &chainstate,
            &mempool,
            &wallet,
            vec![json!(1), json!(9_999_999), json!([watch_address.clone()])],
            &params,
        )
        .expect("rpc");
        assert_eq!(value.as_array().expect("array").len(), 0);

        rpc_importaddress(
            &chainstate,
            &wallet,
            vec![json!(watch_address.clone()), Value::Null, json!(false)],
            &params,
        )
        .expect("rpc");

        let value = rpc_listunspent(
            &chainstate,
            &mempool,
            &wallet,
            vec![json!(1), json!(9_999_999), json!([watch_address.clone()])],
            &params,
        )
        .expect("rpc");
        let arr = value.as_array().expect("array");
        assert_eq!(arr.len(), 1);
        assert_eq!(
            arr[0].get("spendable").and_then(Value::as_bool),
            Some(false)
        );

        let balance = rpc_getbalance(
            &chainstate,
            &mempool,
            &wallet,
            vec![Value::Null, json!(1), json!(true)],
        )
        .expect("rpc");
        assert_eq!(balance, amount_to_value(3 * COIN));
    }

    #[test]
    fn listaddressgroupings_reports_wallet_balances() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let addr_a = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let addr_b = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();

        let script_a = address_to_script_pubkey(&addr_a, params.network).expect("script a");
        let script_b = address_to_script_pubkey(&addr_b, params.network).expect("script b");

        {
            let mut guard = wallet.lock().expect("wallet lock");
            guard
                .set_label_for_script_pubkey(script_a.clone(), "alpha".to_string())
                .expect("set label a");
            guard
                .set_label_for_script_pubkey(script_b.clone(), "beta".to_string())
                .expect("set label b");
        }

        let outpoint_a = OutPoint {
            hash: [0xaau8; 32],
            index: 0,
        };
        let outpoint_b = OutPoint {
            hash: [0xbbu8; 32],
            index: 0,
        };
        let utxo_a = fluxd_chainstate::utxo::UtxoEntry {
            value: 1 * COIN,
            script_pubkey: script_a.clone(),
            height: 0,
            is_coinbase: false,
        };
        let utxo_b = fluxd_chainstate::utxo::UtxoEntry {
            value: 2 * COIN,
            script_pubkey: script_b.clone(),
            height: 0,
            is_coinbase: false,
        };
        let mut batch = WriteBatch::new();

        let utxo_key_a = fluxd_chainstate::utxo::outpoint_key_bytes(&outpoint_a);
        let addr_key_a =
            fluxd_chainstate::address_index::address_outpoint_key(&script_a, &outpoint_a)
                .expect("addr key a");
        batch.put(Column::Utxo, utxo_key_a.as_bytes(), utxo_a.encode());
        batch.put(Column::AddressOutpoint, addr_key_a, []);

        let utxo_key_b = fluxd_chainstate::utxo::outpoint_key_bytes(&outpoint_b);
        let addr_key_b =
            fluxd_chainstate::address_index::address_outpoint_key(&script_b, &outpoint_b)
                .expect("addr key b");
        batch.put(Column::Utxo, utxo_key_b.as_bytes(), utxo_b.encode());
        batch.put(Column::AddressOutpoint, addr_key_b, []);

        chainstate.commit_batch(batch).expect("commit utxos");

        let mempool = Mutex::new(Mempool::new(0));
        let value = rpc_listaddressgroupings(&chainstate, &mempool, &wallet, Vec::new(), &params)
            .expect("rpc");
        let groups = value.as_array().expect("array");
        assert_eq!(groups.len(), 2);

        let mut totals: HashMap<String, (i64, String)> = HashMap::new();
        for group in groups {
            let entries = group.as_array().expect("group array");
            for entry in entries {
                let arr = entry.as_array().expect("entry array");
                let address = arr[0].as_str().expect("address").to_string();
                let amount = parse_amount(&arr[1]).expect("amount");
                let label = arr.get(2).and_then(Value::as_str).unwrap_or("").to_string();
                totals.insert(address, (amount, label));
            }
        }

        assert_eq!(
            totals.get(&addr_a).map(|(amount, _)| *amount),
            Some(1 * COIN)
        );
        assert_eq!(
            totals.get(&addr_b).map(|(amount, _)| *amount),
            Some(2 * COIN)
        );
        assert_eq!(
            totals.get(&addr_a).map(|(_, label)| label.as_str()),
            Some("alpha")
        );
        assert_eq!(
            totals.get(&addr_b).map(|(_, label)| label.as_str()),
            Some("beta")
        );
    }

    #[test]
    fn listaddressgroupings_clusters_inputs_and_change() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let addr_a = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let addr_b = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let addr_c = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();

        let script_a = address_to_script_pubkey(&addr_a, params.network).expect("script a");
        let script_b = address_to_script_pubkey(&addr_b, params.network).expect("script b");
        let script_c = address_to_script_pubkey(&addr_c, params.network).expect("script c");

        let a1 = OutPoint {
            hash: [0xa1u8; 32],
            index: 0,
        };
        let a2 = OutPoint {
            hash: [0xa2u8; 32],
            index: 0,
        };
        let b1 = OutPoint {
            hash: [0xb1u8; 32],
            index: 0,
        };
        let b2 = OutPoint {
            hash: [0xb2u8; 32],
            index: 0,
        };

        let mut batch = WriteBatch::new();
        for (outpoint, value, script) in [
            (a1.clone(), 1 * COIN, script_a.clone()),
            (a2.clone(), 2 * COIN, script_a.clone()),
            (b1.clone(), 1 * COIN, script_b.clone()),
            (b2.clone(), 3 * COIN, script_b.clone()),
        ] {
            let utxo_entry = fluxd_chainstate::utxo::UtxoEntry {
                value,
                script_pubkey: script.clone(),
                height: 0,
                is_coinbase: false,
            };
            let utxo_key = fluxd_chainstate::utxo::outpoint_key_bytes(&outpoint);
            let addr_key =
                fluxd_chainstate::address_index::address_outpoint_key(&script, &outpoint)
                    .expect("addr key");
            batch.put(Column::Utxo, utxo_key.as_bytes(), utxo_entry.encode());
            batch.put(Column::AddressOutpoint, addr_key, []);
        }
        chainstate.commit_batch(batch).expect("commit utxos");

        let spend_tx = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: vec![
                TxIn {
                    prevout: a1.clone(),
                    script_sig: Vec::new(),
                    sequence: u32::MAX,
                },
                TxIn {
                    prevout: b1.clone(),
                    script_sig: Vec::new(),
                    sequence: u32::MAX,
                },
            ],
            vout: vec![
                TxOut {
                    value: 1 * COIN,
                    script_pubkey: p2pkh_script([0x77u8; 20]),
                },
                TxOut {
                    value: 1 * COIN,
                    script_pubkey: script_c.clone(),
                },
            ],
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };

        let tip = chainstate
            .best_block()
            .expect("best block")
            .expect("best block present");
        let tip_entry = chainstate
            .header_entry(&tip.hash)
            .expect("header entry")
            .expect("header entry present");
        let height = tip.height + 1;
        let time = tip_entry.time.saturating_add(1);
        let bits = chainstate
            .next_work_required_bits(&tip.hash, height, time as i64, &params.consensus)
            .expect("next bits");

        let miner_value = block_subsidy(height, &params.consensus);
        let exchange_amount = exchange_fund_amount(height, &params.funding);
        let foundation_amount = foundation_fund_amount(height, &params.funding);
        let swap_amount = swap_pool_amount(height as i64, &params.swap_pool);

        let mut vout = Vec::new();
        vout.push(TxOut {
            value: miner_value,
            script_pubkey: Vec::new(),
        });
        if exchange_amount > 0 {
            let script = address_to_script_pubkey(params.funding.exchange_address, params.network)
                .expect("exchange address script");
            vout.push(TxOut {
                value: exchange_amount,
                script_pubkey: script,
            });
        }
        if foundation_amount > 0 {
            let script =
                address_to_script_pubkey(params.funding.foundation_address, params.network)
                    .expect("foundation address script");
            vout.push(TxOut {
                value: foundation_amount,
                script_pubkey: script,
            });
        }
        if swap_amount > 0 {
            let script = address_to_script_pubkey(params.swap_pool.address, params.network)
                .expect("swap pool address script");
            vout.push(TxOut {
                value: swap_amount,
                script_pubkey: script,
            });
        }

        let coinbase = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: vec![TxIn {
                prevout: OutPoint::null(),
                script_sig: Vec::new(),
                sequence: u32::MAX,
            }],
            vout,
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let coinbase_txid = coinbase.txid().expect("coinbase txid");
        let final_sapling_root = chainstate.sapling_root().expect("sapling root");
        let header = BlockHeader {
            version: CURRENT_VERSION,
            prev_block: tip.hash,
            merkle_root: coinbase_txid,
            final_sapling_root,
            time,
            bits,
            nonce: [0u8; 32],
            solution: Vec::new(),
            nodes_collateral: OutPoint::null(),
            block_sig: Vec::new(),
        };

        let mut header_batch = WriteBatch::new();
        chainstate
            .insert_headers_batch_with_pow(
                &[header.clone()],
                &params.consensus,
                &mut header_batch,
                false,
            )
            .expect("insert header");
        chainstate
            .commit_batch(header_batch)
            .expect("commit header");

        let block = fluxd_primitives::block::Block {
            header,
            transactions: vec![coinbase, spend_tx],
        };
        let block_bytes = block.consensus_encode().expect("encode block");
        let flags = ValidationFlags::default();
        let batch = chainstate
            .connect_block(
                &block,
                height,
                &params,
                &flags,
                true,
                None,
                None,
                Some(block_bytes.as_slice()),
                None,
            )
            .expect("connect block");
        chainstate.commit_batch(batch).expect("commit block");

        let mempool = Mutex::new(Mempool::new(0));
        let value = rpc_listaddressgroupings(&chainstate, &mempool, &wallet, Vec::new(), &params)
            .expect("rpc");
        let groups = value.as_array().expect("array");
        assert_eq!(groups.len(), 1);

        let entries = groups[0].as_array().expect("group array");
        let mut grouped: HashMap<String, i64> = HashMap::new();
        for entry in entries {
            let arr = entry.as_array().expect("entry array");
            let address = arr[0].as_str().expect("address").to_string();
            let amount = parse_amount(&arr[1]).expect("amount");
            grouped.insert(address, amount);
        }

        assert_eq!(grouped.get(&addr_a).copied(), Some(2 * COIN));
        assert_eq!(grouped.get(&addr_b).copied(), Some(3 * COIN));
        assert_eq!(grouped.get(&addr_c).copied(), Some(1 * COIN));
    }

    #[test]
    fn sendfrom_respects_minconf() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let from_address = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let from_script =
            address_to_script_pubkey(&from_address, params.network).expect("address script");

        let outpoint = OutPoint {
            hash: [0x99u8; 32],
            index: 0,
        };
        let utxo_entry = fluxd_chainstate::utxo::UtxoEntry {
            value: 5 * COIN,
            script_pubkey: from_script.clone(),
            height: 0,
            is_coinbase: false,
        };
        let utxo_key = fluxd_chainstate::utxo::outpoint_key_bytes(&outpoint);
        let addr_key =
            fluxd_chainstate::address_index::address_outpoint_key(&from_script, &outpoint)
                .expect("address outpoint key");
        let mut batch = WriteBatch::new();
        batch.put(Column::Utxo, utxo_key.as_bytes(), utxo_entry.encode());
        batch.put(Column::AddressOutpoint, addr_key, []);
        chainstate.commit_batch(batch).expect("commit utxo");

        let mempool = Mutex::new(Mempool::new(0));
        let mempool_policy = MempoolPolicy::standard(1000, true);
        let mempool_metrics = MempoolMetrics::default();
        let fee_estimator = Mutex::new(FeeEstimator::new(128));
        let mempool_flags = ValidationFlags::default();
        let (tx_announce, _rx) = broadcast::channel(16);

        let to_address =
            script_pubkey_to_address(&p2pkh_script([0x22u8; 20]), params.network).expect("to addr");

        let err = rpc_sendfrom(
            &chainstate,
            &mempool,
            &mempool_policy,
            &mempool_metrics,
            &fee_estimator,
            2,
            &mempool_flags,
            &wallet,
            vec![json!(""), json!(to_address.clone()), json!("1.0"), json!(2)],
            &params,
            &tx_announce,
        )
        .unwrap_err();
        assert_eq!(err.code, RPC_WALLET_ERROR);

        let value = rpc_sendfrom(
            &chainstate,
            &mempool,
            &mempool_policy,
            &mempool_metrics,
            &fee_estimator,
            2,
            &mempool_flags,
            &wallet,
            vec![json!(""), json!(to_address), json!("1.0"), json!(1)],
            &params,
            &tx_announce,
        )
        .expect("rpc");
        let txid_hex = value.as_str().expect("txid string");
        assert!(is_hex_64(txid_hex));
        let txid = parse_hash(&Value::String(txid_hex.to_string())).expect("txid");
        assert!(mempool.lock().expect("mempool lock").contains(&txid));
    }

    #[test]
    fn sendfrom_honors_fromaccount_address_filter_and_change_destination() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let addr_a = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let addr_b = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();

        let script_a = address_to_script_pubkey(&addr_a, params.network).expect("script a");
        let script_b = address_to_script_pubkey(&addr_b, params.network).expect("script b");

        let outpoint_a = OutPoint {
            hash: [0xa1u8; 32],
            index: 0,
        };
        let outpoint_b = OutPoint {
            hash: [0xb2u8; 32],
            index: 0,
        };

        let utxo_a = fluxd_chainstate::utxo::UtxoEntry {
            value: 2 * COIN,
            script_pubkey: script_a.clone(),
            height: 0,
            is_coinbase: false,
        };
        let utxo_b = fluxd_chainstate::utxo::UtxoEntry {
            value: 5 * COIN,
            script_pubkey: script_b.clone(),
            height: 0,
            is_coinbase: false,
        };

        let utxo_key_a = fluxd_chainstate::utxo::outpoint_key_bytes(&outpoint_a);
        let utxo_key_b = fluxd_chainstate::utxo::outpoint_key_bytes(&outpoint_b);
        let addr_key_a =
            fluxd_chainstate::address_index::address_outpoint_key(&script_a, &outpoint_a)
                .expect("address outpoint key a");
        let addr_key_b =
            fluxd_chainstate::address_index::address_outpoint_key(&script_b, &outpoint_b)
                .expect("address outpoint key b");

        let mut batch = WriteBatch::new();
        batch.put(Column::Utxo, utxo_key_a.as_bytes(), utxo_a.encode());
        batch.put(Column::AddressOutpoint, addr_key_a, []);
        batch.put(Column::Utxo, utxo_key_b.as_bytes(), utxo_b.encode());
        batch.put(Column::AddressOutpoint, addr_key_b, []);
        chainstate.commit_batch(batch).expect("commit utxo");

        let mempool = Mutex::new(Mempool::new(0));
        let mempool_policy = MempoolPolicy::standard(1000, true);
        let mempool_metrics = MempoolMetrics::default();
        let fee_estimator = Mutex::new(FeeEstimator::new(128));
        let mempool_flags = ValidationFlags::default();
        let (tx_announce, _rx) = broadcast::channel(16);

        let to_address =
            script_pubkey_to_address(&p2pkh_script([0x22u8; 20]), params.network).expect("to addr");
        let to_script = address_to_script_pubkey(&to_address, params.network).expect("to script");

        let value = rpc_sendfrom(
            &chainstate,
            &mempool,
            &mempool_policy,
            &mempool_metrics,
            &fee_estimator,
            2,
            &mempool_flags,
            &wallet,
            vec![json!(addr_b), json!(to_address), json!("1.0"), json!(1)],
            &params,
            &tx_announce,
        )
        .expect("rpc");
        let txid_hex = value.as_str().expect("txid string");
        assert!(is_hex_64(txid_hex));

        let txid = parse_hash(&Value::String(txid_hex.to_string())).expect("parse txid");
        let guard = mempool.lock().expect("mempool lock");
        let entry = guard.get(&txid).expect("mempool entry");

        assert!(entry.tx.vin.iter().any(|vin| vin.prevout == outpoint_b));
        assert!(
            !entry.tx.vin.iter().any(|vin| vin.prevout == outpoint_a),
            "should not select outpoints from other wallet addresses"
        );
        assert!(entry
            .tx
            .vout
            .iter()
            .any(|out| out.script_pubkey == to_script));
        assert!(
            entry
                .tx
                .vout
                .iter()
                .any(|out| out.script_pubkey == script_b && out.value > 0),
            "change should return to fromaccount address"
        );
    }

    #[test]
    fn sendmany_honors_fromaccount_address_filter_and_change_destination() {
        let (chainstate, mut params, data_dir) = setup_regtest_chainstate();
        params.consensus.upgrades[UpgradeIndex::Acadia.as_usize()].activation_height = 1;

        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let addr_a = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let addr_b = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();

        let script_a = address_to_script_pubkey(&addr_a, params.network).expect("script a");
        let script_b = address_to_script_pubkey(&addr_b, params.network).expect("script b");

        let outpoint_a = OutPoint {
            hash: [0xc3u8; 32],
            index: 0,
        };
        let outpoint_b = OutPoint {
            hash: [0xd4u8; 32],
            index: 0,
        };

        let utxo_a = fluxd_chainstate::utxo::UtxoEntry {
            value: 5 * COIN,
            script_pubkey: script_a.clone(),
            height: 0,
            is_coinbase: false,
        };
        let utxo_b = fluxd_chainstate::utxo::UtxoEntry {
            value: 2 * COIN,
            script_pubkey: script_b.clone(),
            height: 0,
            is_coinbase: false,
        };

        let utxo_key_a = fluxd_chainstate::utxo::outpoint_key_bytes(&outpoint_a);
        let utxo_key_b = fluxd_chainstate::utxo::outpoint_key_bytes(&outpoint_b);
        let addr_key_a =
            fluxd_chainstate::address_index::address_outpoint_key(&script_a, &outpoint_a)
                .expect("address outpoint key a");
        let addr_key_b =
            fluxd_chainstate::address_index::address_outpoint_key(&script_b, &outpoint_b)
                .expect("address outpoint key b");

        let mut batch = WriteBatch::new();
        batch.put(Column::Utxo, utxo_key_a.as_bytes(), utxo_a.encode());
        batch.put(Column::AddressOutpoint, addr_key_a, []);
        batch.put(Column::Utxo, utxo_key_b.as_bytes(), utxo_b.encode());
        batch.put(Column::AddressOutpoint, addr_key_b, []);
        chainstate.commit_batch(batch).expect("commit utxo");

        let mempool = Mutex::new(Mempool::new(0));
        let mempool_policy = MempoolPolicy::standard(1000, true);
        let mempool_metrics = MempoolMetrics::default();
        let fee_estimator = Mutex::new(FeeEstimator::new(128));
        let mempool_flags = ValidationFlags::default();
        let (tx_announce, _rx) = broadcast::channel(16);

        let to_address =
            script_pubkey_to_address(&p2pkh_script([0x22u8; 20]), params.network).expect("to addr");
        let to_script = address_to_script_pubkey(&to_address, params.network).expect("to script");
        let mut amounts = serde_json::Map::new();
        amounts.insert(to_address, json!("1.0"));

        let value = rpc_sendmany(
            &chainstate,
            &mempool,
            &mempool_policy,
            &mempool_metrics,
            &fee_estimator,
            2,
            &mempool_flags,
            &wallet,
            vec![json!(addr_a), Value::Object(amounts), json!(1)],
            &params,
            &tx_announce,
        )
        .expect("rpc");
        let txid_hex = value.as_str().expect("txid string");
        assert!(is_hex_64(txid_hex));

        let txid = parse_hash(&Value::String(txid_hex.to_string())).expect("parse txid");
        let guard = mempool.lock().expect("mempool lock");
        let entry = guard.get(&txid).expect("mempool entry");

        assert!(entry.tx.vin.iter().any(|vin| vin.prevout == outpoint_a));
        assert!(
            !entry.tx.vin.iter().any(|vin| vin.prevout == outpoint_b),
            "should not select outpoints from other wallet addresses"
        );
        assert!(entry
            .tx
            .vout
            .iter()
            .any(|out| out.script_pubkey == to_script));
        assert!(
            entry
                .tx
                .vout
                .iter()
                .any(|out| out.script_pubkey == script_a && out.value > 0),
            "change should return to fromaccount address"
        );
    }

    #[test]
    fn wallet_importprivkey_enables_dumpprivkey() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet_a =
            Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let address = rpc_getnewaddress(&wallet_a, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let wif = rpc_dumpprivkey(&wallet_a, vec![json!(address.clone())], &params)
            .expect("rpc")
            .as_str()
            .expect("wif string")
            .to_string();

        let data_dir_b = temp_data_dir("fluxd-wallet-test-b");
        std::fs::create_dir_all(&data_dir_b).expect("create data dir");
        let wallet_b =
            Mutex::new(Wallet::load_or_create(&data_dir_b, params.network).expect("wallet"));
        rpc_importprivkey(
            &chainstate,
            &wallet_b,
            vec![json!(wif.clone()), Value::Null, json!(false)],
        )
        .expect("rpc");

        let wif_b = rpc_dumpprivkey(&wallet_b, vec![json!(address)], &params)
            .expect("rpc")
            .as_str()
            .expect("wif string")
            .to_string();
        assert_eq!(wif_b, wif);
    }

    #[test]
    fn signmessage_roundtrips_with_verifymessage() {
        let (_chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let address = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let message = "hello world";
        let signature = rpc_signmessage(
            &wallet,
            vec![json!(address.clone()), json!(message)],
            &params,
        )
        .expect("rpc")
        .as_str()
        .expect("signature string")
        .to_string();

        let ok = rpc_verifymessage(
            vec![json!(address), json!(signature), json!(message)],
            &params,
        )
        .expect("rpc");
        assert_eq!(ok, Value::Bool(true));
    }

    #[test]
    fn wallet_balance_excludes_immature_coinbase_then_includes_after_maturity() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));
        let address = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let script_pubkey =
            address_to_script_pubkey(&address, params.network).expect("address script");

        let (_txid, _vout, height, miner_value) =
            mine_regtest_block_to_script(&chainstate, &params, script_pubkey);
        assert_eq!(height, 1);

        let mempool = Mutex::new(Mempool::new(0));
        let bal = rpc_getbalance(&chainstate, &mempool, &wallet, Vec::new()).expect("rpc");
        assert_eq!(parse_amount(&bal).expect("amount"), 0);

        extend_regtest_chain_to_height(&chainstate, &params, COINBASE_MATURITY);
        let bal = rpc_getbalance(&chainstate, &mempool, &wallet, Vec::new()).expect("rpc");
        assert_eq!(parse_amount(&bal).expect("amount"), miner_value);

        let utxos =
            rpc_listunspent(&chainstate, &mempool, &wallet, Vec::new(), &params).expect("rpc");
        let arr = utxos.as_array().expect("array");
        assert_eq!(arr.len(), 1);
        let row = arr[0].as_object().expect("object");
        assert_eq!(
            row.get("amount_zat").and_then(Value::as_i64),
            Some(miner_value)
        );
        assert_eq!(
            row.get("confirmations").and_then(Value::as_i64),
            Some(i64::from(COINBASE_MATURITY))
        );
    }

    #[test]
    fn getbalance_rejects_nonempty_account_param() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));
        let mempool = Mutex::new(Mempool::new(0));

        let value = rpc_getbalance(&chainstate, &mempool, &wallet, vec![json!("")]).expect("rpc");
        assert_eq!(parse_amount(&value).expect("amount"), 0);

        let value = rpc_getbalance(&chainstate, &mempool, &wallet, vec![json!("*")]).expect("rpc");
        assert_eq!(parse_amount(&value).expect("amount"), 0);

        let err = rpc_getbalance(
            &chainstate,
            &mempool,
            &wallet,
            vec![json!("label-not-allowed")],
        )
        .unwrap_err();
        assert_eq!(err.code, RPC_INVALID_PARAMETER);
        assert_eq!(err.message, "account must be \"\" or \"*\"");
    }

    #[test]
    fn wallet_unconfirmed_balance_tracks_mempool_outputs() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));
        let address = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let script_pubkey =
            address_to_script_pubkey(&address, params.network).expect("address script");

        let incoming_value = 2 * COIN;
        let incoming_prevout = OutPoint {
            hash: [0x33u8; 32],
            index: 0,
        };
        let incoming_tx = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: vec![TxIn {
                prevout: incoming_prevout.clone(),
                script_sig: Vec::new(),
                sequence: 0,
            }],
            vout: vec![TxOut {
                value: incoming_value,
                script_pubkey: script_pubkey.clone(),
            }],
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let incoming_txid = incoming_tx.txid().expect("txid");
        let incoming_raw = incoming_tx.consensus_encode().expect("encode tx");

        let mut inner = Mempool::new(0);
        inner
            .insert(MempoolEntry {
                txid: incoming_txid,
                tx: incoming_tx,
                raw: incoming_raw,
                time: 0,
                height: 0,
                fee: 0,
                value_in: 0,
                modified_size: 0,
                priority: 0.0,
                was_clear_at_entry: true,
                fee_delta: 0,
                priority_delta: 0.0,
                spent_outpoints: vec![incoming_prevout],
                parents: Vec::new(),
            })
            .expect("insert mempool tx");
        let mempool = Mutex::new(inner);

        let confirmed_only =
            rpc_getbalance(&chainstate, &mempool, &wallet, Vec::new()).expect("rpc");
        assert_eq!(parse_amount(&confirmed_only).expect("amount"), 0);

        let include_mempool =
            rpc_getbalance(&chainstate, &mempool, &wallet, vec![Value::Null, json!(0)])
                .expect("rpc");
        assert_eq!(
            parse_amount(&include_mempool).expect("amount"),
            incoming_value
        );

        let unconfirmed =
            rpc_getunconfirmedbalance(&chainstate, &mempool, &wallet, Vec::new()).expect("rpc");
        assert_eq!(parse_amount(&unconfirmed).expect("amount"), incoming_value);

        let info = rpc_getwalletinfo(&chainstate, &mempool, &wallet, Vec::new()).expect("rpc");
        let obj = info.as_object().expect("object");
        assert_eq!(
            obj.get("unconfirmed_balance_zat").and_then(Value::as_i64),
            Some(incoming_value)
        );
        assert_eq!(obj.get("balance_zat").and_then(Value::as_i64), Some(0));

        let utxos_default =
            rpc_listunspent(&chainstate, &mempool, &wallet, Vec::new(), &params).expect("rpc");
        assert_eq!(utxos_default.as_array().expect("array").len(), 0);

        let utxos =
            rpc_listunspent(&chainstate, &mempool, &wallet, vec![json!(0)], &params).expect("rpc");
        let arr = utxos.as_array().expect("array");
        assert_eq!(arr.len(), 1);
        let row = arr[0].as_object().expect("object");
        let incoming_txid_hex = hash256_to_hex(&incoming_txid);
        assert_eq!(
            row.get("txid").and_then(Value::as_str),
            Some(incoming_txid_hex.as_str())
        );
        assert_eq!(row.get("vout").and_then(Value::as_u64), Some(0));
        assert_eq!(
            row.get("address").and_then(Value::as_str),
            Some(address.as_str())
        );
        assert_eq!(
            row.get("amount_zat").and_then(Value::as_i64),
            Some(incoming_value)
        );
        assert_eq!(row.get("confirmations").and_then(Value::as_i64), Some(0));

        let spending_tx = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: vec![TxIn {
                prevout: OutPoint {
                    hash: incoming_txid,
                    index: 0,
                },
                script_sig: Vec::new(),
                sequence: 0,
            }],
            vout: vec![TxOut {
                value: incoming_value,
                script_pubkey: p2pkh_script([0x44u8; 20]),
            }],
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let spending_txid = spending_tx.txid().expect("txid");
        let spending_raw = spending_tx.consensus_encode().expect("encode tx");
        mempool
            .lock()
            .expect("mempool lock")
            .insert(MempoolEntry {
                txid: spending_txid,
                tx: spending_tx,
                raw: spending_raw,
                time: 0,
                height: 0,
                fee: 0,
                value_in: 0,
                modified_size: 0,
                priority: 0.0,
                was_clear_at_entry: false,
                fee_delta: 0,
                priority_delta: 0.0,
                spent_outpoints: vec![OutPoint {
                    hash: incoming_txid,
                    index: 0,
                }],
                parents: vec![incoming_txid],
            })
            .expect("insert spending tx");

        let unconfirmed =
            rpc_getunconfirmedbalance(&chainstate, &mempool, &wallet, Vec::new()).expect("rpc");
        assert_eq!(parse_amount(&unconfirmed).expect("amount"), 0);

        let utxos =
            rpc_listunspent(&chainstate, &mempool, &wallet, vec![json!(0)], &params).expect("rpc");
        assert_eq!(utxos.as_array().expect("array").len(), 0);
    }

    #[test]
    fn getreceivedbyaddress_counts_confirmed_and_mempool_outputs() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));
        let address = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let script_pubkey =
            address_to_script_pubkey(&address, params.network).expect("address script");

        let (_txid, _vout, height, miner_value) =
            mine_regtest_block_to_script(&chainstate, &params, script_pubkey.clone());
        assert_eq!(height, 1);

        let mempool = Mutex::new(Mempool::new(0));

        let received = rpc_getreceivedbyaddress(
            &chainstate,
            &mempool,
            &wallet,
            vec![json!(address.clone())],
            &params,
        )
        .expect("rpc");
        assert_eq!(parse_amount(&received).expect("amount"), miner_value);

        let received = rpc_getreceivedbyaddress(
            &chainstate,
            &mempool,
            &wallet,
            vec![json!(address.clone()), json!(2)],
            &params,
        )
        .expect("rpc");
        assert_eq!(parse_amount(&received).expect("amount"), 0);

        mine_regtest_block_to_script(&chainstate, &params, p2pkh_script([0x22u8; 20]));
        let received = rpc_getreceivedbyaddress(
            &chainstate,
            &mempool,
            &wallet,
            vec![json!(address.clone()), json!(2)],
            &params,
        )
        .expect("rpc");
        assert_eq!(parse_amount(&received).expect("amount"), miner_value);

        let incoming_value = 1 * COIN;
        let incoming_prevout = OutPoint {
            hash: [0x55u8; 32],
            index: 0,
        };
        let incoming_tx = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: vec![TxIn {
                prevout: incoming_prevout.clone(),
                script_sig: Vec::new(),
                sequence: 0,
            }],
            vout: vec![TxOut {
                value: incoming_value,
                script_pubkey,
            }],
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let txid = incoming_tx.txid().expect("txid");
        let raw = incoming_tx.consensus_encode().expect("encode tx");
        mempool
            .lock()
            .expect("mempool lock")
            .insert(MempoolEntry {
                txid,
                tx: incoming_tx,
                raw,
                time: 0,
                height: 0,
                fee: 0,
                value_in: 0,
                modified_size: 0,
                priority: 0.0,
                was_clear_at_entry: true,
                fee_delta: 0,
                priority_delta: 0.0,
                spent_outpoints: vec![incoming_prevout],
                parents: Vec::new(),
            })
            .expect("insert mempool tx");

        let received = rpc_getreceivedbyaddress(
            &chainstate,
            &mempool,
            &wallet,
            vec![json!(address.clone()), json!(0)],
            &params,
        )
        .expect("rpc");
        assert_eq!(
            parse_amount(&received).expect("amount"),
            miner_value + incoming_value
        );

        let other_address =
            script_pubkey_to_address(&p2pkh_script([0x66u8; 20]), params.network).expect("address");
        let err = rpc_getreceivedbyaddress(
            &chainstate,
            &mempool,
            &wallet,
            vec![json!(other_address)],
            &params,
        )
        .unwrap_err();
        assert_eq!(err.code, RPC_WALLET_ERROR);
    }

    #[test]
    fn getreceivedbyaddress_counts_p2sh_wallet_receives() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let key_a = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let key_b = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();

        let multisig =
            rpc_addmultisigaddress(&wallet, vec![json!(2), json!([key_a, key_b])], &params)
                .expect("rpc")
                .as_str()
                .expect("p2sh address string")
                .to_string();

        let script_pubkey =
            address_to_script_pubkey(&multisig, params.network).expect("address script");
        let (_txid, _vout, height, miner_value) =
            mine_regtest_block_to_script(&chainstate, &params, script_pubkey);
        assert_eq!(height, 1);

        let mempool = Mutex::new(Mempool::new(0));
        let received = rpc_getreceivedbyaddress(
            &chainstate,
            &mempool,
            &wallet,
            vec![json!(multisig)],
            &params,
        )
        .expect("rpc");
        assert_eq!(parse_amount(&received).expect("amount"), miner_value);
    }

    #[test]
    fn gettransaction_reports_confirmed_wallet_tx() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));
        let address = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let script_pubkey =
            address_to_script_pubkey(&address, params.network).expect("address script");

        let (txid, _vout, _height, miner_value) =
            mine_regtest_block_to_script(&chainstate, &params, script_pubkey);

        let mempool = Mutex::new(Mempool::new(0));
        let txid_hex = hash256_to_hex(&txid);
        let value = rpc_gettransaction(
            &chainstate,
            &mempool,
            &wallet,
            vec![json!(txid_hex.clone())],
            &params,
        )
        .expect("rpc");
        let obj = value.as_object().expect("object");
        assert_eq!(
            obj.get("txid").and_then(Value::as_str),
            Some(txid_hex.as_str())
        );
        assert_eq!(
            obj.get("amount_zat").and_then(Value::as_i64),
            Some(miner_value)
        );
        assert_eq!(obj.get("confirmations").and_then(Value::as_i64), Some(1));
        assert_eq!(
            obj.get("involvesWatchonly").and_then(Value::as_bool),
            Some(false)
        );
        assert_eq!(obj.get("generated").and_then(Value::as_bool), Some(true));
        assert_eq!(obj.get("expiryheight").and_then(Value::as_i64), Some(0));
        let joinsplits = obj
            .get("vJoinSplit")
            .and_then(Value::as_array)
            .expect("vJoinSplit");
        assert!(joinsplits.is_empty());
        let details = obj
            .get("details")
            .and_then(Value::as_array)
            .expect("details");
        assert!(!details.is_empty());
        assert!(obj
            .get("hex")
            .and_then(Value::as_str)
            .is_some_and(|hex| !hex.is_empty()));

        let missing_txid_hex = hash256_to_hex(&[0x99u8; 32]);
        let err = rpc_gettransaction(
            &chainstate,
            &mempool,
            &wallet,
            vec![json!(missing_txid_hex)],
            &params,
        )
        .unwrap_err();
        assert_eq!(err.code, RPC_INVALID_ADDRESS_OR_KEY);
    }

    #[test]
    fn gettransaction_falls_back_to_wallet_store_when_missing_from_chain_and_mempool() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let from_address = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let from_script =
            address_to_script_pubkey(&from_address, params.network).expect("address script");

        let outpoint = OutPoint {
            hash: [0x11u8; 32],
            index: 0,
        };
        let utxo_entry = fluxd_chainstate::utxo::UtxoEntry {
            value: 5 * COIN,
            script_pubkey: from_script.clone(),
            height: 0,
            is_coinbase: false,
        };
        let utxo_key = fluxd_chainstate::utxo::outpoint_key_bytes(&outpoint);
        let addr_key =
            fluxd_chainstate::address_index::address_outpoint_key(&from_script, &outpoint)
                .expect("address outpoint key");
        let mut batch = WriteBatch::new();
        batch.put(Column::Utxo, utxo_key.as_bytes(), utxo_entry.encode());
        batch.put(Column::AddressOutpoint, addr_key, []);
        chainstate.commit_batch(batch).expect("commit utxo");

        let mempool = Mutex::new(Mempool::new(0));
        let mempool_policy = MempoolPolicy::standard(1000, true);
        let mempool_metrics = MempoolMetrics::default();
        let fee_estimator = Mutex::new(FeeEstimator::new(128));
        let mempool_flags = ValidationFlags::default();
        let (tx_announce, _rx) = broadcast::channel(16);

        let to_address =
            script_pubkey_to_address(&p2pkh_script([0x22u8; 20]), params.network).expect("address");
        let txid_hex = rpc_sendtoaddress(
            &chainstate,
            &mempool,
            &mempool_policy,
            &mempool_metrics,
            &fee_estimator,
            2,
            &mempool_flags,
            &wallet,
            vec![json!(to_address), json!("1.0")],
            &params,
            &tx_announce,
        )
        .expect("rpc")
        .as_str()
        .expect("txid string")
        .to_string();

        drop(wallet);
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let empty_mempool = Mutex::new(Mempool::new(0));
        let value = rpc_gettransaction(
            &chainstate,
            &empty_mempool,
            &wallet,
            vec![json!(txid_hex.clone())],
            &params,
        )
        .expect("rpc");

        let obj = value.as_object().expect("object");
        assert_eq!(obj.get("confirmations").and_then(Value::as_i64), Some(-1));
        assert_eq!(obj.get("amount_zat").and_then(Value::as_i64), Some(-COIN));

        let hex = obj.get("hex").and_then(Value::as_str).expect("hex");
        let bytes = bytes_from_hex(hex).expect("hex decode");
        let decoded = Transaction::consensus_decode(&bytes).expect("decode tx");
        let decoded_txid = decoded.txid().expect("txid");
        assert_eq!(hash256_to_hex(&decoded_txid), txid_hex);
    }

    #[test]
    fn gettransaction_coinbase_category_is_immature_then_generate() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));
        let address = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let script_pubkey =
            address_to_script_pubkey(&address, params.network).expect("address script");

        let (txid, _vout, height, miner_value) =
            mine_regtest_block_to_script(&chainstate, &params, script_pubkey);
        assert_eq!(height, 1);
        let txid_hex = hash256_to_hex(&txid);

        let mempool = Mutex::new(Mempool::new(0));
        let value = rpc_gettransaction(
            &chainstate,
            &mempool,
            &wallet,
            vec![json!(txid_hex.clone())],
            &params,
        )
        .expect("rpc");
        let obj = value.as_object().expect("object");
        assert_eq!(
            obj.get("amount_zat").and_then(Value::as_i64),
            Some(miner_value)
        );
        assert_eq!(obj.get("confirmations").and_then(Value::as_i64), Some(1));
        let details = obj
            .get("details")
            .and_then(Value::as_array)
            .expect("details");
        let first = details[0].as_object().expect("detail row");
        assert_eq!(
            first.get("category").and_then(Value::as_str),
            Some("immature")
        );

        let value =
            rpc_listtransactions(&chainstate, &mempool, &wallet, Vec::new(), &params).expect("rpc");
        let arr = value.as_array().expect("array");
        assert_eq!(arr.len(), 1);
        let row = arr[0].as_object().expect("row");
        assert_eq!(
            row.get("category").and_then(Value::as_str),
            Some("immature")
        );

        extend_regtest_chain_to_height(&chainstate, &params, COINBASE_MATURITY);

        let value = rpc_gettransaction(
            &chainstate,
            &mempool,
            &wallet,
            vec![json!(txid_hex.clone())],
            &params,
        )
        .expect("rpc");
        let obj = value.as_object().expect("object");
        assert_eq!(
            obj.get("confirmations").and_then(Value::as_i64),
            Some(i64::from(COINBASE_MATURITY))
        );
        let details = obj
            .get("details")
            .and_then(Value::as_array)
            .expect("details");
        let first = details[0].as_object().expect("detail row");
        assert_eq!(
            first.get("category").and_then(Value::as_str),
            Some("generate")
        );

        let value =
            rpc_listtransactions(&chainstate, &mempool, &wallet, Vec::new(), &params).expect("rpc");
        let arr = value.as_array().expect("array");
        assert_eq!(arr.len(), 1);
        let row = arr[0].as_object().expect("row");
        assert_eq!(
            row.get("category").and_then(Value::as_str),
            Some("generate")
        );
    }

    #[test]
    fn gettransaction_reports_fee_for_confirmed_send_tx() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));
        let address = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let wallet_script_pubkey =
            address_to_script_pubkey(&address, params.network).expect("address script");

        let prevout = OutPoint {
            hash: [0x55u8; 32],
            index: 0,
        };
        let input_value = 10_000i64;
        let utxo_entry = fluxd_chainstate::utxo::UtxoEntry {
            value: input_value,
            script_pubkey: wallet_script_pubkey.clone(),
            height: 0,
            is_coinbase: false,
        };
        let utxo_key = fluxd_chainstate::utxo::outpoint_key_bytes(&prevout);
        let mut batch = WriteBatch::new();
        batch.put(Column::Utxo, utxo_key.as_bytes(), utxo_entry.encode());
        chainstate.commit_batch(batch).expect("commit utxo");

        let sent_value = 9_000i64;
        let change_value = 900i64;
        let other_script = p2pkh_script([0x66u8; 20]);
        let spend_tx = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: vec![TxIn {
                prevout: prevout.clone(),
                script_sig: Vec::new(),
                sequence: u32::MAX,
            }],
            vout: vec![
                TxOut {
                    value: sent_value,
                    script_pubkey: other_script,
                },
                TxOut {
                    value: change_value,
                    script_pubkey: wallet_script_pubkey.clone(),
                },
            ],
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let spend_txid = spend_tx.txid().expect("txid");

        let tip = chainstate
            .best_block()
            .expect("best block")
            .expect("best block present");
        let tip_entry = chainstate
            .header_entry(&tip.hash)
            .expect("header entry")
            .expect("header entry present");
        let height = tip.height + 1;
        let time = tip_entry.time.saturating_add(1);
        let bits = chainstate
            .next_work_required_bits(&tip.hash, height, time as i64, &params.consensus)
            .expect("next bits");

        let miner_value = block_subsidy(height, &params.consensus);
        let exchange_amount = exchange_fund_amount(height, &params.funding);
        let foundation_amount = foundation_fund_amount(height, &params.funding);
        let swap_amount = swap_pool_amount(height as i64, &params.swap_pool);

        let mut vout = Vec::new();
        vout.push(TxOut {
            value: miner_value,
            script_pubkey: Vec::new(),
        });
        if exchange_amount > 0 {
            let script = address_to_script_pubkey(params.funding.exchange_address, params.network)
                .expect("exchange address script");
            vout.push(TxOut {
                value: exchange_amount,
                script_pubkey: script,
            });
        }
        if foundation_amount > 0 {
            let script =
                address_to_script_pubkey(params.funding.foundation_address, params.network)
                    .expect("foundation address script");
            vout.push(TxOut {
                value: foundation_amount,
                script_pubkey: script,
            });
        }
        if swap_amount > 0 {
            let script = address_to_script_pubkey(params.swap_pool.address, params.network)
                .expect("swap pool address script");
            vout.push(TxOut {
                value: swap_amount,
                script_pubkey: script,
            });
        }

        let coinbase = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: vec![TxIn {
                prevout: OutPoint::null(),
                script_sig: Vec::new(),
                sequence: u32::MAX,
            }],
            vout,
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let coinbase_txid = coinbase.txid().expect("coinbase txid");
        let merkle_root = crate::verify_chain::compute_merkle_root(&[coinbase_txid, spend_txid]);
        let final_sapling_root = chainstate.sapling_root().expect("sapling root");

        let header = BlockHeader {
            version: CURRENT_VERSION,
            prev_block: tip.hash,
            merkle_root,
            final_sapling_root,
            time,
            bits,
            nonce: [0u8; 32],
            solution: Vec::new(),
            nodes_collateral: OutPoint::null(),
            block_sig: Vec::new(),
        };

        let mut header_batch = WriteBatch::new();
        chainstate
            .insert_headers_batch_with_pow(
                &[header.clone()],
                &params.consensus,
                &mut header_batch,
                false,
            )
            .expect("insert header");
        chainstate
            .commit_batch(header_batch)
            .expect("commit header");

        let block = Block {
            header,
            transactions: vec![coinbase, spend_tx],
        };
        let block_bytes = block.consensus_encode().expect("encode block");
        let flags = ValidationFlags::default();
        let batch = chainstate
            .connect_block(
                &block,
                height,
                &params,
                &flags,
                true,
                None,
                None,
                Some(block_bytes.as_slice()),
                None,
            )
            .expect("connect block");
        chainstate.commit_batch(batch).expect("commit block");

        let mempool = Mutex::new(Mempool::new(0));
        let txid_hex = hash256_to_hex(&spend_txid);
        let value = rpc_gettransaction(
            &chainstate,
            &mempool,
            &wallet,
            vec![json!(txid_hex.clone())],
            &params,
        )
        .expect("rpc");
        let obj = value.as_object().expect("object");
        assert_eq!(obj.get("confirmations").and_then(Value::as_i64), Some(1));
        assert_eq!(
            obj.get("amount_zat").and_then(Value::as_i64),
            Some(-sent_value)
        );
        assert_eq!(obj.get("fee_zat").and_then(Value::as_i64), Some(-100));
        assert_eq!(obj.get("expiryheight").and_then(Value::as_i64), Some(0));
        let joinsplits = obj
            .get("vJoinSplit")
            .and_then(Value::as_array)
            .expect("vJoinSplit");
        assert!(joinsplits.is_empty());
    }

    #[test]
    fn gettransaction_can_serve_mempool_wallet_tx() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));
        let address = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let script_pubkey =
            address_to_script_pubkey(&address, params.network).expect("address script");

        let incoming_value = 3 * COIN;
        let tx = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: vec![TxIn {
                prevout: OutPoint {
                    hash: [0x44u8; 32],
                    index: 0,
                },
                script_sig: Vec::new(),
                sequence: 0,
            }],
            vout: vec![TxOut {
                value: incoming_value,
                script_pubkey,
            }],
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let txid = tx.txid().expect("txid");
        let raw = tx.consensus_encode().expect("encode tx");

        let entry = MempoolEntry {
            txid,
            tx,
            raw,
            time: 123,
            height: 0,
            fee: 0,
            value_in: 0,
            modified_size: 0,
            priority: 0.0,
            was_clear_at_entry: true,
            fee_delta: 0,
            priority_delta: 0.0,
            spent_outpoints: Vec::new(),
            parents: Vec::new(),
        };
        let mut inner = Mempool::new(0);
        inner.insert(entry).expect("insert mempool tx");
        let mempool = Mutex::new(inner);

        let txid_hex = hash256_to_hex(&txid);
        let value = rpc_gettransaction(
            &chainstate,
            &mempool,
            &wallet,
            vec![json!(txid_hex)],
            &params,
        )
        .expect("rpc");
        let obj = value.as_object().expect("object");
        assert_eq!(obj.get("confirmations").and_then(Value::as_i64), Some(0));
        assert_eq!(
            obj.get("amount_zat").and_then(Value::as_i64),
            Some(incoming_value)
        );
        assert_eq!(obj.get("time").and_then(Value::as_u64), Some(123));
        let joinsplits = obj
            .get("vJoinSplit")
            .and_then(Value::as_array)
            .expect("vJoinSplit");
        assert!(joinsplits.is_empty());
    }

    #[test]
    fn gettransaction_reports_fee_for_mempool_send_tx() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));
        let address = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let wallet_script_pubkey =
            address_to_script_pubkey(&address, params.network).expect("address script");

        let prevout = OutPoint {
            hash: [0x55u8; 32],
            index: 0,
        };
        let input_value = 10_000i64;
        let utxo_entry = fluxd_chainstate::utxo::UtxoEntry {
            value: input_value,
            script_pubkey: wallet_script_pubkey.clone(),
            height: 0,
            is_coinbase: false,
        };
        let utxo_key = fluxd_chainstate::utxo::outpoint_key_bytes(&prevout);
        let mut batch = WriteBatch::new();
        batch.put(Column::Utxo, utxo_key.as_bytes(), utxo_entry.encode());
        chainstate.commit_batch(batch).expect("commit utxo");

        let sent_value = 9_000i64;
        let change_value = 900i64;
        let other_script = p2pkh_script([0x66u8; 20]);
        let spend_tx = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: vec![TxIn {
                prevout: prevout.clone(),
                script_sig: Vec::new(),
                sequence: u32::MAX,
            }],
            vout: vec![
                TxOut {
                    value: sent_value,
                    script_pubkey: other_script,
                },
                TxOut {
                    value: change_value,
                    script_pubkey: wallet_script_pubkey,
                },
            ],
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let txid = spend_tx.txid().expect("txid");
        let raw = spend_tx.consensus_encode().expect("encode tx");

        let entry = MempoolEntry {
            txid,
            tx: spend_tx,
            raw,
            time: 123,
            height: 0,
            fee: 100,
            value_in: 0,
            modified_size: 0,
            priority: 0.0,
            was_clear_at_entry: true,
            fee_delta: 0,
            priority_delta: 0.0,
            spent_outpoints: vec![prevout],
            parents: Vec::new(),
        };
        let mut inner = Mempool::new(0);
        inner.insert(entry).expect("insert mempool tx");
        let mempool = Mutex::new(inner);

        let txid_hex = hash256_to_hex(&txid);
        let value = rpc_gettransaction(
            &chainstate,
            &mempool,
            &wallet,
            vec![json!(txid_hex.clone())],
            &params,
        )
        .expect("rpc");
        let obj = value.as_object().expect("object");
        assert_eq!(obj.get("confirmations").and_then(Value::as_i64), Some(0));
        assert_eq!(
            obj.get("amount_zat").and_then(Value::as_i64),
            Some(-sent_value)
        );
        assert_eq!(obj.get("fee_zat").and_then(Value::as_i64), Some(-100));
    }

    #[test]
    fn gettransaction_populates_walletconflicts_for_mempool_tx() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));
        let address = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let wallet_script_pubkey =
            address_to_script_pubkey(&address, params.network).expect("address script");

        let prevout = OutPoint {
            hash: [0x55u8; 32],
            index: 0,
        };
        let input_value = 10_000i64;
        let utxo_entry = fluxd_chainstate::utxo::UtxoEntry {
            value: input_value,
            script_pubkey: wallet_script_pubkey.clone(),
            height: 0,
            is_coinbase: false,
        };
        let utxo_key = fluxd_chainstate::utxo::outpoint_key_bytes(&prevout);
        let mut batch = WriteBatch::new();
        batch.put(Column::Utxo, utxo_key.as_bytes(), utxo_entry.encode());

        let conflict_txid: Hash256 = [0x99u8; 32];
        let spent_value = fluxd_chainstate::spentindex::SpentIndexValue {
            txid: conflict_txid,
            input_index: 0,
            block_height: 1,
            details: None,
        };
        batch.put(
            Column::SpentIndex,
            utxo_key.as_bytes(),
            spent_value.encode(),
        );
        chainstate
            .commit_batch(batch)
            .expect("commit utxo+spentindex");

        let other_script = p2pkh_script([0x66u8; 20]);
        let spend_tx = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: vec![TxIn {
                prevout: prevout.clone(),
                script_sig: Vec::new(),
                sequence: u32::MAX,
            }],
            vout: vec![TxOut {
                value: 9_000i64,
                script_pubkey: other_script,
            }],
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let txid = spend_tx.txid().expect("txid");
        let raw = spend_tx.consensus_encode().expect("encode tx");

        let entry = MempoolEntry {
            txid,
            tx: spend_tx,
            raw,
            time: 123,
            height: 0,
            fee: 0,
            value_in: 0,
            modified_size: 0,
            priority: 0.0,
            was_clear_at_entry: true,
            fee_delta: 0,
            priority_delta: 0.0,
            spent_outpoints: vec![prevout],
            parents: Vec::new(),
        };
        let mut inner = Mempool::new(0);
        inner.insert(entry).expect("insert mempool tx");
        let mempool = Mutex::new(inner);

        let txid_hex = hash256_to_hex(&txid);
        let value = rpc_gettransaction(
            &chainstate,
            &mempool,
            &wallet,
            vec![json!(txid_hex)],
            &params,
        )
        .expect("rpc");
        let obj = value.as_object().expect("object");
        let conflicts = obj
            .get("walletconflicts")
            .and_then(Value::as_array)
            .expect("walletconflicts");
        assert_eq!(conflicts.len(), 1);
        assert_eq!(
            conflicts[0].as_str(),
            Some(hash256_to_hex(&conflict_txid).as_str())
        );
    }

    #[test]
    fn gettransaction_suppresses_change_output_details_for_mempool_send_tx() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let from_address = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let wallet_script_pubkey =
            address_to_script_pubkey(&from_address, params.network).expect("address script");

        let change_address = rpc_getrawchangeaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("change address string")
            .to_string();
        let change_script_pubkey =
            address_to_script_pubkey(&change_address, params.network).expect("change script");

        let prevout = OutPoint {
            hash: [0x77u8; 32],
            index: 0,
        };
        let input_value = 10_000i64;
        let utxo_entry = fluxd_chainstate::utxo::UtxoEntry {
            value: input_value,
            script_pubkey: wallet_script_pubkey.clone(),
            height: 0,
            is_coinbase: false,
        };
        let utxo_key = fluxd_chainstate::utxo::outpoint_key_bytes(&prevout);
        let mut batch = WriteBatch::new();
        batch.put(Column::Utxo, utxo_key.as_bytes(), utxo_entry.encode());
        chainstate.commit_batch(batch).expect("commit utxo");

        let sent_value = 9_000i64;
        let change_value = 900i64;
        let other_script = p2pkh_script([0x66u8; 20]);
        let spend_tx = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: vec![TxIn {
                prevout: prevout.clone(),
                script_sig: Vec::new(),
                sequence: u32::MAX,
            }],
            vout: vec![
                TxOut {
                    value: sent_value,
                    script_pubkey: other_script,
                },
                TxOut {
                    value: change_value,
                    script_pubkey: change_script_pubkey,
                },
            ],
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let txid = spend_tx.txid().expect("txid");
        let raw = spend_tx.consensus_encode().expect("encode tx");

        let entry = MempoolEntry {
            txid,
            tx: spend_tx,
            raw,
            time: 123,
            height: 0,
            fee: 100,
            value_in: 0,
            modified_size: 0,
            priority: 0.0,
            was_clear_at_entry: true,
            fee_delta: 0,
            priority_delta: 0.0,
            spent_outpoints: vec![prevout],
            parents: Vec::new(),
        };
        let mut inner = Mempool::new(0);
        inner.insert(entry).expect("insert mempool tx");
        let mempool = Mutex::new(inner);

        let txid_hex = hash256_to_hex(&txid);
        let value = rpc_gettransaction(
            &chainstate,
            &mempool,
            &wallet,
            vec![json!(txid_hex.clone())],
            &params,
        )
        .expect("rpc");
        let obj = value.as_object().expect("object");
        assert_eq!(obj.get("confirmations").and_then(Value::as_i64), Some(0));
        assert_eq!(
            obj.get("amount_zat").and_then(Value::as_i64),
            Some(-sent_value)
        );

        let details = obj
            .get("details")
            .and_then(Value::as_array)
            .expect("details");
        assert!(details
            .iter()
            .filter_map(Value::as_object)
            .any(|row| { row.get("category").and_then(Value::as_str) == Some("send") }));
        assert!(!details
            .iter()
            .filter_map(Value::as_object)
            .any(|row| { row.get("category").and_then(Value::as_str) == Some("receive") }));
        assert!(!details.iter().filter_map(Value::as_object).any(|row| {
            row.get("address").and_then(Value::as_str) == Some(change_address.as_str())
        }));
    }

    #[test]
    fn gettransaction_requires_include_watchonly_for_watchonly_tx() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let _owned_address = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();

        let watch_script = p2pkh_script([0x33u8; 20]);
        let watch_address =
            script_pubkey_to_address(&watch_script, params.network).expect("watch address");
        rpc_importaddress(
            &chainstate,
            &wallet,
            vec![json!(watch_address.clone()), Value::Null, json!(false)],
            &params,
        )
        .expect("rpc");

        let (txid, _vout, _height, miner_value) =
            mine_regtest_block_to_script(&chainstate, &params, watch_script);

        let mempool = Mutex::new(Mempool::new(0));
        let txid_hex = hash256_to_hex(&txid);

        let err = rpc_gettransaction(
            &chainstate,
            &mempool,
            &wallet,
            vec![json!(txid_hex.clone())],
            &params,
        )
        .unwrap_err();
        assert_eq!(err.code, RPC_INVALID_ADDRESS_OR_KEY);

        let value = rpc_gettransaction(
            &chainstate,
            &mempool,
            &wallet,
            vec![json!(txid_hex.clone()), json!(true)],
            &params,
        )
        .expect("rpc");
        let obj = value.as_object().expect("object");
        assert_eq!(
            obj.get("txid").and_then(Value::as_str),
            Some(txid_hex.as_str())
        );
        assert_eq!(
            obj.get("amount_zat").and_then(Value::as_i64),
            Some(miner_value)
        );
        assert_eq!(
            obj.get("involvesWatchonly").and_then(Value::as_bool),
            Some(true)
        );
    }

    #[test]
    fn listtransactions_orders_oldest_to_newest() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));
        let address = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let script_pubkey =
            address_to_script_pubkey(&address, params.network).expect("address script");

        let (txid_a, _vout, height_a, miner_value_a) =
            mine_regtest_block_to_script(&chainstate, &params, script_pubkey.clone());
        assert_eq!(height_a, 1);
        let (txid_b, _vout, height_b, miner_value_b) =
            mine_regtest_block_to_script(&chainstate, &params, script_pubkey.clone());
        assert_eq!(height_b, 2);

        let mempool_tx = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: vec![TxIn {
                prevout: OutPoint {
                    hash: [0x77u8; 32],
                    index: 0,
                },
                script_sig: Vec::new(),
                sequence: 0,
            }],
            vout: vec![TxOut {
                value: COIN,
                script_pubkey,
            }],
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let mempool_txid = mempool_tx.txid().expect("txid");
        let mempool_raw = mempool_tx.consensus_encode().expect("encode tx");
        let entry = MempoolEntry {
            txid: mempool_txid,
            tx: mempool_tx,
            raw: mempool_raw,
            time: 200,
            height: 0,
            fee: 0,
            value_in: 0,
            modified_size: 0,
            priority: 0.0,
            was_clear_at_entry: true,
            fee_delta: 0,
            priority_delta: 0.0,
            spent_outpoints: Vec::new(),
            parents: Vec::new(),
        };
        let mut inner = Mempool::new(0);
        inner.insert(entry).expect("insert mempool tx");
        let mempool = Mutex::new(inner);

        let value =
            rpc_listtransactions(&chainstate, &mempool, &wallet, Vec::new(), &params).expect("rpc");
        let arr = value.as_array().expect("array");
        assert_eq!(arr.len(), 3);

        let mem_txid_hex = hash256_to_hex(&mempool_txid);
        let txid_b_hex = hash256_to_hex(&txid_b);
        let txid_a_hex = hash256_to_hex(&txid_a);

        let row0 = arr[0].as_object().expect("object");
        assert_eq!(
            row0.get("txid").and_then(Value::as_str),
            Some(txid_a_hex.as_str())
        );
        assert_eq!(row0.get("confirmations").and_then(Value::as_i64), Some(2));
        assert_eq!(
            row0.get("amount_zat").and_then(Value::as_i64),
            Some(miner_value_a)
        );

        let row1 = arr[1].as_object().expect("object");
        assert_eq!(
            row1.get("txid").and_then(Value::as_str),
            Some(txid_b_hex.as_str())
        );
        assert_eq!(row1.get("confirmations").and_then(Value::as_i64), Some(1));
        assert_eq!(
            row1.get("amount_zat").and_then(Value::as_i64),
            Some(miner_value_b)
        );

        let row2 = arr[2].as_object().expect("object");
        assert_eq!(
            row2.get("txid").and_then(Value::as_str),
            Some(mem_txid_hex.as_str())
        );
        assert_eq!(row2.get("confirmations").and_then(Value::as_i64), Some(0));
        assert_eq!(row2.get("amount_zat").and_then(Value::as_i64), Some(COIN));
    }

    #[test]
    fn listtransactions_includes_wallet_store_transactions() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));
        let address = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let script_pubkey =
            address_to_script_pubkey(&address, params.network).expect("address script");

        let (_txid_a, _vout, height_a, _miner_value_a) =
            mine_regtest_block_to_script(&chainstate, &params, script_pubkey.clone());
        assert_eq!(height_a, 1);
        let (_txid_b, _vout, height_b, _miner_value_b) =
            mine_regtest_block_to_script(&chainstate, &params, script_pubkey.clone());
        assert_eq!(height_b, 2);

        let mempool_tx = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: vec![TxIn {
                prevout: OutPoint {
                    hash: [0x77u8; 32],
                    index: 0,
                },
                script_sig: Vec::new(),
                sequence: 0,
            }],
            vout: vec![TxOut {
                value: COIN,
                script_pubkey: script_pubkey.clone(),
            }],
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let mempool_txid = mempool_tx.txid().expect("txid");
        let mempool_raw = mempool_tx.consensus_encode().expect("encode tx");
        let entry = MempoolEntry {
            txid: mempool_txid,
            tx: mempool_tx,
            raw: mempool_raw,
            time: 0,
            height: 0,
            fee: 0,
            value_in: 0,
            modified_size: 0,
            priority: 0.0,
            was_clear_at_entry: true,
            fee_delta: 0,
            priority_delta: 0.0,
            spent_outpoints: Vec::new(),
            parents: Vec::new(),
        };
        let mut inner = Mempool::new(0);
        inner.insert(entry).expect("insert mempool tx");
        let mempool = Mutex::new(inner);

        let stored_tx = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: vec![TxIn {
                prevout: OutPoint {
                    hash: [0x99u8; 32],
                    index: 0,
                },
                script_sig: Vec::new(),
                sequence: 0,
            }],
            vout: vec![TxOut {
                value: COIN,
                script_pubkey,
            }],
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let stored_txid = stored_tx.txid().expect("txid");
        let stored_txid_hex = hash256_to_hex(&stored_txid);
        let stored_raw = stored_tx.consensus_encode().expect("encode tx");
        {
            let mut guard = wallet.lock().expect("wallet lock");
            let mut tx_values = std::collections::BTreeMap::new();
            tx_values.insert("comment".to_string(), "hello".to_string());
            tx_values.insert("to".to_string(), "world".to_string());
            guard
                .record_transaction_with_values(stored_txid, stored_raw, tx_values)
                .expect("record tx");
        }

        let value =
            rpc_listtransactions(&chainstate, &mempool, &wallet, Vec::new(), &params).expect("rpc");
        let arr = value.as_array().expect("array");
        assert_eq!(arr.len(), 4);
        let last = arr[3].as_object().expect("object");
        assert_eq!(
            last.get("txid").and_then(Value::as_str),
            Some(stored_txid_hex.as_str())
        );
        assert_eq!(last.get("confirmations").and_then(Value::as_i64), Some(-1));
        assert_eq!(last.get("comment").and_then(Value::as_str), Some("hello"));
        assert_eq!(last.get("to").and_then(Value::as_str), Some("world"));
    }

    #[test]
    fn listtransactions_includes_fee_for_send_tx() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));
        let address = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let wallet_script_pubkey =
            address_to_script_pubkey(&address, params.network).expect("address script");

        let prevout = OutPoint {
            hash: [0x55u8; 32],
            index: 0,
        };
        let input_value = 10_000i64;
        let utxo_entry = fluxd_chainstate::utxo::UtxoEntry {
            value: input_value,
            script_pubkey: wallet_script_pubkey.clone(),
            height: 0,
            is_coinbase: false,
        };
        let utxo_key = fluxd_chainstate::utxo::outpoint_key_bytes(&prevout);
        let mut batch = WriteBatch::new();
        batch.put(Column::Utxo, utxo_key.as_bytes(), utxo_entry.encode());
        chainstate.commit_batch(batch).expect("commit utxo");

        let sent_value = 9_000i64;
        let change_value = 900i64;
        let other_script = p2pkh_script([0x66u8; 20]);
        let spend_tx = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: vec![TxIn {
                prevout: prevout.clone(),
                script_sig: Vec::new(),
                sequence: u32::MAX,
            }],
            vout: vec![
                TxOut {
                    value: sent_value,
                    script_pubkey: other_script,
                },
                TxOut {
                    value: change_value,
                    script_pubkey: wallet_script_pubkey,
                },
            ],
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let txid = spend_tx.txid().expect("txid");
        let raw = spend_tx.consensus_encode().expect("encode tx");

        let entry = MempoolEntry {
            txid,
            tx: spend_tx,
            raw,
            time: 123,
            height: 0,
            fee: 100,
            value_in: 0,
            modified_size: 0,
            priority: 0.0,
            was_clear_at_entry: true,
            fee_delta: 0,
            priority_delta: 0.0,
            spent_outpoints: vec![prevout],
            parents: Vec::new(),
        };
        let mut inner = Mempool::new(0);
        inner.insert(entry).expect("insert mempool tx");
        let mempool = Mutex::new(inner);

        let value =
            rpc_listtransactions(&chainstate, &mempool, &wallet, Vec::new(), &params).expect("rpc");
        let arr = value.as_array().expect("array");
        assert!(arr.iter().filter_map(Value::as_object).any(|row| {
            row.get("category").and_then(Value::as_str) == Some("send")
                && row.get("fee_zat").and_then(Value::as_i64) == Some(-100)
        }));
    }

    #[test]
    fn listsinceblock_filters_and_sets_lastblock() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));
        let address = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let script_pubkey =
            address_to_script_pubkey(&address, params.network).expect("address script");

        let (_txid_a, _vout, height_a, _miner_value_a) =
            mine_regtest_block_to_script(&chainstate, &params, script_pubkey.clone());
        assert_eq!(height_a, 1);
        let (txid_b, _vout, height_b, _miner_value_b) =
            mine_regtest_block_to_script(&chainstate, &params, script_pubkey.clone());
        assert_eq!(height_b, 2);
        let txid_b_hex = hash256_to_hex(&txid_b);

        let blockhash_a = chainstate
            .height_hash(height_a)
            .expect("height_hash")
            .expect("blockhash a");
        let blockhash_b = chainstate
            .height_hash(height_b)
            .expect("height_hash")
            .expect("blockhash b");
        let blockhash_a_hex = hash256_to_hex(&blockhash_a);
        let blockhash_b_hex = hash256_to_hex(&blockhash_b);

        let mempool_tx = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: vec![TxIn {
                prevout: OutPoint {
                    hash: [0x77u8; 32],
                    index: 0,
                },
                script_sig: Vec::new(),
                sequence: 0,
            }],
            vout: vec![TxOut {
                value: COIN,
                script_pubkey,
            }],
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let mempool_txid = mempool_tx.txid().expect("txid");
        let mempool_txid_hex = hash256_to_hex(&mempool_txid);
        let mempool_raw = mempool_tx.consensus_encode().expect("encode tx");
        let entry = MempoolEntry {
            txid: mempool_txid,
            tx: mempool_tx,
            raw: mempool_raw,
            time: 200,
            height: 0,
            fee: 0,
            value_in: 0,
            modified_size: 0,
            priority: 0.0,
            was_clear_at_entry: true,
            fee_delta: 0,
            priority_delta: 0.0,
            spent_outpoints: Vec::new(),
            parents: Vec::new(),
        };
        let mut inner = Mempool::new(0);
        inner.insert(entry).expect("insert mempool tx");
        let mempool = Mutex::new(inner);

        let value =
            rpc_listsinceblock(&chainstate, &mempool, &wallet, Vec::new(), &params).expect("rpc");
        let obj = value.as_object().expect("object");
        assert_eq!(
            obj.get("lastblock").and_then(Value::as_str),
            Some(blockhash_b_hex.as_str())
        );
        let txs = obj
            .get("transactions")
            .and_then(Value::as_array)
            .expect("transactions array");
        assert_eq!(txs.len(), 3);
        let last = txs[2].as_object().expect("object");
        assert_eq!(
            last.get("txid").and_then(Value::as_str),
            Some(mempool_txid_hex.as_str())
        );

        let value = rpc_listsinceblock(
            &chainstate,
            &mempool,
            &wallet,
            vec![json!("not-a-blockhash")],
            &params,
        )
        .expect("rpc");
        let obj = value.as_object().expect("object");
        assert_eq!(
            obj.get("lastblock").and_then(Value::as_str),
            Some(blockhash_b_hex.as_str())
        );
        let txs = obj
            .get("transactions")
            .and_then(Value::as_array)
            .expect("transactions array");
        assert_eq!(txs.len(), 3);
        let last = txs[2].as_object().expect("object");
        assert_eq!(
            last.get("txid").and_then(Value::as_str),
            Some(mempool_txid_hex.as_str())
        );

        let value = rpc_listsinceblock(
            &chainstate,
            &mempool,
            &wallet,
            vec![Value::String(blockhash_a_hex.clone())],
            &params,
        )
        .expect("rpc");
        let obj = value.as_object().expect("object");
        assert_eq!(
            obj.get("lastblock").and_then(Value::as_str),
            Some(blockhash_b_hex.as_str())
        );
        let txs = obj
            .get("transactions")
            .and_then(Value::as_array)
            .expect("transactions array");
        assert_eq!(txs.len(), 2);
        let first = txs[0].as_object().expect("object");
        assert_eq!(
            first.get("txid").and_then(Value::as_str),
            Some(txid_b_hex.as_str())
        );

        let value = rpc_listsinceblock(
            &chainstate,
            &mempool,
            &wallet,
            vec![Value::String(format!("{blockhash_a_hex} trailing"))],
            &params,
        )
        .expect("rpc");
        let obj = value.as_object().expect("object");
        assert_eq!(
            obj.get("lastblock").and_then(Value::as_str),
            Some(blockhash_b_hex.as_str())
        );
        let txs = obj
            .get("transactions")
            .and_then(Value::as_array)
            .expect("transactions array");
        assert_eq!(txs.len(), 2);
        let first = txs[0].as_object().expect("object");
        assert_eq!(
            first.get("txid").and_then(Value::as_str),
            Some(txid_b_hex.as_str())
        );

        let value = rpc_listsinceblock(
            &chainstate,
            &mempool,
            &wallet,
            vec![Value::Null, json!(2)],
            &params,
        )
        .expect("rpc");
        let obj = value.as_object().expect("object");
        assert_eq!(
            obj.get("lastblock").and_then(Value::as_str),
            Some(blockhash_a_hex.as_str())
        );
    }

    #[test]
    fn listsinceblock_includes_wallet_store_transactions() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));
        let address = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let script_pubkey =
            address_to_script_pubkey(&address, params.network).expect("address script");

        let (_txid_a, _vout, height_a, _miner_value_a) =
            mine_regtest_block_to_script(&chainstate, &params, script_pubkey.clone());
        assert_eq!(height_a, 1);
        let (_txid_b, _vout, height_b, _miner_value_b) =
            mine_regtest_block_to_script(&chainstate, &params, script_pubkey.clone());
        assert_eq!(height_b, 2);

        let mempool_tx = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: vec![TxIn {
                prevout: OutPoint {
                    hash: [0x77u8; 32],
                    index: 0,
                },
                script_sig: Vec::new(),
                sequence: 0,
            }],
            vout: vec![TxOut {
                value: COIN,
                script_pubkey: script_pubkey.clone(),
            }],
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let mempool_txid = mempool_tx.txid().expect("txid");
        let mempool_raw = mempool_tx.consensus_encode().expect("encode tx");
        let entry = MempoolEntry {
            txid: mempool_txid,
            tx: mempool_tx,
            raw: mempool_raw,
            time: 0,
            height: 0,
            fee: 0,
            value_in: 0,
            modified_size: 0,
            priority: 0.0,
            was_clear_at_entry: true,
            fee_delta: 0,
            priority_delta: 0.0,
            spent_outpoints: Vec::new(),
            parents: Vec::new(),
        };
        let mut inner = Mempool::new(0);
        inner.insert(entry).expect("insert mempool tx");
        let mempool = Mutex::new(inner);

        let stored_tx = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: vec![TxIn {
                prevout: OutPoint {
                    hash: [0x99u8; 32],
                    index: 0,
                },
                script_sig: Vec::new(),
                sequence: 0,
            }],
            vout: vec![TxOut {
                value: COIN,
                script_pubkey,
            }],
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };
        let stored_txid = stored_tx.txid().expect("txid");
        let stored_txid_hex = hash256_to_hex(&stored_txid);
        let stored_raw = stored_tx.consensus_encode().expect("encode tx");
        {
            let mut guard = wallet.lock().expect("wallet lock");
            let mut tx_values = std::collections::BTreeMap::new();
            tx_values.insert("comment".to_string(), "hello".to_string());
            tx_values.insert("to".to_string(), "world".to_string());
            guard
                .record_transaction_with_values(stored_txid, stored_raw, tx_values)
                .expect("record tx");
        }

        let value =
            rpc_listsinceblock(&chainstate, &mempool, &wallet, Vec::new(), &params).expect("rpc");
        let obj = value.as_object().expect("object");
        let txs = obj
            .get("transactions")
            .and_then(Value::as_array)
            .expect("transactions array");
        assert_eq!(txs.len(), 4);
        let last = txs[3].as_object().expect("object");
        assert_eq!(
            last.get("txid").and_then(Value::as_str),
            Some(stored_txid_hex.as_str())
        );
        assert_eq!(last.get("confirmations").and_then(Value::as_i64), Some(-1));
        assert_eq!(last.get("comment").and_then(Value::as_str), Some("hello"));
        assert_eq!(last.get("to").and_then(Value::as_str), Some("world"));
    }

    #[test]
    fn listtransactions_includes_watchonly_when_requested() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let _owned_address = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();

        let watch_script = p2pkh_script([0x44u8; 20]);
        let watch_address =
            script_pubkey_to_address(&watch_script, params.network).expect("watch address");
        rpc_importaddress(
            &chainstate,
            &wallet,
            vec![json!(watch_address.clone()), Value::Null, json!(false)],
            &params,
        )
        .expect("rpc");

        let (txid, _vout, _height, miner_value) =
            mine_regtest_block_to_script(&chainstate, &params, watch_script);

        let mempool = Mutex::new(Mempool::new(0));

        let value =
            rpc_listtransactions(&chainstate, &mempool, &wallet, Vec::new(), &params).expect("rpc");
        assert_eq!(value.as_array().expect("array").len(), 0);

        let txid_hex = hash256_to_hex(&txid);
        let value = rpc_listtransactions(
            &chainstate,
            &mempool,
            &wallet,
            vec![Value::Null, json!(10), json!(0), json!(true)],
            &params,
        )
        .expect("rpc");
        let arr = value.as_array().expect("array");
        assert_eq!(arr.len(), 1);
        let row = arr[0].as_object().expect("object");
        assert_eq!(
            row.get("txid").and_then(Value::as_str),
            Some(txid_hex.as_str())
        );
        assert_eq!(
            row.get("amount_zat").and_then(Value::as_i64),
            Some(miner_value)
        );
        assert_eq!(
            row.get("involvesWatchonly").and_then(Value::as_bool),
            Some(true)
        );
    }

    #[test]
    fn listtransactions_honors_account_filter() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let addr_a = rpc_getnewaddress(&wallet, vec![json!("label-a")])
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let script_a = address_to_script_pubkey(&addr_a, params.network).expect("script pubkey");
        {
            let guard = wallet.lock().expect("wallet lock");
            assert_eq!(
                guard.label_for_script_pubkey(&script_a),
                Some("label-a"),
                "wallet should store label for addr_a script"
            );
        }
        let (txid_a, _vout_a, _height_a, _value_a) =
            mine_regtest_block_to_script(&chainstate, &params, script_a);

        let addr_b = rpc_getnewaddress(&wallet, vec![json!("label-b")])
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let script_b = address_to_script_pubkey(&addr_b, params.network).expect("script pubkey");
        let (txid_b, _vout_b, _height_b, _value_b) =
            mine_regtest_block_to_script(&chainstate, &params, script_b);

        let mempool = Mutex::new(Mempool::new(0));

        let view_a = rpc_gettransaction(
            &chainstate,
            &mempool,
            &wallet,
            vec![Value::String(hash256_to_hex(&txid_a))],
            &params,
        )
        .expect("gettransaction");
        let details_a = view_a
            .as_object()
            .and_then(|obj| obj.get("details"))
            .and_then(Value::as_array)
            .expect("details array");
        assert!(
            details_a.iter().any(|row| {
                row.get("address")
                    .and_then(Value::as_str)
                    .is_some_and(|value| value == addr_a.as_str())
            }),
            "expected gettransaction details to include addr_a"
        );
        assert!(
            details_a.iter().any(|row| {
                row.get("account")
                    .and_then(Value::as_str)
                    .is_some_and(|value| value == "label-a")
            }),
            "expected gettransaction details to include label-a account"
        );

        let filtered = rpc_listtransactions(
            &chainstate,
            &mempool,
            &wallet,
            vec![json!("label-a"), json!(100)],
            &params,
        )
        .expect("rpc");
        let arr = filtered.as_array().expect("array");
        assert!(
            !arr.is_empty(),
            "expected at least one listtransactions row"
        );
        assert!(arr.iter().all(|row| {
            row.get("account")
                .and_then(Value::as_str)
                .is_some_and(|value| value == "label-a")
        }));

        let txids = arr
            .iter()
            .filter_map(|row| row.get("txid").and_then(Value::as_str))
            .collect::<HashSet<_>>();
        assert!(txids.contains(hash256_to_hex(&txid_a).as_str()));
        assert!(!txids.contains(hash256_to_hex(&txid_b).as_str()));
    }

    #[test]
    fn listtransactions_applies_from_and_count() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let address_1 = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let script_1 =
            address_to_script_pubkey(&address_1, params.network).expect("address script");

        let address_2 = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let script_2 =
            address_to_script_pubkey(&address_2, params.network).expect("address script");

        let address_3 = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let script_3 =
            address_to_script_pubkey(&address_3, params.network).expect("address script");

        let (_txid_1, _vout_1, height_1, _value_1) =
            mine_regtest_block_to_script(&chainstate, &params, script_1);
        assert_eq!(height_1, 1);
        let (txid_2, _vout_2, height_2, _value_2) =
            mine_regtest_block_to_script(&chainstate, &params, script_2);
        assert_eq!(height_2, 2);
        let (txid_3, _vout_3, height_3, _value_3) =
            mine_regtest_block_to_script(&chainstate, &params, script_3);
        assert_eq!(height_3, 3);

        let mempool = Mutex::new(Mempool::new(0));

        let expected_txid_2 = hash256_to_hex(&txid_2);
        let expected_txid_3 = hash256_to_hex(&txid_3);

        let value = rpc_listtransactions(
            &chainstate,
            &mempool,
            &wallet,
            vec![json!("*"), json!(2), json!(0)],
            &params,
        )
        .expect("rpc");
        let arr = value.as_array().expect("array");
        assert_eq!(arr.len(), 2);
        assert_eq!(
            arr[0].get("txid").and_then(Value::as_str),
            Some(expected_txid_2.as_str())
        );
        assert_eq!(
            arr[1].get("txid").and_then(Value::as_str),
            Some(expected_txid_3.as_str())
        );

        let value = rpc_listtransactions(
            &chainstate,
            &mempool,
            &wallet,
            vec![json!("*"), json!(1), json!(1)],
            &params,
        )
        .expect("rpc");
        let arr = value.as_array().expect("array");
        assert_eq!(arr.len(), 1);
        assert_eq!(
            arr[0].get("txid").and_then(Value::as_str),
            Some(expected_txid_2.as_str())
        );
    }

    #[test]
    fn listtransactions_rejects_negative_count() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));
        let mempool = Mutex::new(Mempool::new(0));

        let err = rpc_listtransactions(
            &chainstate,
            &mempool,
            &wallet,
            vec![Value::Null, json!(-1)],
            &params,
        )
        .unwrap_err();
        assert_eq!(err.code, RPC_INVALID_PARAMETER);
        assert_eq!(err.message, "Negative count");
    }

    #[test]
    fn listtransactions_rejects_negative_from() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));
        let mempool = Mutex::new(Mempool::new(0));

        let err = rpc_listtransactions(
            &chainstate,
            &mempool,
            &wallet,
            vec![Value::Null, json!(1), json!(-1)],
            &params,
        )
        .unwrap_err();
        assert_eq!(err.code, RPC_INVALID_PARAMETER);
        assert_eq!(err.message, "Negative from");
    }

    #[test]
    fn listreceivedbyaddress_reports_wallet_receives() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));
        let address = rpc_getnewaddress(&wallet, vec![json!("label-a")])
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let script_pubkey =
            address_to_script_pubkey(&address, params.network).expect("address script");

        let (txid_a, _vout, height_a, miner_value_a) =
            mine_regtest_block_to_script(&chainstate, &params, script_pubkey.clone());
        assert_eq!(height_a, 1);
        let (txid_b, _vout, height_b, miner_value_b) =
            mine_regtest_block_to_script(&chainstate, &params, script_pubkey);
        assert_eq!(height_b, 2);

        let mempool = Mutex::new(Mempool::new(0));
        let value = rpc_listreceivedbyaddress(&chainstate, &mempool, &wallet, Vec::new(), &params)
            .expect("rpc");
        let arr = value.as_array().expect("array");
        assert_eq!(arr.len(), 1);
        let row = arr[0].as_object().expect("object");
        assert_eq!(
            row.get("address").and_then(Value::as_str),
            Some(address.as_str())
        );
        assert_eq!(row.get("account").and_then(Value::as_str), Some("label-a"));
        assert_eq!(row.get("label").and_then(Value::as_str), Some("label-a"));
        assert_eq!(
            row.get("amount"),
            Some(&amount_to_value(miner_value_a + miner_value_b))
        );
        assert_eq!(row.get("confirmations").and_then(Value::as_i64), Some(1));
        let txids = row.get("txids").and_then(Value::as_array).expect("txids");
        let got = txids
            .iter()
            .map(|value| value.as_str().expect("txid string").to_string())
            .collect::<HashSet<_>>();
        let expected = [hash256_to_hex(&txid_a), hash256_to_hex(&txid_b)]
            .into_iter()
            .collect::<HashSet<_>>();
        assert_eq!(got, expected);

        let value =
            rpc_listreceivedbyaddress(&chainstate, &mempool, &wallet, vec![json!(2)], &params)
                .expect("rpc");
        let arr = value.as_array().expect("array");
        assert_eq!(arr.len(), 1);
        let row = arr[0].as_object().expect("object");
        assert_eq!(
            row.get("address").and_then(Value::as_str),
            Some(address.as_str())
        );
        assert_eq!(row.get("account").and_then(Value::as_str), Some("label-a"));
        assert_eq!(row.get("label").and_then(Value::as_str), Some("label-a"));
        assert_eq!(row.get("amount"), Some(&amount_to_value(miner_value_a)));
        assert_eq!(row.get("confirmations").and_then(Value::as_i64), Some(2));
        let txids = row.get("txids").and_then(Value::as_array).expect("txids");
        let expected_txid = hash256_to_hex(&txid_a);
        assert_eq!(txids, &vec![Value::String(expected_txid)]);

        let other_address =
            script_pubkey_to_address(&p2pkh_script([0x22u8; 20]), params.network).expect("address");
        let value = rpc_listreceivedbyaddress(
            &chainstate,
            &mempool,
            &wallet,
            vec![json!(1), json!(true), Value::Null, json!(other_address)],
            &params,
        )
        .expect("rpc");
        let arr = value.as_array().expect("array");
        assert_eq!(arr.len(), 0);
    }

    #[test]
    fn listreceivedbyaddress_sets_involves_watchonly_for_watchonly_receives() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let _owned_address = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();

        let watch_script = p2pkh_script([0x66u8; 20]);
        let watch_address =
            script_pubkey_to_address(&watch_script, params.network).expect("watch address");
        rpc_importaddress(
            &chainstate,
            &wallet,
            vec![json!(watch_address.clone()), Value::Null, json!(false)],
            &params,
        )
        .expect("rpc");

        let (txid, _vout, _height, miner_value) =
            mine_regtest_block_to_script(&chainstate, &params, watch_script);

        let mempool = Mutex::new(Mempool::new(0));

        let value = rpc_listreceivedbyaddress(&chainstate, &mempool, &wallet, Vec::new(), &params)
            .expect("rpc");
        assert_eq!(value.as_array().expect("array").len(), 0);

        let value = rpc_listreceivedbyaddress(
            &chainstate,
            &mempool,
            &wallet,
            vec![json!(1), json!(false), json!(true)],
            &params,
        )
        .expect("rpc");
        let arr = value.as_array().expect("array");
        assert_eq!(arr.len(), 1);
        let row = arr[0].as_object().expect("object");
        assert_eq!(
            row.get("address").and_then(Value::as_str),
            Some(watch_address.as_str())
        );
        assert_eq!(row.get("amount"), Some(&amount_to_value(miner_value)));
        assert_eq!(
            row.get("involvesWatchonly").and_then(Value::as_bool),
            Some(true)
        );
        let txids = row.get("txids").and_then(Value::as_array).expect("txids");
        let expected_txid = hash256_to_hex(&txid);
        assert_eq!(txids, &vec![Value::String(expected_txid)]);
    }

    #[test]
    fn sendtoaddress_funds_signs_and_broadcasts_sapling_tx_when_upgrade_active() {
        let (chainstate, mut params, data_dir) = setup_regtest_chainstate();
        params.consensus.upgrades[UpgradeIndex::Acadia.as_usize()].activation_height = 1;

        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));
        let from_address = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let from_script =
            address_to_script_pubkey(&from_address, params.network).expect("address script");

        let outpoint = OutPoint {
            hash: [0x11u8; 32],
            index: 0,
        };
        let utxo_entry = fluxd_chainstate::utxo::UtxoEntry {
            value: 5 * COIN,
            script_pubkey: from_script.clone(),
            height: 0,
            is_coinbase: false,
        };
        let utxo_key = fluxd_chainstate::utxo::outpoint_key_bytes(&outpoint);
        let addr_key =
            fluxd_chainstate::address_index::address_outpoint_key(&from_script, &outpoint)
                .expect("address outpoint key");
        let mut batch = WriteBatch::new();
        batch.put(Column::Utxo, utxo_key.as_bytes(), utxo_entry.encode());
        batch.put(Column::AddressOutpoint, addr_key, []);
        chainstate.commit_batch(batch).expect("commit utxo");

        let mempool = Mutex::new(Mempool::new(0));
        let mempool_policy = MempoolPolicy::standard(1000, true);
        let mempool_metrics = MempoolMetrics::default();
        let fee_estimator = Mutex::new(FeeEstimator::new(128));
        let mempool_flags = ValidationFlags::default();
        let (tx_announce, _rx) = broadcast::channel(16);

        let to_address =
            script_pubkey_to_address(&p2pkh_script([0x22u8; 20]), params.network).expect("address");

        let value = rpc_sendtoaddress(
            &chainstate,
            &mempool,
            &mempool_policy,
            &mempool_metrics,
            &fee_estimator,
            2,
            &mempool_flags,
            &wallet,
            vec![json!(to_address), json!("1.0")],
            &params,
            &tx_announce,
        )
        .expect("rpc");
        let txid_hex = value.as_str().expect("txid string");
        assert!(is_hex_64(txid_hex));

        let txid = parse_hash(&Value::String(txid_hex.to_string())).expect("parse txid");
        let guard = mempool.lock().expect("mempool lock");
        let entry = guard.get(&txid).expect("mempool entry");
        assert!(entry.tx.f_overwintered);
        assert_eq!(entry.tx.version, 4);
        assert_eq!(entry.tx.version_group_id, SAPLING_VERSION_GROUP_ID);
        assert!(entry.tx.expiry_height > 0);
    }

    #[test]
    fn sendtoaddress_supports_p2sh_destination() {
        let (chainstate, mut params, data_dir) = setup_regtest_chainstate();
        params.consensus.upgrades[UpgradeIndex::Acadia.as_usize()].activation_height = 1;

        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));
        let from_address = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let other_address = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let from_script =
            address_to_script_pubkey(&from_address, params.network).expect("address script");

        let multisig = rpc_createmultisig(
            &wallet,
            vec![json!(2), json!([from_address.clone(), other_address])],
            &params,
        )
        .expect("rpc");
        let ms_addr = multisig
            .get("address")
            .and_then(Value::as_str)
            .expect("multisig address")
            .to_string();
        let ms_script =
            address_to_script_pubkey(&ms_addr, params.network).expect("multisig script");

        let outpoint = OutPoint {
            hash: [0x15u8; 32],
            index: 0,
        };
        let utxo_entry = fluxd_chainstate::utxo::UtxoEntry {
            value: 5 * COIN,
            script_pubkey: from_script.clone(),
            height: 0,
            is_coinbase: false,
        };
        let utxo_key = fluxd_chainstate::utxo::outpoint_key_bytes(&outpoint);
        let addr_key =
            fluxd_chainstate::address_index::address_outpoint_key(&from_script, &outpoint)
                .expect("address outpoint key");
        let mut batch = WriteBatch::new();
        batch.put(Column::Utxo, utxo_key.as_bytes(), utxo_entry.encode());
        batch.put(Column::AddressOutpoint, addr_key, []);
        chainstate.commit_batch(batch).expect("commit utxo");

        let mempool = Mutex::new(Mempool::new(0));
        let mempool_policy = MempoolPolicy::standard(1000, true);
        let mempool_metrics = MempoolMetrics::default();
        let fee_estimator = Mutex::new(FeeEstimator::new(128));
        let mempool_flags = ValidationFlags::default();
        let (tx_announce, _rx) = broadcast::channel(16);

        let value = rpc_sendtoaddress(
            &chainstate,
            &mempool,
            &mempool_policy,
            &mempool_metrics,
            &fee_estimator,
            2,
            &mempool_flags,
            &wallet,
            vec![json!(ms_addr), json!("1.0")],
            &params,
            &tx_announce,
        )
        .expect("rpc");
        let txid_hex = value.as_str().expect("txid string");
        assert!(is_hex_64(txid_hex));

        let txid = parse_hash(&Value::String(txid_hex.to_string())).expect("parse txid");
        let guard = mempool.lock().expect("mempool lock");
        let entry = guard.get(&txid).expect("mempool entry");
        assert!(entry
            .tx
            .vout
            .iter()
            .any(|out| out.value == COIN && out.script_pubkey == ms_script));
    }

    #[test]
    fn sendtoaddress_supports_subtractfeefromamount() {
        let (chainstate, mut params, data_dir) = setup_regtest_chainstate();
        params.consensus.upgrades[UpgradeIndex::Acadia.as_usize()].activation_height = 1;

        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));
        let from_address = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let from_script =
            address_to_script_pubkey(&from_address, params.network).expect("address script");

        let outpoint = OutPoint {
            hash: [0x13u8; 32],
            index: 0,
        };
        let input_value = 5 * COIN;
        let utxo_entry = fluxd_chainstate::utxo::UtxoEntry {
            value: input_value,
            script_pubkey: from_script.clone(),
            height: 0,
            is_coinbase: false,
        };
        let utxo_key = fluxd_chainstate::utxo::outpoint_key_bytes(&outpoint);
        let addr_key =
            fluxd_chainstate::address_index::address_outpoint_key(&from_script, &outpoint)
                .expect("address outpoint key");
        let mut batch = WriteBatch::new();
        batch.put(Column::Utxo, utxo_key.as_bytes(), utxo_entry.encode());
        batch.put(Column::AddressOutpoint, addr_key, []);
        chainstate.commit_batch(batch).expect("commit utxo");

        let mempool = Mutex::new(Mempool::new(0));
        let mempool_policy = MempoolPolicy::standard(1000, true);
        let mempool_metrics = MempoolMetrics::default();
        let fee_estimator = Mutex::new(FeeEstimator::new(128));
        let mempool_flags = ValidationFlags::default();
        let (tx_announce, _rx) = broadcast::channel(16);

        let to_address =
            script_pubkey_to_address(&p2pkh_script([0x22u8; 20]), params.network).expect("address");
        let to_script = address_to_script_pubkey(&to_address, params.network).expect("script");

        let value = rpc_sendtoaddress(
            &chainstate,
            &mempool,
            &mempool_policy,
            &mempool_metrics,
            &fee_estimator,
            2,
            &mempool_flags,
            &wallet,
            vec![
                json!(to_address),
                json!("1.0"),
                Value::Null,
                Value::Null,
                Value::Bool(true),
            ],
            &params,
            &tx_announce,
        )
        .expect("rpc");
        let txid_hex = value.as_str().expect("txid string");
        assert!(is_hex_64(txid_hex));

        let txid = parse_hash(&Value::String(txid_hex.to_string())).expect("parse txid");
        let guard = mempool.lock().expect("mempool lock");
        let entry = guard.get(&txid).expect("mempool entry");

        let outputs_value: i64 = entry.tx.vout.iter().map(|out| out.value).sum();
        let fee = input_value - outputs_value;
        assert!(fee > 0);

        let to_value = entry
            .tx
            .vout
            .iter()
            .find(|out| out.script_pubkey == to_script)
            .expect("destination output")
            .value;
        assert_eq!(to_value, COIN - fee);

        let other_value: i64 = entry
            .tx
            .vout
            .iter()
            .filter(|out| out.script_pubkey != to_script)
            .map(|out| out.value)
            .sum();
        assert_eq!(other_value, input_value - COIN);
    }

    #[test]
    fn sendmany_funds_signs_and_broadcasts_sapling_tx_when_upgrade_active() {
        let (chainstate, mut params, data_dir) = setup_regtest_chainstate();
        params.consensus.upgrades[UpgradeIndex::Acadia.as_usize()].activation_height = 1;

        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));
        let from_address = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let from_script =
            address_to_script_pubkey(&from_address, params.network).expect("address script");

        let outpoint = OutPoint {
            hash: [0x12u8; 32],
            index: 0,
        };
        let utxo_entry = fluxd_chainstate::utxo::UtxoEntry {
            value: 10 * COIN,
            script_pubkey: from_script.clone(),
            height: 0,
            is_coinbase: false,
        };
        let utxo_key = fluxd_chainstate::utxo::outpoint_key_bytes(&outpoint);
        let addr_key =
            fluxd_chainstate::address_index::address_outpoint_key(&from_script, &outpoint)
                .expect("address outpoint key");
        let mut batch = WriteBatch::new();
        batch.put(Column::Utxo, utxo_key.as_bytes(), utxo_entry.encode());
        batch.put(Column::AddressOutpoint, addr_key, []);
        chainstate.commit_batch(batch).expect("commit utxo");

        let mempool = Mutex::new(Mempool::new(0));
        let mempool_policy = MempoolPolicy::standard(1000, true);
        let mempool_metrics = MempoolMetrics::default();
        let fee_estimator = Mutex::new(FeeEstimator::new(128));
        let mempool_flags = ValidationFlags::default();
        let (tx_announce, _rx) = broadcast::channel(16);

        let to_address_a =
            script_pubkey_to_address(&p2pkh_script([0x21u8; 20]), params.network).expect("address");
        let to_address_b =
            script_pubkey_to_address(&p2pkh_script([0x22u8; 20]), params.network).expect("address");
        let mut amounts = serde_json::Map::new();
        amounts.insert(to_address_a.clone(), json!("1.0"));
        amounts.insert(to_address_b.clone(), json!("2.0"));

        let value = rpc_sendmany(
            &chainstate,
            &mempool,
            &mempool_policy,
            &mempool_metrics,
            &fee_estimator,
            2,
            &mempool_flags,
            &wallet,
            vec![json!(""), Value::Object(amounts), json!(1)],
            &params,
            &tx_announce,
        )
        .expect("rpc");
        let txid_hex = value.as_str().expect("txid string");
        assert!(is_hex_64(txid_hex));

        let txid = parse_hash(&Value::String(txid_hex.to_string())).expect("parse txid");
        let guard = mempool.lock().expect("mempool lock");
        let entry = guard.get(&txid).expect("mempool entry");

        assert!(entry.tx.f_overwintered);
        assert_eq!(entry.tx.version, 4);
        assert_eq!(entry.tx.version_group_id, SAPLING_VERSION_GROUP_ID);
        assert!(entry.tx.expiry_height > 0);
        assert!(entry.tx.vout.len() >= 3);

        let script_a = address_to_script_pubkey(&to_address_a, params.network).expect("script a");
        let script_b = address_to_script_pubkey(&to_address_b, params.network).expect("script b");
        let mut found_a = false;
        let mut found_b = false;
        for output in &entry.tx.vout {
            if output.value == COIN && output.script_pubkey == script_a {
                found_a = true;
            }
            if output.value == 2 * COIN && output.script_pubkey == script_b {
                found_b = true;
            }
        }
        assert!(found_a);
        assert!(found_b);
    }

    #[test]
    fn sendmany_supports_p2sh_destination() {
        let (chainstate, mut params, data_dir) = setup_regtest_chainstate();
        params.consensus.upgrades[UpgradeIndex::Acadia.as_usize()].activation_height = 1;

        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));
        let from_address = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let other_address = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let from_script =
            address_to_script_pubkey(&from_address, params.network).expect("address script");

        let multisig = rpc_createmultisig(
            &wallet,
            vec![json!(2), json!([from_address.clone(), other_address])],
            &params,
        )
        .expect("rpc");
        let ms_addr = multisig
            .get("address")
            .and_then(Value::as_str)
            .expect("multisig address")
            .to_string();
        let ms_script =
            address_to_script_pubkey(&ms_addr, params.network).expect("multisig script");

        let outpoint = OutPoint {
            hash: [0x16u8; 32],
            index: 0,
        };
        let utxo_entry = fluxd_chainstate::utxo::UtxoEntry {
            value: 10 * COIN,
            script_pubkey: from_script.clone(),
            height: 0,
            is_coinbase: false,
        };
        let utxo_key = fluxd_chainstate::utxo::outpoint_key_bytes(&outpoint);
        let addr_key =
            fluxd_chainstate::address_index::address_outpoint_key(&from_script, &outpoint)
                .expect("address outpoint key");
        let mut batch = WriteBatch::new();
        batch.put(Column::Utxo, utxo_key.as_bytes(), utxo_entry.encode());
        batch.put(Column::AddressOutpoint, addr_key, []);
        chainstate.commit_batch(batch).expect("commit utxo");

        let mempool = Mutex::new(Mempool::new(0));
        let mempool_policy = MempoolPolicy::standard(1000, true);
        let mempool_metrics = MempoolMetrics::default();
        let fee_estimator = Mutex::new(FeeEstimator::new(128));
        let mempool_flags = ValidationFlags::default();
        let (tx_announce, _rx) = broadcast::channel(16);

        let to_address =
            script_pubkey_to_address(&p2pkh_script([0x21u8; 20]), params.network).expect("address");
        let to_script = address_to_script_pubkey(&to_address, params.network).expect("dest script");

        let mut amounts = serde_json::Map::new();
        amounts.insert(ms_addr.clone(), json!("1.0"));
        amounts.insert(to_address.clone(), json!("2.0"));

        let value = rpc_sendmany(
            &chainstate,
            &mempool,
            &mempool_policy,
            &mempool_metrics,
            &fee_estimator,
            2,
            &mempool_flags,
            &wallet,
            vec![json!(""), Value::Object(amounts), json!(1)],
            &params,
            &tx_announce,
        )
        .expect("rpc");
        let txid_hex = value.as_str().expect("txid string");
        assert!(is_hex_64(txid_hex));

        let txid = parse_hash(&Value::String(txid_hex.to_string())).expect("parse txid");
        let guard = mempool.lock().expect("mempool lock");
        let entry = guard.get(&txid).expect("mempool entry");

        let mut found_ms = false;
        let mut found_to = false;
        for output in &entry.tx.vout {
            if output.value == COIN && output.script_pubkey == ms_script {
                found_ms = true;
            }
            if output.value == 2 * COIN && output.script_pubkey == to_script {
                found_to = true;
            }
        }
        assert!(found_ms);
        assert!(found_to);
    }

    #[test]
    fn sendmany_supports_subtractfeefromamount() {
        let (chainstate, mut params, data_dir) = setup_regtest_chainstate();
        params.consensus.upgrades[UpgradeIndex::Acadia.as_usize()].activation_height = 1;

        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));
        let from_address = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let from_script =
            address_to_script_pubkey(&from_address, params.network).expect("address script");

        let outpoint = OutPoint {
            hash: [0x14u8; 32],
            index: 0,
        };
        let input_value = 10 * COIN;
        let utxo_entry = fluxd_chainstate::utxo::UtxoEntry {
            value: input_value,
            script_pubkey: from_script.clone(),
            height: 0,
            is_coinbase: false,
        };
        let utxo_key = fluxd_chainstate::utxo::outpoint_key_bytes(&outpoint);
        let addr_key =
            fluxd_chainstate::address_index::address_outpoint_key(&from_script, &outpoint)
                .expect("address outpoint key");
        let mut batch = WriteBatch::new();
        batch.put(Column::Utxo, utxo_key.as_bytes(), utxo_entry.encode());
        batch.put(Column::AddressOutpoint, addr_key, []);
        chainstate.commit_batch(batch).expect("commit utxo");

        let mempool = Mutex::new(Mempool::new(0));
        let mempool_policy = MempoolPolicy::standard(1000, true);
        let mempool_metrics = MempoolMetrics::default();
        let fee_estimator = Mutex::new(FeeEstimator::new(128));
        let mempool_flags = ValidationFlags::default();
        let (tx_announce, _rx) = broadcast::channel(16);

        let to_address_a =
            script_pubkey_to_address(&p2pkh_script([0x21u8; 20]), params.network).expect("a addr");
        let to_address_b =
            script_pubkey_to_address(&p2pkh_script([0x22u8; 20]), params.network).expect("b addr");

        let script_a = address_to_script_pubkey(&to_address_a, params.network).expect("script a");
        let script_b = address_to_script_pubkey(&to_address_b, params.network).expect("script b");

        let mut amounts = serde_json::Map::new();
        amounts.insert(to_address_a.clone(), json!("1.0"));
        amounts.insert(to_address_b.clone(), json!("2.0"));

        let subtract = vec![Value::String(to_address_a.clone())];

        let value = rpc_sendmany(
            &chainstate,
            &mempool,
            &mempool_policy,
            &mempool_metrics,
            &fee_estimator,
            2,
            &mempool_flags,
            &wallet,
            vec![
                json!(""),
                Value::Object(amounts),
                json!(1),
                Value::Null,
                Value::Array(subtract),
            ],
            &params,
            &tx_announce,
        )
        .expect("rpc");
        let txid_hex = value.as_str().expect("txid string");
        assert!(is_hex_64(txid_hex));

        let txid = parse_hash(&Value::String(txid_hex.to_string())).expect("parse txid");
        let guard = mempool.lock().expect("mempool lock");
        let entry = guard.get(&txid).expect("mempool entry");

        let outputs_value: i64 = entry.tx.vout.iter().map(|out| out.value).sum();
        let fee = input_value - outputs_value;
        assert!(fee > 0);

        let mut a_value = None;
        let mut b_value = None;
        let mut other_value = 0i64;
        for out in &entry.tx.vout {
            if out.script_pubkey == script_a {
                a_value = Some(out.value);
            } else if out.script_pubkey == script_b {
                b_value = Some(out.value);
            } else {
                other_value = other_value.saturating_add(out.value);
            }
        }

        assert_eq!(b_value, Some(2 * COIN));
        assert_eq!(a_value, Some(COIN - fee));
        assert_eq!(other_value, input_value - (COIN + 2 * COIN));
    }

    #[test]
    fn ping_returns_null() {
        let value = rpc_ping(Vec::new()).expect("rpc");
        assert_eq!(value, Value::Null);
    }

    #[test]
    fn ping_rejects_params() {
        let err = rpc_ping(vec![json!(1)]).unwrap_err();
        assert_eq!(err.code, RPC_INVALID_PARAMETER);
    }

    #[test]
    fn shielded_wallet_stubs_return_wallet_error() {
        let err = rpc_shielded_wallet_not_implemented(Vec::new(), "zsendmany").unwrap_err();
        assert_eq!(err.code, RPC_WALLET_ERROR);
        assert!(err.message.contains("zsendmany not implemented"));
    }

    #[test]
    fn decode_sprout_spending_key_accepts_regtest_prefix() {
        let key_bytes = [0x00u8; 32];
        let mut payload = Vec::new();
        payload.extend_from_slice(&[0xAC, 0x08]);
        payload.extend_from_slice(&key_bytes);
        let encoded = base58check_encode(&payload);

        let decoded = decode_sprout_spending_key(&encoded, Network::Regtest).expect("decode");
        assert_eq!(decoded.to_bytes(), key_bytes);
    }

    #[test]
    fn zcrawreceive_rejects_invalid_spending_key() {
        let (chainstate, params, _data_dir) = setup_regtest_chainstate();
        let err =
            rpc_zcrawreceive(&chainstate, vec![json!("notakey"), json!("")], &params).unwrap_err();
        assert_eq!(err.code, RPC_INVALID_ADDRESS_OR_KEY);
        assert_eq!(err.message, "Invalid spending key");
    }

    #[test]
    fn zcrawkeygen_returns_sprout_keys_with_network_prefixes() {
        let (_chainstate, params, _data_dir) = setup_regtest_chainstate();
        let value = rpc_zcrawkeygen(Vec::new(), &params).expect("rpc");
        let obj = value.as_object().expect("object");

        let zcaddr = obj
            .get("zcaddress")
            .and_then(Value::as_str)
            .expect("zcaddress");
        let sk = obj
            .get("zcsecretkey")
            .and_then(Value::as_str)
            .expect("zcsecretkey");
        let vk = obj
            .get("zcviewingkey")
            .and_then(Value::as_str)
            .expect("zcviewingkey");

        let decoded_key = decode_sprout_spending_key(sk, params.network).expect("decode sk");
        let addr_from_key = decoded_key.address();
        let (payingkey, transmissionkey) =
            decode_sprout_payment_address(zcaddr, params.network).expect("decode zcaddr");
        assert_eq!(addr_from_key.a_pk, payingkey);
        assert_eq!(addr_from_key.pk_enc, transmissionkey);

        let payload = base58check_decode(vk).expect("decode vk");
        assert_eq!(payload.len(), 3 + 64);
        assert!(
            payload.starts_with(&[0xA8, 0xAC, 0x0C]),
            "expected regtest viewing key prefix"
        );
    }

    #[test]
    fn help_accepts_zvalidateaddress_alias() {
        let value = rpc_help(vec![json!("z_validateaddress")]).expect("rpc");
        assert!(value.as_str().unwrap_or_default().contains("supported"));
    }

    #[test]
    fn stop_requests_shutdown() {
        let (tx, rx) = watch::channel(false);
        let value = rpc_stop(Vec::new(), &tx).expect("rpc");
        assert!(value.as_str().unwrap_or_default().contains("stopping"));
        assert!(*rx.borrow());
    }

    #[test]
    fn restart_requests_shutdown() {
        let (tx, rx) = watch::channel(false);
        let value = rpc_restart(Vec::new(), &tx).expect("rpc");
        assert!(value.as_str().unwrap_or_default().contains("restarting"));
        assert!(*rx.borrow());
    }

    #[test]
    fn reindex_writes_flag_and_requests_shutdown() {
        let data_dir = temp_data_dir("fluxd-reindex-test");
        std::fs::create_dir_all(&data_dir).expect("create data dir");
        let (tx, rx) = watch::channel(false);

        let value = rpc_reindex(Vec::new(), &data_dir, &tx).expect("rpc");
        assert!(value
            .as_str()
            .unwrap_or_default()
            .contains("reindex requested"));
        assert!(*rx.borrow());

        let flag_path = data_dir.join(crate::REINDEX_REQUEST_FILE_NAME);
        let contents = std::fs::read_to_string(&flag_path).expect("flag contents");
        assert_eq!(contents, "reindex\n");

        std::fs::remove_dir_all(&data_dir).ok();
    }

    #[test]
    fn rescanblockchain_populates_wallet_txcount() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let address = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let script_pubkey =
            address_to_script_pubkey(&address, params.network).expect("address script");

        mine_regtest_block_to_script(&chainstate, &params, script_pubkey.clone());
        mine_regtest_block_to_script(&chainstate, &params, script_pubkey);

        let mempool = Mutex::new(Mempool::new(0));
        let info = rpc_getwalletinfo(&chainstate, &mempool, &wallet, Vec::new()).expect("rpc");
        assert_eq!(info.get("txcount").and_then(Value::as_u64), Some(0));

        let value = rpc_rescanblockchain(&chainstate, &wallet, Vec::new()).expect("rpc");
        assert_eq!(value.get("start_height").and_then(Value::as_i64), Some(0));
        assert_eq!(value.get("stop_height").and_then(Value::as_i64), Some(2));

        let info = rpc_getwalletinfo(&chainstate, &mempool, &wallet, Vec::new()).expect("rpc");
        assert_eq!(info.get("txcount").and_then(Value::as_u64), Some(2));
    }

    #[test]
    fn rescanblockchain_accepts_height_range() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let address = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let script_pubkey =
            address_to_script_pubkey(&address, params.network).expect("address script");

        mine_regtest_block_to_script(&chainstate, &params, script_pubkey.clone());
        mine_regtest_block_to_script(&chainstate, &params, script_pubkey);

        let value =
            rpc_rescanblockchain(&chainstate, &wallet, vec![json!(2), json!(2)]).expect("rpc");
        assert_eq!(value.get("start_height").and_then(Value::as_i64), Some(2));
        assert_eq!(value.get("stop_height").and_then(Value::as_i64), Some(2));

        let mempool = Mutex::new(Mempool::new(0));
        let info = rpc_getwalletinfo(&chainstate, &mempool, &wallet, Vec::new()).expect("rpc");
        assert_eq!(info.get("txcount").and_then(Value::as_u64), Some(1));
    }

    #[test]
    fn rescanblockchain_persists_tx_bytes_for_gettransaction_fallback() {
        let (chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));

        let address = rpc_getnewaddress(&wallet, Vec::new())
            .expect("rpc")
            .as_str()
            .expect("address string")
            .to_string();
        let script_pubkey =
            address_to_script_pubkey(&address, params.network).expect("address script");

        let (txid, _vout, _height, miner_value) =
            mine_regtest_block_to_script(&chainstate, &params, script_pubkey);

        rpc_rescanblockchain(&chainstate, &wallet, vec![json!(1), json!(1)]).expect("rpc");

        {
            let guard = wallet.lock().expect("wallet lock");
            assert!(
                guard.transaction_bytes(&txid).is_some(),
                "rescan should store wallet tx bytes"
            );
        }

        let mut batch = WriteBatch::new();
        batch.delete(Column::TxIndex, txid);
        chainstate
            .commit_batch(batch)
            .expect("commit txindex delete");

        let mempool = Mutex::new(Mempool::new(0));
        let txid_hex = hash256_to_hex(&txid);
        let value = rpc_gettransaction(
            &chainstate,
            &mempool,
            &wallet,
            vec![json!(txid_hex.clone())],
            &params,
        )
        .expect("rpc");
        let obj = value.as_object().expect("object");
        assert_eq!(obj.get("confirmations").and_then(Value::as_i64), Some(-1));
        assert_eq!(
            obj.get("amount_zat").and_then(Value::as_i64),
            Some(miner_value)
        );
        assert_eq!(obj.get("generated").and_then(Value::as_bool), Some(true));

        let details = obj
            .get("details")
            .and_then(Value::as_array)
            .expect("details array");
        assert!(details
            .iter()
            .filter_map(Value::as_object)
            .any(|row| { row.get("category").and_then(Value::as_str) == Some("orphan") }));
    }

    #[test]
    fn verifychain_returns_bool() {
        let (chainstate, _params, _data_dir) = setup_regtest_chainstate();
        let value = rpc_verifychain(&chainstate, Vec::new()).expect("rpc");
        assert_eq!(value.as_bool(), Some(true));
    }

    #[test]
    fn network_hashrate_rpcs_return_numbers() {
        let (chainstate, params, _data_dir) = setup_regtest_chainstate();
        let value = rpc_getnetworkhashps(&chainstate, Vec::new(), &params).expect("rpc");
        assert!(value.as_i64().is_some());
        let value = rpc_getnetworksolps(&chainstate, Vec::new(), &params).expect("rpc");
        assert!(value.as_i64().is_some());
        let header_metrics = HeaderMetrics::default();
        let value = rpc_getlocalsolps(Vec::new(), &header_metrics).expect("rpc");
        assert!(value.as_f64().is_some());
    }

    #[test]
    fn getblocktemplate_has_cpp_schema_keys() {
        let (chainstate, params, _data_dir) = setup_regtest_chainstate();
        let mempool = Mutex::new(Mempool::new(0));
        let mempool_policy = MempoolPolicy::standard(0, true);
        let flags = ValidationFlags::default();

        let pubkey_hash = [0x11u8; 20];
        let script_pubkey = p2pkh_script(pubkey_hash);
        let miner_address =
            script_pubkey_to_address(&script_pubkey, params.network).expect("p2pkh address");

        let value = rpc_getblocktemplate(
            &chainstate,
            &mempool,
            &mempool_policy,
            Vec::new(),
            &params,
            &flags,
            Some(&miner_address),
        )
        .expect("rpc");
        let obj = value.as_object().expect("object");

        for key in [
            "capabilities",
            "version",
            "previousblockhash",
            "finalsaplingroothash",
            "transactions",
            "coinbasetxn",
            "longpollid",
            "target",
            "mintime",
            "mutable",
            "noncerange",
            "sigoplimit",
            "sizelimit",
            "curtime",
            "bits",
            "height",
        ] {
            assert!(obj.contains_key(key), "missing key {key}");
        }

        let prev_hash = obj
            .get("previousblockhash")
            .and_then(Value::as_str)
            .unwrap();
        assert!(is_hex_64(prev_hash));
        let sapling_root = obj
            .get("finalsaplingroothash")
            .and_then(Value::as_str)
            .unwrap();
        assert!(is_hex_64(sapling_root));
        let target = obj.get("target").and_then(Value::as_str).unwrap();
        assert!(is_hex_64(target));

        let coinbase = obj.get("coinbasetxn").and_then(Value::as_object).unwrap();
        for key in ["data", "hash", "depends", "fee", "sigops", "required"] {
            assert!(coinbase.contains_key(key), "missing coinbasetxn key {key}");
        }
        let coinbase_hash = coinbase.get("hash").and_then(Value::as_str).unwrap();
        assert!(is_hex_64(coinbase_hash));
        assert!(coinbase.get("depends").and_then(Value::as_array).is_some());
        assert!(coinbase.get("required").and_then(Value::as_bool).is_some());
    }

    #[test]
    fn getblocktemplate_honors_prioritisetransaction_priority_delta_for_free_txs() {
        let (chainstate, params, _data_dir) = setup_regtest_chainstate();
        let mempool_policy = MempoolPolicy::standard(1000, true);
        let flags = ValidationFlags::default();

        let pubkey_hash = [0x11u8; 20];
        let script_pubkey = p2pkh_script(pubkey_hash);
        let miner_address =
            script_pubkey_to_address(&script_pubkey, params.network).expect("p2pkh address");

        let tx = Transaction {
            f_overwintered: false,
            version: 1,
            version_group_id: 0,
            vin: Vec::new(),
            vout: Vec::new(),
            lock_time: 0,
            expiry_height: 0,
            value_balance: 0,
            shielded_spends: Vec::new(),
            shielded_outputs: Vec::new(),
            join_splits: Vec::new(),
            join_split_pub_key: [0u8; 32],
            join_split_sig: [0u8; 64],
            binding_sig: [0u8; 64],
            fluxnode: None,
        };

        let trigger_txid: Hash256 = [0x01u8; 32];
        let skipped_txid: Hash256 = [0x02u8; 32];
        let prioritised_txid: Hash256 = [0x03u8; 32];

        let mut inner = Mempool::new(0);
        for (txid, priority) in [
            (trigger_txid, 2.0f64),
            (skipped_txid, 0.0f64),
            (prioritised_txid, 0.0f64),
        ] {
            inner
                .insert(MempoolEntry {
                    txid,
                    tx: tx.clone(),
                    raw: vec![0u8; 10],
                    time: 0,
                    height: 0,
                    fee: 0,
                    value_in: 0,
                    modified_size: 0,
                    priority,
                    was_clear_at_entry: true,
                    fee_delta: 0,
                    priority_delta: 0.0,
                    spent_outpoints: Vec::new(),
                    parents: Vec::new(),
                })
                .expect("insert");
        }
        inner.prioritise_transaction(prioritised_txid, 1.0, 0);
        let mempool = Mutex::new(inner);

        let value = rpc_getblocktemplate(
            &chainstate,
            &mempool,
            &mempool_policy,
            Vec::new(),
            &params,
            &flags,
            Some(&miner_address),
        )
        .expect("rpc");
        let obj = value.as_object().expect("object");
        let txs = obj
            .get("transactions")
            .and_then(Value::as_array)
            .expect("transactions array");
        let hashes = txs
            .iter()
            .filter_map(|entry| entry.as_object())
            .filter_map(|entry| entry.get("hash"))
            .filter_map(Value::as_str)
            .map(str::to_string)
            .collect::<Vec<_>>();

        assert!(
            hashes.contains(&hash256_to_hex(&trigger_txid)),
            "missing trigger txid, hashes={hashes:?}"
        );
        assert!(
            hashes.contains(&hash256_to_hex(&prioritised_txid)),
            "missing prioritised txid, hashes={hashes:?}"
        );
        assert!(
            !hashes.contains(&hash256_to_hex(&skipped_txid)),
            "unexpected skipped txid, hashes={hashes:?}"
        );
    }

    #[test]
    fn getblocktemplate_generates_wallet_miner_address_when_unset() {
        let (_chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));
        assert_eq!(wallet.lock().expect("wallet lock").key_count(), 0);

        let miner = default_miner_address_from_wallet_for_blocktemplate(None, &[], &wallet)
            .expect("default miner");
        assert!(miner.is_some());
        assert_eq!(wallet.lock().expect("wallet lock").key_count(), 1);
    }

    #[test]
    fn getblocktemplate_does_not_touch_wallet_for_proposal_mode() {
        let (_chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));
        assert_eq!(wallet.lock().expect("wallet lock").key_count(), 0);

        let params = vec![json!({"mode":"proposal","data":"00"})];
        let miner = default_miner_address_from_wallet_for_blocktemplate(None, &params, &wallet)
            .expect("default miner");
        assert!(miner.is_none());
        assert_eq!(wallet.lock().expect("wallet lock").key_count(), 0);
    }

    #[test]
    fn getblocktemplate_does_not_touch_wallet_for_invalid_param_type() {
        let (_chainstate, params, data_dir) = setup_regtest_chainstate();
        let wallet = Mutex::new(Wallet::load_or_create(&data_dir, params.network).expect("wallet"));
        assert_eq!(wallet.lock().expect("wallet lock").key_count(), 0);

        let params = vec![json!(1)];
        let miner = default_miner_address_from_wallet_for_blocktemplate(None, &params, &wallet)
            .expect("default miner");
        assert!(miner.is_none());
        assert_eq!(wallet.lock().expect("wallet lock").key_count(), 0);
    }
}

fn default_miner_address_from_wallet_for_blocktemplate(
    miner_address: Option<&str>,
    params: &[Value],
    wallet: &Mutex<Wallet>,
) -> Result<Option<String>, RpcError> {
    if miner_address.is_some() {
        return Ok(None);
    }

    if params.len() > 1 {
        return Ok(None);
    }

    let request_obj = params.get(0).and_then(Value::as_object);
    if !params.is_empty() && request_obj.is_none() {
        return Ok(None);
    }

    let mode = request_obj
        .and_then(|obj| obj.get("mode").and_then(Value::as_str))
        .unwrap_or("template");
    if mode != "template" {
        return Ok(None);
    }

    let request_miner_address = request_obj.and_then(|obj| {
        obj.get("mineraddress")
            .or_else(|| obj.get("address"))
            .and_then(Value::as_str)
    });
    if request_miner_address.is_some() {
        return Ok(None);
    }

    let mut guard = wallet
        .lock()
        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "wallet lock poisoned"))?;
    if let Some(address) = guard.default_address().map_err(map_wallet_error)? {
        return Ok(Some(address));
    }

    let address = guard.generate_new_address(true).map_err(map_wallet_error)?;
    Ok(Some(address))
}

fn system_time_to_unix(time: SystemTime) -> i64 {
    time.duration_since(UNIX_EPOCH)
        .map(|value| value.as_secs() as i64)
        .unwrap_or(0)
}

fn peer_kind_name(kind: PeerKind) -> &'static str {
    match kind {
        PeerKind::Block => "block",
        PeerKind::Header => "header",
        PeerKind::Relay => "relay",
    }
}

fn resolve_block_hash<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    value: &Value,
) -> Result<(Hash256, HeaderEntry), RpcError> {
    let hash = if let Some(height) = parse_height_opt(value)? {
        let best_height = best_block_height(chainstate)?;
        if height < 0 || height > best_height {
            return Err(RpcError::new(
                RPC_INVALID_PARAMETER,
                "block height out of range",
            ));
        }
        chainstate
            .height_hash(height)
            .map_err(map_internal)?
            .ok_or_else(|| RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "block not found"))?
    } else {
        parse_hash(value)?
    };
    let entry = chainstate
        .header_entry(&hash)
        .map_err(map_internal)?
        .ok_or_else(|| RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "block not found"))?;
    Ok((hash, entry))
}

fn parse_hash(value: &Value) -> Result<Hash256, RpcError> {
    let text = value
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "hash must be a string"))?;
    hash256_from_hex(text).map_err(|_| RpcError::new(RPC_INVALID_PARAMETER, "invalid hash"))
}

fn parse_hash_sethex(value: &Value) -> Result<Option<Hash256>, RpcError> {
    let text = value
        .as_str()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "hash must be a string"))?;

    let mut text = text.trim_start();
    if let Some(stripped) = text.strip_prefix("0x").or_else(|| text.strip_prefix("0X")) {
        text = stripped;
    }

    let bytes = text.as_bytes();
    let mut end = 0usize;
    while end < bytes.len() && bytes[end].is_ascii_hexdigit() {
        end += 1;
    }

    let mut hex = &text[..end];
    if hex.is_empty() {
        return Ok(None);
    }
    if hex.len() > 64 {
        hex = &hex[hex.len() - 64..];
    }

    let hash =
        hash256_from_hex(hex).map_err(|_| RpcError::new(RPC_INVALID_PARAMETER, "invalid hash"))?;
    Ok(Some(hash))
}

fn parse_height(value: &Value) -> Result<i32, RpcError> {
    if let Some(height) = parse_height_opt(value)? {
        return Ok(height);
    }
    Err(RpcError::new(
        RPC_INVALID_PARAMETER,
        "height must be numeric",
    ))
}

fn parse_height_opt(value: &Value) -> Result<Option<i32>, RpcError> {
    if let Some(height) = value.as_i64() {
        return Ok(Some(height as i32));
    }
    let text = match value.as_str() {
        Some(text) => text,
        None => return Ok(None),
    };
    if text.chars().all(|c| c.is_ascii_digit()) {
        let parsed = text
            .parse::<i32>()
            .map_err(|_| RpcError::new(RPC_INVALID_PARAMETER, "invalid height"))?;
        return Ok(Some(parsed));
    }
    Ok(None)
}

fn parse_u32(value: &Value, label: &str) -> Result<u32, RpcError> {
    if let Some(num) = value.as_u64() {
        if num <= u32::MAX as u64 {
            return Ok(num as u32);
        }
    }
    if let Some(num) = value.as_i64() {
        if num >= 0 && num <= u32::MAX as i64 {
            return Ok(num as u32);
        }
    }
    if let Some(text) = value.as_str() {
        if text.chars().all(|c| c.is_ascii_digit()) {
            let parsed = text
                .parse::<u32>()
                .map_err(|_| RpcError::new(RPC_INVALID_PARAMETER, "invalid number"))?;
            return Ok(parsed);
        }
    }
    Err(RpcError::new(
        RPC_INVALID_PARAMETER,
        format!("{label} must be numeric"),
    ))
}

fn parse_i64(value: &Value, label: &str) -> Result<i64, RpcError> {
    if let Some(num) = value.as_i64() {
        return Ok(num);
    }
    if let Some(num) = value.as_u64() {
        if num <= i64::MAX as u64 {
            return Ok(num as i64);
        }
    }
    if let Some(text) = value.as_str() {
        let text = text.trim();
        if text.is_empty() {
            return Err(RpcError::new(RPC_INVALID_PARAMETER, "invalid number"));
        }
        let parsed = text
            .parse::<i64>()
            .map_err(|_| RpcError::new(RPC_INVALID_PARAMETER, "invalid number"))?;
        return Ok(parsed);
    }
    Err(RpcError::new(
        RPC_INVALID_PARAMETER,
        format!("{label} must be numeric"),
    ))
}

fn parse_f64(value: &Value, label: &str) -> Result<f64, RpcError> {
    if let Some(num) = value.as_f64() {
        return Ok(num);
    }
    if let Some(num) = value.as_i64() {
        return Ok(num as f64);
    }
    if let Some(num) = value.as_u64() {
        return Ok(num as f64);
    }
    if let Some(text) = value.as_str() {
        let text = text.trim();
        if text.is_empty() {
            return Err(RpcError::new(RPC_INVALID_PARAMETER, "invalid number"));
        }
        let parsed = text
            .parse::<f64>()
            .map_err(|_| RpcError::new(RPC_INVALID_PARAMETER, "invalid number"))?;
        return Ok(parsed);
    }
    Err(RpcError::new(
        RPC_INVALID_PARAMETER,
        format!("{label} must be numeric"),
    ))
}

fn parse_bool(value: &Value) -> Result<bool, RpcError> {
    value
        .as_bool()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "boolean expected"))
}

fn parse_verbose_flag(value: &Value) -> Result<bool, RpcError> {
    if let Some(flag) = value.as_bool() {
        return Ok(flag);
    }
    if let Some(flag) = value.as_i64() {
        return Ok(flag != 0);
    }
    Err(RpcError::new(
        RPC_INVALID_PARAMETER,
        "verbose flag must be boolean or numeric",
    ))
}

fn parse_verbosity(value: &Value) -> Result<i32, RpcError> {
    let verbosity = value
        .as_i64()
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "verbosity must be numeric"))?;
    match verbosity {
        0..=2 => Ok(verbosity as i32),
        _ => Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "verbosity must be 0, 1, or 2",
        )),
    }
}

fn parse_addresses_param<'a>(
    value: &'a Value,
) -> Result<(Vec<String>, Option<&'a serde_json::Map<String, Value>>), RpcError> {
    match value {
        Value::String(address) => Ok((vec![address.clone()], None)),
        Value::Object(map) => {
            let addresses = map
                .get("addresses")
                .and_then(|value| value.as_array())
                .ok_or_else(|| {
                    RpcError::new(
                        RPC_INVALID_ADDRESS_OR_KEY,
                        "Addresses is expected to be an array",
                    )
                })?;
            let mut out = Vec::with_capacity(addresses.len());
            for entry in addresses {
                let address = entry
                    .as_str()
                    .ok_or_else(|| RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "Invalid address"))?;
                out.push(address.to_string());
            }
            Ok((out, Some(map)))
        }
        _ => Err(RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "Invalid address")),
    }
}

fn decode_address_scripts(
    addresses: Vec<String>,
    network: Network,
) -> Result<Vec<(String, Vec<u8>)>, RpcError> {
    let mut out = Vec::with_capacity(addresses.len());
    for address in addresses {
        let script = address_to_script_pubkey(&address, network).map_err(|err| match err {
            AddressError::InvalidLength
            | AddressError::InvalidCharacter
            | AddressError::InvalidChecksum
            | AddressError::UnknownPrefix => {
                RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "Invalid address")
            }
        })?;
        out.push((address, script));
    }
    Ok(out)
}

fn parse_chain_info_flag(opts: Option<&serde_json::Map<String, Value>>) -> Result<bool, RpcError> {
    let Some(map) = opts else {
        return Ok(false);
    };
    let Some(value) = map.get("chainInfo") else {
        return Ok(false);
    };
    parse_bool(value)
}

fn parse_height_range<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    opts: Option<&serde_json::Map<String, Value>>,
) -> Result<Option<(u32, u32)>, RpcError> {
    let Some(map) = opts else {
        return Ok(None);
    };
    let Some(start_value) = map.get("start") else {
        return Ok(None);
    };
    let Some(end_value) = map.get("end") else {
        return Ok(None);
    };
    if start_value.is_null() || end_value.is_null() {
        return Ok(None);
    }
    let start = parse_u32(start_value, "start")?;
    let end = parse_u32(end_value, "end")?;
    if start == 0 || end == 0 {
        return Err(RpcError::new(
            RPC_INVALID_ADDRESS_OR_KEY,
            "Start and end are expected to be greater than zero",
        ));
    }
    if end < start {
        return Err(RpcError::new(
            RPC_INVALID_ADDRESS_OR_KEY,
            "End value is expected to be greater than start",
        ));
    }
    let best_height = best_block_height(chainstate)?;
    let best_u32 = u32::try_from(best_height).unwrap_or(0);
    if start > best_u32 || end > best_u32 {
        return Err(RpcError::new(
            RPC_INVALID_ADDRESS_OR_KEY,
            "Start or end is outside chain range",
        ));
    }
    Ok(Some((start, end)))
}

fn ensure_no_params(params: &[Value]) -> Result<(), RpcError> {
    if params.is_empty() {
        Ok(())
    } else {
        Err(RpcError::new(
            RPC_INVALID_PARAMETER,
            "method takes no parameters",
        ))
    }
}

fn best_block_height<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
) -> Result<i32, RpcError> {
    Ok(chainstate
        .best_block()
        .map_err(map_internal)?
        .map(|tip| tip.height)
        .unwrap_or(0))
}

fn confirmations_for_height<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    height: i32,
    best_height: i32,
    hash: &Hash256,
) -> Result<i32, RpcError> {
    if height < 0 || height > best_height {
        return Ok(-1);
    }
    let main_hash = chainstate.height_hash(height).map_err(map_internal)?;
    if main_hash.as_ref() != Some(hash) {
        return Ok(-1);
    }
    Ok(best_height - height + 1)
}

fn next_hash_for_height<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    height: i32,
    best_height: i32,
    hash: &Hash256,
) -> Result<Option<Hash256>, RpcError> {
    if height < 0 || height >= best_height {
        return Ok(None);
    }
    let main_hash = chainstate.height_hash(height).map_err(map_internal)?;
    if main_hash.as_ref() != Some(hash) {
        return Ok(None);
    }
    chainstate.height_hash(height + 1).map_err(map_internal)
}

fn median_time_past<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    height: i32,
) -> Result<i64, RpcError> {
    let mut times = Vec::with_capacity(11);
    let mut current = height;
    for _ in 0..11 {
        if current < 0 {
            break;
        }
        let Some(hash) = chainstate.height_hash(current).map_err(map_internal)? else {
            break;
        };
        let entry = chainstate
            .header_entry(&hash)
            .map_err(map_internal)?
            .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "missing header entry"))?;
        times.push(entry.time as i64);
        current -= 1;
    }
    times.sort_unstable();
    Ok(times.get(times.len() / 2).copied().unwrap_or(0))
}

fn spent_details_address(
    address_type: u32,
    address_hash: &[u8; 20],
    network: Network,
) -> Option<String> {
    match address_type {
        1 => {
            let mut script = Vec::with_capacity(25);
            script.extend_from_slice(&[0x76, 0xa9, 0x14]);
            script.extend_from_slice(address_hash);
            script.extend_from_slice(&[0x88, 0xac]);
            script_pubkey_to_address(&script, network)
        }
        2 => {
            let mut script = Vec::with_capacity(23);
            script.extend_from_slice(&[0xa9, 0x14]);
            script.extend_from_slice(address_hash);
            script.push(0x87);
            script_pubkey_to_address(&script, network)
        }
        _ => None,
    }
}

fn resolve_prevout_via_txindex<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    tx_cache: &mut HashMap<Hash256, Transaction>,
    outpoint: &fluxd_primitives::outpoint::OutPoint,
    network: Network,
) -> Result<(i64, Option<String>), RpcError> {
    let prev_txid = outpoint.hash;
    if !tx_cache.contains_key(&prev_txid) {
        let location = chainstate
            .tx_location(&prev_txid)
            .map_err(map_internal)?
            .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "Spent information not available"))?;
        let bytes = chainstate
            .read_block(location.block)
            .map_err(map_internal)?;
        let block =
            fluxd_primitives::block::Block::consensus_decode(&bytes).map_err(map_internal)?;
        let tx_index = location.index as usize;
        let tx = block
            .transactions
            .get(tx_index)
            .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "Spent information not available"))?
            .clone();
        tx_cache.insert(prev_txid, tx);
    }

    let tx = tx_cache
        .get(&prev_txid)
        .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "Spent information not available"))?;
    let output_index = usize::try_from(outpoint.index)
        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "Spent information not available"))?;
    let output = tx
        .vout
        .get(output_index)
        .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "Spent information not available"))?;
    Ok((
        output.value,
        script_pubkey_to_address(&output.script_pubkey, network),
    ))
}

fn build_upgrade_info(params: &ChainParams, height: i32) -> Value {
    let mut map = serde_json::Map::new();
    for idx in ALL_UPGRADES {
        let upgrade = params.consensus.upgrades[idx.as_usize()];
        if upgrade.activation_height
            == fluxd_consensus::upgrades::NetworkUpgrade::NO_ACTIVATION_HEIGHT
        {
            continue;
        }
        let info = NETWORK_UPGRADE_INFO[idx.as_usize()];
        let status = match network_upgrade_state(height, &params.consensus.upgrades, idx) {
            UpgradeState::Active => "active",
            UpgradeState::Pending => "pending",
            UpgradeState::Disabled => "disabled",
        };
        let entry = json!({
            "name": info.name,
            "activationheight": upgrade.activation_height,
            "status": status,
            "info": info.info,
        });
        map.insert(format!("{:08x}", info.branch_id), entry);
    }
    Value::Object(map)
}

fn block_header_version(bytes: &[u8]) -> Result<i32, RpcError> {
    if bytes.len() < 4 {
        return Err(RpcError::new(
            RPC_INTERNAL_ERROR,
            "invalid block header bytes",
        ));
    }
    let mut buf = [0u8; 4];
    buf.copy_from_slice(&bytes[..4]);
    Ok(i32::from_le_bytes(buf))
}

fn build_softfork_info<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    tip: Option<Hash256>,
    consensus: &fluxd_consensus::params::ConsensusParams,
) -> Result<Value, RpcError> {
    let window = consensus.majority_window;
    let mut found_v2 = 0i32;
    let mut found_v3 = 0i32;
    let mut found_v4 = 0i32;

    let mut cursor = tip;
    for _ in 0..window {
        let Some(hash) = cursor else { break };
        let entry = chainstate
            .header_entry(&hash)
            .map_err(map_internal)?
            .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "missing header entry"))?;
        let bytes = chainstate
            .block_header_bytes(&hash)
            .map_err(map_internal)?
            .ok_or_else(|| RpcError::new(RPC_INTERNAL_ERROR, "missing block header bytes"))?;
        let version = block_header_version(&bytes)?;
        if version >= 2 {
            found_v2 = found_v2.saturating_add(1);
            if version >= 3 {
                found_v3 = found_v3.saturating_add(1);
                if version >= 4 {
                    found_v4 = found_v4.saturating_add(1);
                }
            }
        }
        cursor = if entry.height > 0 {
            Some(entry.prev_hash)
        } else {
            None
        };
    }

    let enforce_required = consensus.majority_enforce_block_upgrade;
    let reject_required = consensus.majority_reject_block_outdated;

    fn majority_desc(found: i32, required: i32, window: i32) -> Value {
        json!({
            "status": found >= required,
            "found": found,
            "required": required,
            "window": window,
        })
    }

    fn softfork_desc(
        id: &'static str,
        version: i32,
        found: i32,
        enforce_required: i32,
        reject_required: i32,
        window: i32,
    ) -> Value {
        json!({
            "id": id,
            "version": version,
            "enforce": majority_desc(found, enforce_required, window),
            "reject": majority_desc(found, reject_required, window),
        })
    }

    Ok(Value::Array(vec![
        softfork_desc(
            "bip34",
            2,
            found_v2,
            enforce_required,
            reject_required,
            window,
        ),
        softfork_desc(
            "bip66",
            3,
            found_v3,
            enforce_required,
            reject_required,
            window,
        ),
        softfork_desc(
            "bip65",
            4,
            found_v4,
            enforce_required,
            reject_required,
            window,
        ),
    ]))
}

fn network_name(network: Network) -> &'static str {
    match network {
        Network::Mainnet => "main",
        Network::Testnet => "test",
        Network::Regtest => "regtest",
    }
}

fn difficulty_from_bits(bits: u32, params: &ChainParams) -> Result<f64, String> {
    let target = compact_to_u256(bits).map_err(|err| err.to_string())?;
    if target.is_zero() {
        return Ok(0.0);
    }
    let pow_limit = U256::from_little_endian(&params.consensus.pow_limit);
    let pow_limit_f = u256_to_f64(pow_limit);
    let target_f = u256_to_f64(target);
    if target_f == 0.0 {
        return Ok(0.0);
    }
    Ok(pow_limit_f / target_f)
}

fn u256_to_f64(value: U256) -> f64 {
    let bytes = value.to_big_endian();
    let mut acc = 0f64;
    for byte in bytes {
        acc = acc * 256.0 + byte as f64;
    }
    acc
}

fn node_version() -> i64 {
    let version = env!("CARGO_PKG_VERSION");
    let mut parts = version.split('.');
    let major = parts
        .next()
        .and_then(|part| part.parse::<i64>().ok())
        .unwrap_or(0);
    let minor = parts
        .next()
        .and_then(|part| part.parse::<i64>().ok())
        .unwrap_or(0);
    let patch = parts
        .next()
        .and_then(|part| part.parse::<i64>().ok())
        .unwrap_or(0);
    major * 10000 + minor * 100 + patch
}

fn format_outpoint(outpoint: &fluxd_primitives::outpoint::OutPoint) -> String {
    format!("{}:{}", hash256_to_hex(&outpoint.hash), outpoint.index)
}

fn parse_outpoint(input: &str) -> Result<OutPoint, RpcError> {
    let (txid_hex, index_str) = input
        .trim()
        .split_once(':')
        .ok_or_else(|| RpcError::new(RPC_INVALID_PARAMETER, "outpoint must be txid:vout"))?;
    let hash = hash256_from_hex(txid_hex)
        .map_err(|_| RpcError::new(RPC_INVALID_PARAMETER, "invalid txid"))?;
    let index = index_str
        .parse::<u32>()
        .map_err(|_| RpcError::new(RPC_INVALID_PARAMETER, "invalid vout"))?;
    Ok(OutPoint { hash, index })
}

fn fluxnode_network_info(address: &str) -> (String, String) {
    let address = address.trim();
    if address.is_empty() {
        return (String::new(), String::new());
    }

    if let Ok(addr) = address.parse::<SocketAddr>() {
        let ip = addr.ip();
        let network = match ip {
            IpAddr::V4(_) => "ipv4",
            IpAddr::V6(_) => "ipv6",
        };
        return (ip.to_string(), network.to_string());
    }

    let host = if let Some(rest) = address.strip_prefix('[') {
        rest.split_once(']')
            .map(|(host, _)| host)
            .unwrap_or(address)
    } else if let Some((host, port)) = address.rsplit_once(':') {
        if !host.is_empty() && port.chars().all(|ch| ch.is_ascii_digit()) {
            host
        } else {
            address
        }
    } else {
        address
    };

    let network = if host.ends_with(".onion") {
        "onion"
    } else if host.parse::<std::net::Ipv4Addr>().is_ok() {
        "ipv4"
    } else if host.parse::<std::net::Ipv6Addr>().is_ok() {
        "ipv6"
    } else {
        "unknown"
    };

    (host.to_string(), network.to_string())
}

#[derive(Clone, Debug)]
struct FluxnodeConfEntry {
    alias: String,
    address: String,
    privkey: String,
    collateral: OutPoint,
    collateral_privkey: Option<String>,
    redeem_script: Option<String>,
}

fn read_fluxnode_conf(data_dir: &Path) -> Result<Vec<FluxnodeConfEntry>, RpcError> {
    let path = data_dir.join("fluxnode.conf");
    if !path.exists() {
        return Ok(Vec::new());
    }
    let contents = fs::read_to_string(&path).map_err(map_internal)?;
    let mut entries = Vec::new();
    let mut invalid = 0usize;
    for line in contents.lines() {
        let line = line.trim();
        if line.is_empty() || line.starts_with('#') {
            continue;
        }
        let parts: Vec<&str> = line.split_whitespace().collect();
        if parts.len() < 5 {
            invalid = invalid.saturating_add(1);
            continue;
        }
        let alias = parts[0].to_string();
        let address = parts[1].to_string();
        let privkey = parts[2].to_string();
        let txhash = parts[3];
        let outidx = parts[4];
        let Ok(hash) = hash256_from_hex(txhash) else {
            invalid = invalid.saturating_add(1);
            continue;
        };
        let Ok(index) = outidx.parse::<u32>() else {
            invalid = invalid.saturating_add(1);
            continue;
        };
        entries.push(FluxnodeConfEntry {
            alias,
            address,
            privkey,
            collateral: OutPoint { hash, index },
            collateral_privkey: parts.get(5).map(|value| (*value).to_string()),
            redeem_script: parts.get(6).map(|value| (*value).to_string()),
        });
    }
    if entries.is_empty() && invalid > 0 {
        return Err(RpcError::new(
            RPC_INTERNAL_ERROR,
            "fluxnode.conf contains no valid entries",
        ));
    }
    Ok(entries)
}

fn parse_wif_secret_key(wif: &str, network: Network) -> Result<(SecretKey, bool), RpcError> {
    let (secret, compressed) = wif_to_secret_key(wif, network)
        .map_err(|_| RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "Invalid private key encoding"))?;
    let secret = SecretKey::from_slice(&secret)
        .map_err(|_| RpcError::new(RPC_INVALID_ADDRESS_OR_KEY, "Invalid private key"))?;
    Ok((secret, compressed))
}

fn secret_key_pubkey_bytes(secret: &SecretKey, compressed: bool) -> Vec<u8> {
    let secp = Secp256k1::signing_only();
    let pubkey = PublicKey::from_secret_key(&secp, secret);
    if compressed {
        pubkey.serialize().to_vec()
    } else {
        pubkey.serialize_uncompressed().to_vec()
    }
}

fn sign_compact_message(
    secret: &SecretKey,
    compressed: bool,
    message: &[u8],
) -> Result<[u8; 65], RpcError> {
    let digest = signed_message_hash(message);
    let msg = Message::from_digest_slice(&digest)
        .map_err(|_| RpcError::new(RPC_INTERNAL_ERROR, "Invalid message digest"))?;
    let secp = Secp256k1::signing_only();
    let sig: RecoverableSignature = secp.sign_ecdsa_recoverable(&msg, secret);
    let (rec_id, sig_bytes) = sig.serialize_compact();
    let header = 27u8
        .saturating_add(rec_id.to_i32().try_into().unwrap_or(0))
        .saturating_add(if compressed { 4 } else { 0 });
    let mut out = [0u8; 65];
    out[0] = header;
    out[1..].copy_from_slice(&sig_bytes);
    Ok(out)
}

fn fluxnode_payment_address<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    record: &FluxnodeRecord,
    chain_params: &ChainParams,
) -> Result<Option<String>, RpcError> {
    let network = chain_params.network;
    if let Some(key) = record.p2sh_script {
        let script = chainstate.fluxnode_key(key).map_err(map_internal)?;
        let Some(script) = script else {
            return Ok(None);
        };
        let inner = hash160(&script);
        let mut pubkey = Vec::with_capacity(23);
        pubkey.extend_from_slice(&[0xa9, 0x14]);
        pubkey.extend_from_slice(&inner);
        pubkey.push(0x87);
        return Ok(script_pubkey_to_address(&pubkey, network));
    }
    if let Some(key) = record.collateral_pubkey {
        let pubkey = chainstate.fluxnode_key(key).map_err(map_internal)?;
        let Some(pubkey) = pubkey else {
            return Ok(None);
        };
        let is_p2sh_signing_key = chain_params
            .fluxnode
            .p2sh_public_keys
            .iter()
            .filter_map(|key| bytes_from_hex(key.key))
            .any(|expected| expected == pubkey);
        if is_p2sh_signing_key {
            let utxo = chainstate
                .utxo_entry(&record.collateral)
                .map_err(map_internal)?;
            let Some(utxo) = utxo else {
                return Ok(None);
            };
            return Ok(script_pubkey_to_address(&utxo.script_pubkey, network));
        }
        let hash = hash160(&pubkey);
        let mut script = Vec::with_capacity(25);
        script.extend_from_slice(&[0x76, 0xa9, 0x14]);
        script.extend_from_slice(&hash);
        script.extend_from_slice(&[0x88, 0xac]);
        return Ok(script_pubkey_to_address(&script, network));
    }
    Ok(None)
}

fn fluxnode_status_payment_address<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    record: &FluxnodeRecord,
    network: Network,
) -> Result<Option<String>, RpcError> {
    if let Some(key) = record.p2sh_script {
        let script = chainstate.fluxnode_key(key).map_err(map_internal)?;
        let Some(script) = script else {
            return Ok(None);
        };
        let inner = hash160(&script);
        let mut pubkey = Vec::with_capacity(23);
        pubkey.extend_from_slice(&[0xa9, 0x14]);
        pubkey.extend_from_slice(&inner);
        pubkey.push(0x87);
        return Ok(script_pubkey_to_address(&pubkey, network));
    }
    if let Some(key) = record.collateral_pubkey {
        let pubkey = chainstate.fluxnode_key(key).map_err(map_internal)?;
        let Some(pubkey) = pubkey else {
            return Ok(None);
        };
        let hash = hash160(&pubkey);
        let mut script = Vec::with_capacity(25);
        script.extend_from_slice(&[0x76, 0xa9, 0x14]);
        script.extend_from_slice(&hash);
        script.extend_from_slice(&[0x88, 0xac]);
        return Ok(script_pubkey_to_address(&script, network));
    }
    Ok(None)
}

fn header_time_at_height<S: fluxd_storage::KeyValueStore>(
    chainstate: &ChainState<S>,
    height: i32,
) -> Option<u32> {
    if height < 0 {
        return None;
    }
    let hash = chainstate.height_hash(height).ok().flatten()?;
    chainstate
        .header_entry(&hash)
        .ok()
        .flatten()
        .map(|entry| entry.time)
}

fn hex_bytes(bytes: &[u8]) -> String {
    let mut out = String::with_capacity(bytes.len() * 2);
    for byte in bytes {
        out.push(hex_digit(byte >> 4));
        out.push(hex_digit(byte & 0x0f));
    }
    out
}

fn hex_digit(value: u8) -> char {
    match value {
        0..=9 => (b'0' + value) as char,
        _ => (b'a' + (value - 10)) as char,
    }
}

fn bytes_from_hex(input: &str) -> Option<Vec<u8>> {
    let mut hex = input.trim();
    if let Some(stripped) = hex.strip_prefix("0x").or_else(|| hex.strip_prefix("0X")) {
        hex = stripped;
    }
    if hex.len() % 2 == 1 {
        return None;
    }
    let mut bytes = Vec::with_capacity(hex.len() / 2);
    let mut iter = hex.as_bytes().iter().copied();
    while let (Some(high), Some(low)) = (iter.next(), iter.next()) {
        let high = (high as char).to_digit(16)? as u8;
        let low = (low as char).to_digit(16)? as u8;
        bytes.push(high << 4 | low);
    }
    Some(bytes)
}

fn base58check_decode(input: &str) -> Result<Vec<u8>, AddressError> {
    let bytes = base58_decode(input)?;
    if bytes.len() < 4 {
        return Err(AddressError::InvalidLength);
    }
    let (payload, checksum) = bytes.split_at(bytes.len() - 4);
    let digest = sha256d(payload);
    if checksum != &digest[..4] {
        return Err(AddressError::InvalidChecksum);
    }
    Ok(payload.to_vec())
}

fn base58check_encode(payload: &[u8]) -> String {
    let mut data = Vec::with_capacity(payload.len() + 4);
    data.extend_from_slice(payload);
    let checksum = sha256d(payload);
    data.extend_from_slice(&checksum[..4]);
    base58_encode(&data)
}

fn base58_decode(input: &str) -> Result<Vec<u8>, AddressError> {
    if input.is_empty() {
        return Err(AddressError::InvalidLength);
    }
    let mut bytes: Vec<u8> = Vec::new();
    for ch in input.bytes() {
        let value = base58_value(ch).ok_or(AddressError::InvalidCharacter)? as u32;
        let mut carry = value;
        for byte in bytes.iter_mut().rev() {
            let val = (*byte as u32) * 58 + carry;
            *byte = (val & 0xff) as u8;
            carry = val >> 8;
        }
        while carry > 0 {
            bytes.insert(0, (carry & 0xff) as u8);
            carry >>= 8;
        }
    }

    let leading_zeros = input.bytes().take_while(|b| *b == b'1').count();
    let mut out = vec![0u8; leading_zeros];
    out.extend_from_slice(&bytes);
    Ok(out)
}

fn base58_encode(data: &[u8]) -> String {
    const ALPHABET: &[u8; 58] = b"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    if data.is_empty() {
        return String::new();
    }

    let mut digits: Vec<u8> = vec![0u8];
    for byte in data {
        let mut carry = *byte as u32;
        for digit in digits.iter_mut().rev() {
            let val = (*digit as u32) * 256 + carry;
            *digit = (val % 58) as u8;
            carry = val / 58;
        }
        while carry > 0 {
            digits.insert(0, (carry % 58) as u8);
            carry /= 58;
        }
    }

    let leading_zeros = data.iter().take_while(|b| **b == 0).count();
    let mut out = String::with_capacity(leading_zeros + digits.len());
    for _ in 0..leading_zeros {
        out.push('1');
    }
    for digit in digits {
        out.push(ALPHABET[digit as usize] as char);
    }
    out
}

fn base58_value(ch: u8) -> Option<u8> {
    match ch {
        b'1' => Some(0),
        b'2'..=b'9' => Some(ch - b'1'),
        b'A'..=b'H' => Some(ch - b'A' + 9),
        b'J'..=b'N' => Some(ch - b'J' + 17),
        b'P'..=b'Z' => Some(ch - b'P' + 22),
        b'a'..=b'k' => Some(ch - b'a' + 33),
        b'm'..=b'z' => Some(ch - b'm' + 44),
        _ => None,
    }
}

fn rpc_ok(id: Value, result: Value) -> Value {
    json!({
        "result": result,
        "error": Value::Null,
        "id": id,
    })
}

fn rpc_error(id: Value, code: i64, message: impl Into<String>) -> Value {
    json!({
        "result": Value::Null,
        "error": {
            "code": code,
            "message": message.into(),
        },
        "id": id,
    })
}

fn map_internal(err: impl ToString) -> RpcError {
    RpcError::new(RPC_INTERNAL_ERROR, err.to_string())
}

fn write_cookie(path: &Path, user: &str, pass: &str) -> Result<(), String> {
    let mut file = File::create(path).map_err(|err| err.to_string())?;
    let contents = format!("{user}:{pass}");
    file.write_all(contents.as_bytes())
        .map_err(|err| err.to_string())?;
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        let perms = fs::Permissions::from_mode(0o600);
        fs::set_permissions(path, perms).map_err(|err| err.to_string())?;
    }
    Ok(())
}

#[derive(Debug)]
pub(crate) struct RpcError {
    code: i64,
    message: String,
}

impl RpcError {
    fn new(code: i64, message: impl Into<String>) -> Self {
        Self {
            code,
            message: message.into(),
        }
    }
}

impl std::fmt::Display for RpcError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{} (code {})", self.message, self.code)
    }
}

impl std::error::Error for RpcError {}

struct HttpRequest {
    method: String,
    path: String,
    query: Option<String>,
    headers: HashMap<String, String>,
    body: Vec<u8>,
}

async fn read_http_request(stream: &mut tokio::net::TcpStream) -> Result<HttpRequest, String> {
    let mut buffer = Vec::new();
    let mut temp = [0u8; 4096];
    let mut header_end = None;
    while buffer.len() < MAX_REQUEST_BYTES {
        let read = stream
            .read(&mut temp)
            .await
            .map_err(|err| err.to_string())?;
        if read == 0 {
            break;
        }
        buffer.extend_from_slice(&temp[..read]);
        if let Some(pos) = find_header_end(&buffer) {
            header_end = Some(pos);
            break;
        }
    }

    let header_end = header_end.ok_or_else(|| "invalid http request".to_string())?;
    let header_bytes = &buffer[..header_end];
    let mut headers = HashMap::new();
    let mut lines = header_bytes.split(|byte| *byte == b'\n');
    let request_line = lines
        .next()
        .ok_or_else(|| "invalid http request".to_string())?;
    let request_line = String::from_utf8_lossy(request_line);
    let mut parts = request_line.split_whitespace();
    let method = parts.next().unwrap_or("").to_string();
    let raw_path = parts.next().unwrap_or("/");
    let (path, query) = match raw_path.split_once('?') {
        Some((path, query)) => (path.to_string(), Some(query.to_string())),
        None => (raw_path.to_string(), None),
    };

    for line in lines {
        let line = String::from_utf8_lossy(line).trim().to_string();
        if line.is_empty() {
            continue;
        }
        if let Some((key, value)) = line.split_once(':') {
            headers.insert(key.trim().to_ascii_lowercase(), value.trim().to_string());
        }
    }

    let mut body = buffer[header_end..].to_vec();
    let content_length = headers
        .get("content-length")
        .and_then(|value| value.parse::<usize>().ok())
        .unwrap_or(body.len());
    if content_length > MAX_REQUEST_BYTES {
        return Err("request too large".to_string());
    }
    while body.len() < content_length {
        let read = stream
            .read(&mut temp)
            .await
            .map_err(|err| err.to_string())?;
        if read == 0 {
            break;
        }
        body.extend_from_slice(&temp[..read]);
    }
    body.truncate(content_length);

    Ok(HttpRequest {
        method,
        path,
        query,
        headers,
        body,
    })
}

fn find_header_end(buffer: &[u8]) -> Option<usize> {
    buffer
        .windows(4)
        .position(|window| window == b"\r\n\r\n")
        .map(|pos| pos + 4)
}

impl RpcAuth {
    fn check(&self, header: Option<&str>) -> bool {
        let Some(header) = header else {
            return false;
        };
        let header = header.trim();
        let Some(encoded) = header.strip_prefix("Basic ") else {
            return false;
        };
        let decoded = base64::engine::general_purpose::STANDARD
            .decode(encoded.as_bytes())
            .ok()
            .and_then(|bytes| String::from_utf8(bytes).ok());
        let Some(decoded) = decoded else {
            return false;
        };
        decoded == format!("{}:{}", self.user, self.pass)
    }
}

fn build_response(status: &str, content_type: &str, body: &str) -> Vec<u8> {
    let mut response = String::new();
    response.push_str("HTTP/1.1 ");
    response.push_str(status);
    response.push_str("\r\nContent-Type: ");
    response.push_str(content_type);
    response.push_str("\r\nContent-Length: ");
    response.push_str(&body.len().to_string());
    response.push_str("\r\nConnection: close\r\n\r\n");
    response.push_str(body);
    response.into_bytes()
}

fn build_unauthorized() -> Vec<u8> {
    let body = "unauthorized";
    let mut response = String::new();
    response.push_str("HTTP/1.1 401 Unauthorized\r\n");
    response.push_str(&format!(
        "WWW-Authenticate: Basic realm=\"{RPC_REALM}\"\r\n"
    ));
    response.push_str("Content-Type: text/plain\r\n");
    response.push_str(&format!("Content-Length: {}\r\n", body.len()));
    response.push_str("Connection: close\r\n\r\n");
    response.push_str(body);
    response.into_bytes()
}

fn build_forbidden() -> Vec<u8> {
    build_response("403 Forbidden", "text/plain", "forbidden")
}
